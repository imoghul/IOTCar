###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          02/Apr/2022  22:31:31
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 09\serial.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EW2183.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 09\serial.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 09\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 09\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 09\Debug\List\serial.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 09\Debug\Obj\serial.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 09\serial.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains the Serial Routine - Serial Processes
      4          //
      5          //
      6          //  Ibrahim Moghul
      7          //  Mar 2022
      8          //  Built with IAR Embedded Workbench Version: (7.21.1)
      9          //------------------------------------------------------------------------------
     10          #include "serial.h"
     11          #include "macros.h"
     12          #include <string.h>
     13          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x500
   \   union <unnamed> _A_UCA0CTLW0_L
   \                     _A_UCA0CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x506
   \   union <unnamed> _A_UCA0BRW_L
   \                     _A_UCA0BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x508
   \   union <unnamed> _A_UCA0MCTLW_L
   \                     _A_UCA0MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50c
   \   union <unnamed> _A_UCA0RXBUF_L
   \                     _A_UCA0RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50e
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51c
   \   union <unnamed> _A_UCA0IFG_L
   \                     _A_UCA0IFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51e
   \   union <unnamed> _A_UCA0IV_L
   \                     _A_UCA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x580
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x586
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x588
   \   union <unnamed> _A_UCA1MCTLW_L
   \                     _A_UCA1MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58c
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58e
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59a
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59e
   \   union <unnamed> _A_UCA1IV_L
   \                     _A_UCA1IV_L:
   \   000000                DS8 2
     14          
     15          // global variables

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          volatile unsigned int usb0_rx_wr,usb1_rx_wr;
   \                     usb0_rx_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          unsigned int usb0_rx_rd,usb1_rx_rd;
   \                     usb0_rx_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile char USB0_Char_Rx_Ring[SMALL_RING_SIZE],USB0_Char_Rx_Process[LARGE_RING_SIZE];
   \                     USB0_Char_Rx_Ring:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB0_Char_Rx_Process:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile char USB1_Char_Rx_Ring[SMALL_RING_SIZE],USB1_Char_Rx_Process[LARGE_RING_SIZE];
   \                     USB1_Char_Rx_Ring:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Rx_Process:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          volatile char USB0_Char_Tx[LARGE_RING_SIZE],USB1_Char_Tx[LARGE_RING_SIZE];
   \                     USB0_Char_Tx:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Tx:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          unsigned volatile int pb0_index,pb1_index;
   \                     pb0_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     pb1_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          unsigned volatile int tx0_index,tx1_index;
   \                     tx0_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     tx1_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          unsigned volatile int pb0_buffered,pb1_buffered;
   \                     pb0_buffered:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     pb1_buffered:
   \   000000                DS8 2
     24          extern volatile unsigned char display_changed;
     25          extern char display_line[4][11];

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          unsigned volatile int serialState;
   \                     serialState:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          volatile char receievedFromPC = OFF;
   \                     receievedFromPC:
   \   000000                DS8 1
     28          
     29          //----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
     30          void Init_Serial_UCA(void) {
   \                     Init_Serial_UCA:
     31              int i;
     32          
     33              for(i = 0; i < SMALL_RING_SIZE; i++) {
   \   000000   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_0:
   \   000002   3F901000     CMP.W   #0x10, R15
   \   000006   0634         JGE     ??Init_Serial_UCA_2
     34                  USB0_Char_Rx_Ring[i] = 0x00;
   \   000008   CF43....     MOV.B   #0x0, USB0_Char_Rx_Ring(R15)
     35                  USB1_Char_Rx_Ring[i] = 0x00;
   \   00000C   CF43....     MOV.B   #0x0, USB1_Char_Rx_Ring(R15)
     36              }
   \   000010   1F53         ADD.W   #0x1, R15
   \   000012   F73F         JMP     ??Init_Serial_UCA_0
     37          
     38              usb0_rx_wr = BEGINNING;
   \                     ??Init_Serial_UCA_2:
   \   000014   8243....     MOV.W   #0x0, &usb0_rx_wr
     39              usb0_rx_rd = BEGINNING;
   \   000018   8243....     MOV.W   #0x0, &usb0_rx_rd
     40              usb1_rx_wr = BEGINNING;
   \   00001C   8243....     MOV.W   #0x0, &usb1_rx_wr
     41              usb1_rx_rd = BEGINNING;
   \   000020   8243....     MOV.W   #0x0, &usb1_rx_rd
     42          
     43              for(i = 0; i < LARGE_RING_SIZE; i++) {
   \   000024   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_1:
   \   000026   3F901900     CMP.W   #0x19, R15
   \   00002A   0634         JGE     ??Init_Serial_UCA_3
     44                  USB0_Char_Tx[i] = 0x00;
   \   00002C   CF43....     MOV.B   #0x0, USB0_Char_Tx(R15)
     45                  USB1_Char_Tx[i] = 0x00;
   \   000030   CF43....     MOV.B   #0x0, USB1_Char_Tx(R15)
     46              }
   \   000034   1F53         ADD.W   #0x1, R15
   \   000036   F73F         JMP     ??Init_Serial_UCA_1
     47          
     48              //usb0_tx_ring_wr = BEGINNING;
     49              //usb0_tx_ring_rd = BEGINNING;
     50              //usb1_tx_ring_wr = BEGINNING;
     51              //usb1_tx_ring_rd = BEGINNING;
     52              
     53              // Configure UART 0
     54              UCA0CTLW0 = 0;
   \                     ??Init_Serial_UCA_3:
   \   000038   82430005     MOV.W   #0x0, &0x500
     55              UCA0CTLW0 |= UCSWRST;
   \   00003C   92D30005     BIS.W   #0x1, &0x500
     56              UCA0CTLW0 |= UCSSEL__SMCLK;
   \   000040   B2D080000005 BIS.W   #0x80, &0x500
     57              UCA0BRW = 4;
   \   000046   A2420605     MOV.W   #0x4, &0x506
     58              UCA0MCTLW = 0x5551;
   \   00004A   B24051550805 MOV.W   #0x5551, &0x508
     59              UCA0CTLW0 &= ~UCSWRST;
   \   000050   92C30005     BIC.W   #0x1, &0x500
     60              UCA0IE |= UCRXIE;
   \   000054   92D31A05     BIS.W   #0x1, &0x51a
     61              // Configure UART 1
     62              UCA1CTLW0 = 0;
   \   000058   82438005     MOV.W   #0x0, &0x580
     63              UCA1CTLW0 |= UCSWRST;
   \   00005C   92D38005     BIS.W   #0x1, &0x580
     64              UCA1CTLW0 |= UCSSEL__SMCLK;
   \   000060   B2D080008005 BIS.W   #0x80, &0x580
     65              UCA1BRW = 4;
   \   000066   A2428605     MOV.W   #0x4, &0x586
     66              UCA1MCTLW = 0x5551;
   \   00006A   B24051558805 MOV.W   #0x5551, &0x588
     67              UCA1CTLW0 &= ~UCSWRST;
   \   000070   92C38005     BIC.W   #0x1, &0x580
     68              UCA1IE |= UCRXIE;
   \   000074   92D39A05     BIS.W   #0x1, &0x59a
     69          }
   \   000078   1001         RETA
   \   00007A                REQUIRE _A_UCA0CTLW0_L
   \   00007A                REQUIRE _A_UCA0BRW_L
   \   00007A                REQUIRE _A_UCA0MCTLW_L
   \   00007A                REQUIRE _A_UCA0IE_L
   \   00007A                REQUIRE _A_UCA1CTLW0_L
   \   00007A                REQUIRE _A_UCA1BRW_L
   \   00007A                REQUIRE _A_UCA1MCTLW_L
   \   00007A                REQUIRE _A_UCA1IE_L
     70          //------------------------------------------------------------------------------
     71          #pragma vector=EUSCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
     72          __interrupt void eUSCI_A0_ISR(void) {
   \                     eUSCI_A0_ISR:
   \   000000   2F15         PUSHM.W #0x3, R15
     73              unsigned int temp;
     74          
     75              switch(__even_in_range(UCA0IV, 0x08)) {
   \   000002   1F421E05     MOV.W   &0x51e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A0_ISR>_0`:
   \   000008   383C         JMP     ??eUSCI_A0_ISR_0
   \   00000A   033C         JMP     ??eUSCI_A0_ISR_4
   \   00000C   1E3C         JMP     ??eUSCI_A0_ISR_5
   \   00000E   353C         JMP     ??eUSCI_A0_ISR_0
   \   000010   343C         JMP     ??eUSCI_A0_ISR_0
     76                  case 0:
     77                      break;
     78          
     79                  case 2: // RXIFG
     80                    
     81                      temp = usb0_rx_wr++;
   \                     ??eUSCI_A0_ISR_4:
   \   000012   1F42....     MOV.W   &usb0_rx_wr, R15
   \   000016   0E4F         MOV.W   R15, R14
   \   000018   1E53         ADD.W   #0x1, R14
   \   00001A   824E....     MOV.W   R14, &usb0_rx_wr
   \   00001E   0D4F         MOV.W   R15, R13
     82                      USB0_Char_Rx_Ring[temp] = UCA0RXBUF;
   \   000020   1E420C05     MOV.W   &0x50c, R14
   \   000024   CD4E....     MOV.B   R14, USB0_Char_Rx_Ring(R13)
     83                      if(receievedFromPC) UCA1TXBUF=USB0_Char_Rx_Ring[temp];
   \   000028   C293....     CMP.B   #0x0, &receievedFromPC
   \   00002C   0524         JEQ     ??eUSCI_A0_ISR_1
   \   00002E   5F4D....     MOV.B   USB0_Char_Rx_Ring(R13), R15
   \   000032   4F4F         MOV.B   R15, R15
   \   000034   824F8E05     MOV.W   R15, &0x58e
     84                      if (usb0_rx_wr >= (sizeof(USB0_Char_Rx_Ring))) {
   \                     ??eUSCI_A0_ISR_1:
   \   000038   B2901000.... CMP.W   #0x10, &usb0_rx_wr
   \   00003E   0228         JNC     ??eUSCI_A0_ISR_2
     85                          usb0_rx_wr = BEGINNING;
   \   000040   8243....     MOV.W   #0x0, &usb0_rx_wr
     86                      }
     87                      
     88                      serialState = 2;
   \                     ??eUSCI_A0_ISR_2:
   \   000044   A243....     MOV.W   #0x2, &serialState
     89                    
     90          
     91                      break;
   \   000048   183C         JMP     ??eUSCI_A0_ISR_0
     92          
     93                  case 4: // TXIFG
     94                    //if(receievedFromPC==OFF) {
     95                    //  UCA0IE &= ~UCTXIE;
     96                    //  return;
     97                    //}
     98                    UCA0TXBUF = USB0_Char_Tx[tx0_index];
   \                     ??eUSCI_A0_ISR_5:
   \   00004A   1F42....     MOV.W   &tx0_index, R15
   \   00004E   5F4F....     MOV.B   USB0_Char_Tx(R15), R15
   \   000052   4F4F         MOV.B   R15, R15
   \   000054   824F0E05     MOV.W   R15, &0x50e
     99                    USB0_Char_Tx[tx0_index++] = 0;
   \   000058   1F42....     MOV.W   &tx0_index, R15
   \   00005C   0E4F         MOV.W   R15, R14
   \   00005E   1E53         ADD.W   #0x1, R14
   \   000060   824E....     MOV.W   R14, &tx0_index
   \   000064   CF43....     MOV.B   #0x0, USB0_Char_Tx(R15)
    100                    if(USB0_Char_Tx[tx0_index] == 0) {
   \   000068   1F42....     MOV.W   &tx0_index, R15
   \   00006C   CF93....     CMP.B   #0x0, USB0_Char_Tx(R15)
   \   000070   0220         JNE     ??eUSCI_A0_ISR_3
    101                      UCA0IE &= ~UCTXIE;
   \   000072   A2C31A05     BIC.W   #0x2, &0x51a
    102                      //clearProcessBuff_0();
    103                    }
    104                    serialState = 1;
   \                     ??eUSCI_A0_ISR_3:
   \   000076   9243....     MOV.W   #0x1, &serialState
    105                    
    106                    break;
    107          
    108                  default:
    109                      break;
    110              }
    111          }
   \                     ??eUSCI_A0_ISR_0:
   \   00007A   2D17         POPM.W  #0x3, R15
   \   00007C   0013         RETI
   \   00007E                REQUIRE _A_UCA0RXBUF_L
   \   00007E                REQUIRE _A_UCA1TXBUF_L
   \   00007E                REQUIRE _A_UCA0TXBUF_L
   \   00007E                REQUIRE _A_UCA0IE_L
   \   00007E                REQUIRE _A_UCA0IV_L
    112          
    113          #pragma vector=EUSCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    114          __interrupt void eUSCI_A1_ISR(void) {
   \                     eUSCI_A1_ISR:
   \   000000   5F15         PUSHM.W #0x6, R15
    115              unsigned int temp;
    116          
    117              switch(__even_in_range(UCA1IV, 0x08)) {
   \   000002   1F429E05     MOV.W   &0x59e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A1_ISR>_0`:
   \   000008   3C3C         JMP     ??eUSCI_A1_ISR_1
   \   00000A   033C         JMP     ??eUSCI_A1_ISR_5
   \   00000C   1E3C         JMP     ??eUSCI_A1_ISR_6
   \   00000E   393C         JMP     ??eUSCI_A1_ISR_1
   \   000010   383C         JMP     ??eUSCI_A1_ISR_1
    118                  case 0:
    119                      break;
    120          
    121                  case 2: // RXIFG
    122                    char recieved = UCA1RXBUF;
                           ^
Warning[Pe1072]: a declaration cannot have a label

      switch(__even_in_range(UCA1IV, 0x08)) {
      ^
"C:\Users\saad\Documents\ece-306\Project 09\serial.c",117  Warning[Pe546]: 
          transfer of control bypasses initialization of:
            variable "recieved" (declared at line 122)
   \                     ??eUSCI_A1_ISR_5:
   \   000012   1A428C05     MOV.W   &0x58c, R10
    123                      temp = usb1_rx_wr++;
   \   000016   1F42....     MOV.W   &usb1_rx_wr, R15
   \   00001A   0E4F         MOV.W   R15, R14
   \   00001C   1E53         ADD.W   #0x1, R14
   \   00001E   824E....     MOV.W   R14, &usb1_rx_wr
   \   000022   0B4F         MOV.W   R15, R11
    124                      USB1_Char_Rx_Ring[temp] = recieved;
   \   000024   CB4A....     MOV.B   R10, USB1_Char_Rx_Ring(R11)
    125                      if(receievedFromPC)UCA0TXBUF = USB1_Char_Rx_Ring[temp];
   \   000028   C293....     CMP.B   #0x0, &receievedFromPC
   \   00002C   0524         JEQ     ??eUSCI_A1_ISR_2
   \   00002E   5F4B....     MOV.B   USB1_Char_Rx_Ring(R11), R15
   \   000032   4F4F         MOV.B   R15, R15
   \   000034   824F0E05     MOV.W   R15, &0x50e
    126                      if (usb1_rx_wr >= (sizeof(USB1_Char_Rx_Ring))) {
   \                     ??eUSCI_A1_ISR_2:
   \   000038   B2901000.... CMP.W   #0x10, &usb1_rx_wr
   \   00003E   0228         JNC     ??eUSCI_A1_ISR_3
    127                          usb1_rx_wr = BEGINNING;
   \   000040   8243....     MOV.W   #0x0, &usb1_rx_wr
    128                      }
    129                    //if (!receievedFromPC && recieved=='\n')
    130                      receievedFromPC = ON;
   \                     ??eUSCI_A1_ISR_3:
   \   000044   D243....     MOV.B   #0x1, &receievedFromPC
    131          
    132                      break;
   \   000048   1C3C         JMP     ??eUSCI_A1_ISR_1
    133          
    134                  case 4: // TXIFG
    135                    if(receievedFromPC==OFF) {
   \                     ??eUSCI_A1_ISR_6:
   \   00004A   C293....     CMP.B   #0x0, &receievedFromPC
   \   00004E   0320         JNE     ??eUSCI_A1_ISR_4
    136                      UCA1IE &= ~UCTXIE;
   \   000050   A2C39A05     BIC.W   #0x2, &0x59a
    137                      return;
   \   000054   163C         JMP     ??eUSCI_A1_ISR_1
    138                    }
    139                    UCA1TXBUF = USB1_Char_Tx[tx1_index];
   \                     ??eUSCI_A1_ISR_4:
   \   000056   1F42....     MOV.W   &tx1_index, R15
   \   00005A   5F4F....     MOV.B   USB1_Char_Tx(R15), R15
   \   00005E   4F4F         MOV.B   R15, R15
   \   000060   824F8E05     MOV.W   R15, &0x58e
    140                    USB1_Char_Tx[tx1_index++] = 0;
   \   000064   1F42....     MOV.W   &tx1_index, R15
   \   000068   0E4F         MOV.W   R15, R14
   \   00006A   1E53         ADD.W   #0x1, R14
   \   00006C   824E....     MOV.W   R14, &tx1_index
   \   000070   CF43....     MOV.B   #0x0, USB1_Char_Tx(R15)
    141                    if(USB1_Char_Tx[tx1_index] == 0) {
   \   000074   1F42....     MOV.W   &tx1_index, R15
   \   000078   CF93....     CMP.B   #0x0, USB1_Char_Tx(R15)
   \   00007C   0220         JNE     ??eUSCI_A1_ISR_1
    142                      clearProcessBuff_1();
   \   00007E   ........     CALLA   #clearProcessBuff_1
    143                    }
    144                    break;
    145          
    146                  default:
    147                      break;
    148              }
    149          }
   \                     ??eUSCI_A1_ISR_1:
   \   000082   5A17         POPM.W  #0x6, R15
   \   000084   0013         RETI
   \   000086                REQUIRE _A_UCA1RXBUF_L
   \   000086                REQUIRE _A_UCA0TXBUF_L
   \   000086                REQUIRE _A_UCA1IE_L
   \   000086                REQUIRE _A_UCA1TXBUF_L
   \   000086                REQUIRE _A_UCA1IV_L
    150          

   \                                 In  segment CODE, align 2
    151          void clearProcessBuff(volatile char* pb,volatile unsigned int* pb_index,volatile unsigned int* pb_buffered){
   \                     clearProcessBuff:
   \   000000   0A12         PUSH.W  R10
    152            for(int i = 0;i<LARGE_RING_SIZE;++i)pb[i]=0;
   \   000002   0A43         MOV.W   #0x0, R10
   \                     ??clearProcessBuff_0:
   \   000004   3A901900     CMP.W   #0x19, R10
   \   000008   0634         JGE     ??clearProcessBuff_1
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0F5A         ADD.W   R10, R15
   \   00000E   CF430000     MOV.B   #0x0, 0(R15)
   \   000012   1A53         ADD.W   #0x1, R10
   \   000014   F73F         JMP     ??clearProcessBuff_0
    153            *pb_index=0;
   \                     ??clearProcessBuff_1:
   \   000016   8D430000     MOV.W   #0x0, 0(R13)
    154            *pb_buffered=0;
   \   00001A   8E430000     MOV.W   #0x0, 0(R14)
    155          }
   \   00001E   3A41         POP.W   R10
   \   000020   1001         RETA

   \                                 In  segment CODE, align 2
    156          void clearProcessBuff_0(void){
   \                     clearProcessBuff_0:
    157            clearProcessBuff(USB0_Char_Rx_Process,&pb0_index,&pb0_buffered);
   \   000000   3E40....     MOV.W   #pb0_buffered, R14
   \   000004   3D40....     MOV.W   #pb0_index, R13
   \   000008   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   00000C   ........     CALLA   #clearProcessBuff
    158          }
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
    159          void clearProcessBuff_1(void){
   \                     clearProcessBuff_1:
    160            clearProcessBuff(USB1_Char_Rx_Process,&pb1_index,&pb1_buffered);
   \   000000   3E40....     MOV.W   #pb1_buffered, R14
   \   000004   3D40....     MOV.W   #pb1_index, R13
   \   000008   3C40....     MOV.W   #USB1_Char_Rx_Process, R12
   \   00000C   ........     CALLA   #clearProcessBuff
    161          }
   \   000010   1001         RETA
    162          

   \                                 In  segment CODE, align 2
    163          void out_character(char character) {
   \                     out_character:
   \                     ??out_character_0:
    164              //------------------------------------------------------------------------------
    165              // The while loop will stall as long as the Flag is not set [port is busy]
    166              while (!(UCA0IFG & UCTXIFG)); // USCI_A0 TX buffer ready?
   \   000000   A2B31C05     BIT.W   #0x2, &0x51c
   \   000004   FD2B         JNC     ??out_character_0
    167          
    168              UCA0TXBUF = character;
   \   000006   4C4C         MOV.B   R12, R12
   \   000008   824C0E05     MOV.W   R12, &0x50e
    169              //------------------------------------------------------------------------------
    170          }
   \   00000C   1001         RETA
   \   00000E                REQUIRE _A_UCA0IFG_L
   \   00000E                REQUIRE _A_UCA0TXBUF_L
    171          

   \                                 In  segment CODE, align 2
    172          void USCI_A0_transmit(void){
   \                     USCI_A0_transmit:
    173            tx0_index=0;
   \   000000   8243....     MOV.W   #0x0, &tx0_index
    174            UCA0IE |= UCTXIE;
   \   000004   A2D31A05     BIS.W   #0x2, &0x51a
    175          }
   \   000008   1001         RETA
   \   00000A                REQUIRE _A_UCA0IE_L
    176          

   \                                 In  segment CODE, align 2
    177          void USCI_A1_transmit(void){
   \                     USCI_A1_transmit:
    178            tx1_index=0;
   \   000000   8243....     MOV.W   #0x0, &tx1_index
    179            UCA1IE |= UCTXIE;
   \   000004   A2D39A05     BIS.W   #0x2, &0x59a
    180          }
   \   000008   1001         RETA
   \   00000A                REQUIRE _A_UCA1IE_L
    181          

   \                                 In  segment CODE, align 2
    182          void loadRingtoPB(volatile unsigned int* rx_wr,unsigned int* rx_rd,volatile char* Rx_Process,volatile char* Rx_Ring,volatile unsigned int* pb_index,volatile unsigned int* pb_buffered){
   \                     loadRingtoPB:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   1B411000     MOV.W   0x10(SP), R11
   \   000006   18411200     MOV.W   0x12(SP), R8
    183            if(*rx_wr != *rx_rd){
   \   00000A   AC9D0000     CMP.W   @R13, 0(R12)
   \   00000E   1C24         JEQ     ??loadRingtoPB_0
    184              Rx_Process[pb0_index] = Rx_Ring[*rx_rd];
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   000010   1942....     MOV.W   &pb0_index, R9
   \   000014   064F         MOV.W   R15, R6
   \   000016   265D         ADD.W   @R13, R6
   \   000018   0A4E         MOV.W   R14, R10
   \   00001A   0A59         ADD.W   R9, R10
   \   00001C   EA460000     MOV.B   @R6, 0(R10)
    185              if((*rx_rd)++ >= SMALL_RING_SIZE-1) *rx_rd = BEGINNING;
   \   000020   2A4D         MOV.W   @R13, R10
   \   000022   094A         MOV.W   R10, R9
   \   000024   1953         ADD.W   #0x1, R9
   \   000026   8D490000     MOV.W   R9, 0(R13)
   \   00002A   3A900F00     CMP.W   #0xf, R10
   \   00002E   0228         JNC     ??loadRingtoPB_1
   \   000030   8D430000     MOV.W   #0x0, 0(R13)
    186              if((*pb_index)++ >= LARGE_RING_SIZE-1) *pb_index=BEGINNING;
   \                     ??loadRingtoPB_1:
   \   000034   2A4B         MOV.W   @R11, R10
   \   000036   094A         MOV.W   R10, R9
   \   000038   1953         ADD.W   #0x1, R9
   \   00003A   8B490000     MOV.W   R9, 0(R11)
   \   00003E   3A901800     CMP.W   #0x18, R10
   \   000042   0228         JNC     ??loadRingtoPB_0
   \   000044   8B430000     MOV.W   #0x0, 0(R11)
    187            }
    188            if(*pb_index>=2 && Rx_Process[(*pb_index)-1]=='\n' && Rx_Process[(*pb_index)-2]=='\r') {
   \                     ??loadRingtoPB_0:
   \   000048   AB930000     CMP.W   #0x2, 0(R11)
   \   00004C   1228         JNC     ??loadRingtoPB_2
   \   00004E   2A4B         MOV.W   @R11, R10
   \   000050   094E         MOV.W   R14, R9
   \   000052   095A         ADD.W   R10, R9
   \   000054   F9900A00FFFF CMP.B   #0xa, 0xffff(R9)
   \   00005A   0B20         JNE     ??loadRingtoPB_2
   \   00005C   2A4B         MOV.W   @R11, R10
   \   00005E   094E         MOV.W   R14, R9
   \   000060   095A         ADD.W   R10, R9
   \   000062   F9900D00FEFF CMP.B   #0xd, 0xfffe(R9)
   \   000068   0420         JNE     ??loadRingtoPB_2
    189              *pb_buffered = 1;
   \   00006A   98430000     MOV.W   #0x1, 0(R8)
    190              *pb_index = BEGINNING;
   \   00006E   8B430000     MOV.W   #0x0, 0(R11)
    191            }
    192          }
   \                     ??loadRingtoPB_2:
   \   000072   5617         POPM.W  #0x6, R11
   \   000074   1001         RETA
    193          

   \                                 In  segment CODE, align 2
    194          void loadRingtoPB_0(void){
   \                     loadRingtoPB_0:
    195            loadRingtoPB(&usb0_rx_wr,&usb0_rx_rd,USB0_Char_Rx_Process,USB0_Char_Rx_Ring,&pb0_index,&pb0_buffered);
   \   000000   3012....     PUSH.W  #pb0_buffered
   \   000004   3012....     PUSH.W  #pb0_index
   \   000008   3F40....     MOV.W   #USB0_Char_Rx_Ring, R15
   \   00000C   3E40....     MOV.W   #USB0_Char_Rx_Process, R14
   \   000010   3D40....     MOV.W   #usb0_rx_rd, R13
   \   000014   3C40....     MOV.W   #usb0_rx_wr, R12
   \   000018   ........     CALLA   #loadRingtoPB
    196          }
   \   00001C   A1000400     ADDA    #0x4, SP
   \   000020   1001         RETA

   \                                 In  segment CODE, align 2
    197          void loadRingtoPB_1(void){
   \                     loadRingtoPB_1:
    198            loadRingtoPB(&usb1_rx_wr,&usb1_rx_rd,USB1_Char_Rx_Process,USB1_Char_Rx_Ring,&pb1_index,&pb1_buffered);
   \   000000   3012....     PUSH.W  #pb1_buffered
   \   000004   3012....     PUSH.W  #pb1_index
   \   000008   3F40....     MOV.W   #USB1_Char_Rx_Ring, R15
   \   00000C   3E40....     MOV.W   #USB1_Char_Rx_Process, R14
   \   000010   3D40....     MOV.W   #usb1_rx_rd, R13
   \   000014   3C40....     MOV.W   #usb1_rx_wr, R12
   \   000018   ........     CALLA   #loadRingtoPB
    199          }
   \   00001C   A1000400     ADDA    #0x4, SP
   \   000020   1001         RETA
    200          

   \                                 In  segment CODE, align 2
    201          void copyPBtoTx_0(void){
   \                     copyPBtoTx_0:
    202            if(!pb0_buffered)return;
   \   000000   8293....     CMP.W   #0x0, &pb0_buffered
   \   000004   0B24         JEQ     ??copyPBtoTx_0_2
    203            for(int i = 0;i<sizeof(USB0_Char_Rx_Process);++i) USB0_Char_Tx[i] = USB0_Char_Rx_Process[i];
   \   000006   0F43         MOV.W   #0x0, R15
   \                     ??copyPBtoTx_0_0:
   \   000008   3F901900     CMP.W   #0x19, R15
   \   00000C   052C         JC      ??copyPBtoTx_0_3
   \   00000E   DF4F........ MOV.B   USB0_Char_Rx_Process(R15), USB0_Char_Tx(R15)
   \   000014   1F53         ADD.W   #0x1, R15
   \   000016   F83F         JMP     ??copyPBtoTx_0_0
    204            //strcpy(display_line[3],(char*)USB0_Char_Tx);
    205            //for(int i = 0;i<10;++i)
    206            //  if(display_line[3][i] == '\r' || display_line[3][i]=='\n') display_line[3][i]=0;
    207            clearProcessBuff_0();
   \                     ??copyPBtoTx_0_3:
   \   000018   ........     CALLA   #clearProcessBuff_0
    208          }
   \                     ??copyPBtoTx_0_2:
   \   00001C   1001         RETA
    209          
    210          

   \                                 In  segment CODE, align 2
    211          void SerialProcess(void){
   \                     SerialProcess:
    212            loadRingtoPB_0();
   \   000000   ........     CALLA   #loadRingtoPB_0
    213            loadRingtoPB_1();
   \   000004   ........     CALLA   #loadRingtoPB_1
    214            // copyPBtoTx_0();
    215            /*if(pb0_buffered){
    216              if(USB0_Char_Rx_Process[0]=='^'){
    217                if(USB0_Char_Rx_Process[1]=='F') SET_UCA0_115200;
    218                if(USB0_Char_Rx_Process[1]=='S') SET_UCA0_9600;
    219              }
    220              
    221              clearProcessBuff_0();
    222            }*/
    223            if(pb1_buffered) clearProcessBuff_1();
   \   000008   8293....     CMP.W   #0x0, &pb1_buffered
   \   00000C   0224         JEQ     ??SerialProcess_0
   \   00000E   ........     CALLA   #clearProcessBuff_1
    224            
    225          }
   \                     ??SerialProcess_0:
   \   000012   1001         RETA

   \                                 In  segment INTVEC, offset 0x40, root
   \                     `??eUSCI_A1_ISR::??INTVEC 64`:
   \   000040   ....         DC16    eUSCI_A1_ISR

   \                                 In  segment INTVEC, offset 0x42, root
   \                     `??eUSCI_A0_ISR::??INTVEC 66`:
   \   000042   ....         DC16    eUSCI_A0_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Init_Serial_UCA
      4   SerialProcess
        4   -> clearProcessBuff_1
        4   -> loadRingtoPB_0
        4   -> loadRingtoPB_1
      4   USCI_A0_transmit
      4   USCI_A1_transmit
      6   clearProcessBuff
      4   clearProcessBuff_0
        4   -> clearProcessBuff
      4   clearProcessBuff_1
        4   -> clearProcessBuff
      4   copyPBtoTx_0
        4   -> clearProcessBuff_0
     10   eUSCI_A0_ISR
     16   eUSCI_A1_ISR
       16   -> clearProcessBuff_1
     16   loadRingtoPB
      8   loadRingtoPB_0
        8   -> loadRingtoPB
      8   loadRingtoPB_1
        8   -> loadRingtoPB
      4   out_character


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     122  Init_Serial_UCA
      20  SerialProcess
      25  USB0_Char_Rx_Process
      16  USB0_Char_Rx_Ring
      25  USB0_Char_Tx
      25  USB1_Char_Rx_Process
      16  USB1_Char_Rx_Ring
      25  USB1_Char_Tx
      10  USCI_A0_transmit
      10  USCI_A1_transmit
       2  _A_UCA0BRW_L
       2  _A_UCA0CTLW0_L
       2  _A_UCA0IE_L
       2  _A_UCA0IFG_L
       2  _A_UCA0IV_L
       2  _A_UCA0MCTLW_L
       2  _A_UCA0RXBUF_L
       2  _A_UCA0TXBUF_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1IE_L
       2  _A_UCA1IV_L
       2  _A_UCA1MCTLW_L
       2  _A_UCA1RXBUF_L
       2  _A_UCA1TXBUF_L
      34  clearProcessBuff
      18  clearProcessBuff_0
      18  clearProcessBuff_1
      30  copyPBtoTx_0
     126  eUSCI_A0_ISR
       2  eUSCI_A0_ISR::??INTVEC 66
     134  eUSCI_A1_ISR
       2  eUSCI_A1_ISR::??INTVEC 64
     118  loadRingtoPB
      34  loadRingtoPB_0
      34  loadRingtoPB_1
      14  out_character
       2  pb0_buffered
       2  pb0_index
       2  pb1_buffered
       2  pb1_index
       1  receievedFromPC
       2  serialState
       2  tx0_index
       2  tx1_index
       2  usb0_rx_rd
       2  usb0_rx_wr
       2  usb1_rx_rd
       2  usb1_rx_wr

 
 462 bytes in segment CODE
  30 bytes in segment DATA16_AN
 155 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 260 bytes in segment ISR_CODE
 
 722 bytes of CODE  memory
   0 bytes of CONST memory (+  4 bytes shared)
 155 bytes of DATA  memory (+ 30 bytes shared)

Errors: none
Warnings: 3
