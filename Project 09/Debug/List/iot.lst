###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          10/Apr/2022  15:25:31
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 09\iot.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWB178.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 09\iot.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 09\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 09\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 09\Debug\List\iot.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 09\Debug\Obj\iot.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 09\iot.c
      1          #include "iot.h"
      2          #include <string.h>

   \                                 In  segment CODE, align 2
   \   __intrinsic __nounwind __cc_version2 char *strchr(char const *, int)
   \                     strchr:
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   0D4B         MOV.W   R11, R13
   \   000008   0C4A         MOV.W   R10, R12
   \   00000A   ........     CALLA   #__iar_Strchr
   \   00000E   1A17         POPM.W  #0x2, R11
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
   \   __intrinsic __nounwind __cc_version2 char *strstr(char const *, char const *)
   \                     strstr:
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   0D4B         MOV.W   R11, R13
   \   000008   0C4A         MOV.W   R10, R12
   \   00000A   ........     CALLA   #__iar_Strstr
   \   00000E   1A17         POPM.W  #0x2, R11
   \   000010   1001         RETA
      3          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2
      4          #include <string.h>
      5          #include "adc.h"
      6          #include "serial.h"
      7          #include "ports.h"
      8          #include "sm.h"
      9          #include <stdlib.h>
     10          

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     11          char iot_setup_state = BOOT_UP;
   \                     iot_setup_state:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for iot_setup_state>`
     12          extern volatile char USB0_Char_Tx[];
     13          extern unsigned volatile int pb0_buffered;
     14          extern volatile char USB0_Char_Rx_Process[];
     15          extern volatile char receievedFromPC;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          char SSID[SSID_LEN + 1];
   \                     SSID:
   \   000000                DS8 11

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          char IP[IP_LEN + 1];
   \                     IP:
   \   000000                DS8 14
     18          extern volatile unsigned char display_changed;
     19          extern char display_line[4][11];

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          char dotFound;
   \                     dotFound:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          int midIndex;
   \                     midIndex:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          char midFound;
   \                     midFound:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          command CommandBuffer[COMMAND_BUFFER_LEN];
   \                     CommandBuffer:
   \   000000                DS8 20

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          char cb_index;
   \                     cb_index:
   \   000000                DS8 1
     25          
     26          extern volatile unsigned int cycle_count;
     27          extern volatile unsigned int stopwatch_milliseconds;
     28          extern volatile unsigned int stopwatch_seconds;
     29          
     30          extern volatile char state;
     31          extern volatile int stateCounter;
     32          extern volatile char nextState;
     33          
     34          extern int polarityRight, polarityLeft;
     35          extern unsigned int driveTime;
     36          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     37          command emptyCommand = {0, 0};
   \                     emptyCommand:
   \   000000                DS8 4
     38          
     39          

   \                                 In  segment CODE, align 2
     40          int Init_IOT(void) {
   \                     Init_IOT:
   \   000000   0A12         PUSH.W  R10
     41              //if(!receievedFromPC) return;
     42          
     43              switch(iot_setup_state) {
   \   000002   5E42....     MOV.B   &iot_setup_state, R14
   \   000006   7E804200     SUB.B   #0x42, R14
   \   00000A   1524         JEQ     ??Init_IOT_17
   \   00000C   7E800700     SUB.B   #0x7, R14
   \   000010   9124         JEQ     ??Init_IOT_18
   \   000012   6E82         SUB.B   #0x4, R14
   \   000014   2124         JEQ     ??Init_IOT_19
   \   000016   5E83         SUB.B   #0x1, R14
   \   000018   4F24         JEQ     ??Init_IOT_20
   \   00001A   7E800500     SUB.B   #0x5, R14
   \   00001E   3424         JEQ     ??Init_IOT_21
   \   000020   7E801600     SUB.B   #0x16, R14
   \   000024   9324         JEQ     ??Init_IOT_22
   \   000026   6E82         SUB.B   #0x4, R14
   \   000028   2324         JEQ     ??Init_IOT_23
   \   00002A   5E83         SUB.B   #0x1, R14
   \   00002C   5124         JEQ     ??Init_IOT_24
   \   00002E   7E800500     SUB.B   #0x5, R14
   \   000032   3624         JEQ     ??Init_IOT_25
   \   000034   E23C         JMP     ??Init_IOT_12
     44                  case BOOT_UP:
     45                      if(pb0_buffered) {
   \                     ??Init_IOT_17:
   \   000036   8293....     CMP.W   #0x0, &pb0_buffered
   \   00003A   E124         JEQ     ??Init_IOT_3
     46                          if(strcmp((char*)USB0_Char_Rx_Process, BOOT_RESPONSE) == 0) {
   \   00003C   3D40....     MOV.W   #`?<Constant "WIFI GOT IP\\r\\n">`, R13
   \   000040   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   000044   ........     CALLA   #strcmp
   \   000048   0C93         CMP.W   #0x0, R12
   \   00004A   0320         JNE     ??Init_IOT_26
     47                              iot_setup_state = CIPMUX_Tx;
   \   00004C   F2404D00.... MOV.B   #0x4d, &iot_setup_state
     48                          }
     49          
     50                          clearProcessBuff_0();
   \                     ??Init_IOT_26:
   \   000052   ........     CALLA   #clearProcessBuff_0
     51                      }
     52          
     53                      break;
   \   000056   D33C         JMP     ??Init_IOT_3
     54          
     55                  case CIPMUX_Tx:
     56                      strcpy((char*)USB0_Char_Tx, ALLOW_MULTIPLE_CONNECTIONS);
   \                     ??Init_IOT_19:
   \   000058   3D40....     MOV.W   #`?<Constant "AT+CIPMUX=1\\r\\n">`, R13
   \   00005C   3C40....     MOV.W   #USB0_Char_Tx, R12
   \   000060   ........     CALLA   #strcpy
     57                      USCI_A0_transmit();
   \   000064   ........     CALLA   #USCI_A0_transmit
     58                      iot_setup_state = CIPMUX_Rx;
   \   000068   F2406D00.... MOV.B   #0x6d, &iot_setup_state
     59                      break;
   \   00006E   C73C         JMP     ??Init_IOT_3
     60          
     61                  case CIPMUX_Rx:
     62                      if(UCA0IE & UCTXIE) break; // wait for the Tx to completely transmit
   \                     ??Init_IOT_23:
   \   000070   A2B31A05     BIT.W   #0x2, &0x51a
   \   000074   C42C         JC      ??Init_IOT_3
     63          
     64                      if(pb0_buffered) { // wait for pb to finish buffering
   \   000076   8293....     CMP.W   #0x0, &pb0_buffered
   \   00007A   C124         JEQ     ??Init_IOT_3
     65                          iot_setup_state = CIPSERVER_Tx;
   \   00007C   F2405300.... MOV.B   #0x53, &iot_setup_state
     66                          clearProcessBuff_0();
   \   000082   ........     CALLA   #clearProcessBuff_0
     67                      }
     68          
     69                      break;
   \   000086   BB3C         JMP     ??Init_IOT_3
     70          
     71                  case CIPSERVER_Tx:
     72                      strcpy((char*)USB0_Char_Tx, START_SERVER);
   \                     ??Init_IOT_21:
   \   000088   3D40....     MOV.W   #`?<Constant "AT+CIPSERVER=1,4764\\r\\n">`, R13
   \   00008C   3C40....     MOV.W   #USB0_Char_Tx, R12
   \   000090   ........     CALLA   #strcpy
     73                      USCI_A0_transmit();
   \   000094   ........     CALLA   #USCI_A0_transmit
     74                      iot_setup_state = CIPSERVER_Rx;
   \   000098   F2407300.... MOV.B   #0x73, &iot_setup_state
     75                      break;
   \   00009E   AF3C         JMP     ??Init_IOT_3
     76          
     77                  case CIPSERVER_Rx:
     78                      if(UCA0IE & UCTXIE) break;
   \                     ??Init_IOT_25:
   \   0000A0   A2B31A05     BIT.W   #0x2, &0x51a
   \   0000A4   AC2C         JC      ??Init_IOT_3
     79          
     80                      if(pb0_buffered) {
   \   0000A6   8293....     CMP.W   #0x0, &pb0_buffered
   \   0000AA   A924         JEQ     ??Init_IOT_3
     81                          iot_setup_state = GET_SSID_Tx;
   \   0000AC   F2404E00.... MOV.B   #0x4e, &iot_setup_state
     82                          clearProcessBuff_0();
   \   0000B2   ........     CALLA   #clearProcessBuff_0
     83                      }
     84          
     85                      break;
   \   0000B6   A33C         JMP     ??Init_IOT_3
     86          
     87                  case GET_SSID_Tx:
     88                      strcpy((char*)USB0_Char_Tx, SSID_COMMAND);
   \                     ??Init_IOT_20:
   \   0000B8   3D40....     MOV.W   #`?<Constant "AT+CWJAP?\\r\\n">`, R13
   \   0000BC   3C40....     MOV.W   #USB0_Char_Tx, R12
   \   0000C0   ........     CALLA   #strcpy
     89                      USCI_A0_transmit();
   \   0000C4   ........     CALLA   #USCI_A0_transmit
     90                      iot_setup_state = GET_SSID_Rx;
   \   0000C8   F2406E00.... MOV.B   #0x6e, &iot_setup_state
     91                      break;
   \   0000CE   973C         JMP     ??Init_IOT_3
     92          
     93                  case GET_SSID_Rx:
     94                      if(UCA0IE & UCTXIE) break;
   \                     ??Init_IOT_24:
   \   0000D0   A2B31A05     BIT.W   #0x2, &0x51a
   \   0000D4   942C         JC      ??Init_IOT_3
     95          
     96                      if(pb0_buffered) {
   \   0000D6   8293....     CMP.W   #0x0, &pb0_buffered
   \   0000DA   9124         JEQ     ??Init_IOT_3
     97                          if(strncmp(SSID_RESPONSE, (char*)USB0_Char_Rx_Process, SSID_RESPONSE_LEN) == 0) {
   \   0000DC   3E400700     MOV.W   #0x7, R14
   \   0000E0   3D40....     MOV.W   #USB0_Char_Rx_Process, R13
   \   0000E4   3C40....     MOV.W   #`?<Constant "+CWJAP:">`, R12
   \   0000E8   ........     CALLA   #strncmp
   \   0000EC   0C93         CMP.W   #0x0, R12
   \   0000EE   1C20         JNE     ??Init_IOT_27
     98                              int i;
     99          
    100                              for(i = 0; i <= SSID_LEN && USB0_Char_Rx_Process[i + SSID_RESPONSE_LEN + 1] != '\"'; ++i) SSID[i] = USB0_Char_Rx_Process[i + SSID_RESPONSE_LEN + 1];
   \   0000F0   0A43         MOV.W   #0x0, R10
   \                     ??Init_IOT_0:
   \   0000F2   3A900B00     CMP.W   #0xb, R10
   \   0000F6   0934         JGE     ??Init_IOT_28
   \   0000F8   FA902200.... CMP.B   #0x22, LWRD(USB0_Char_Rx_Process + 8)(R10)
   \   0000FE   0524         JEQ     ??Init_IOT_28
   \   000100   DA4A........ MOV.B   LWRD(USB0_Char_Rx_Process + 8)(R10), SSID(R10)
   \   000106   1A53         ADD.W   #0x1, R10
   \   000108   F43F         JMP     ??Init_IOT_0
    101          
    102                              SSID[i + SSID_RESPONSE_LEN + 2] = 0;
   \                     ??Init_IOT_28:
   \   00010A   CA43....     MOV.B   #0x0, SSID + 9(R10)
    103                              SSID[SSID_LEN] = 0;
   \   00010E   C243....     MOV.B   #0x0, &SSID + 10
    104                              centerStringToDisplay(0, SSID);
   \   000112   3D40....     MOV.W   #SSID, R13
   \   000116   0C43         MOV.W   #0x0, R12
   \   000118   ........     CALLA   #centerStringToDisplay
    105                              display_changed = 1;
   \   00011C   D243....     MOV.B   #0x1, &display_changed
    106                              iot_setup_state = GET_IP_Tx;
   \   000120   F2404900.... MOV.B   #0x49, &iot_setup_state
   \   000126   033C         JMP     ??Init_IOT_13
    107                          } else iot_setup_state = GET_SSID_Tx;
   \                     ??Init_IOT_27:
   \   000128   F2404E00.... MOV.B   #0x4e, &iot_setup_state
    108          
    109                          clearProcessBuff_0();
   \                     ??Init_IOT_13:
   \   00012E   ........     CALLA   #clearProcessBuff_0
    110                      }
    111          
    112                      break;
   \   000132   653C         JMP     ??Init_IOT_3
    113          
    114                  case GET_IP_Tx:
    115                      strcpy((char*)USB0_Char_Tx, IP_COMMAND);
   \                     ??Init_IOT_18:
   \   000134   3D40....     MOV.W   #`?<Constant "AT+CIFSR\\r\\n">`, R13
   \   000138   3C40....     MOV.W   #USB0_Char_Tx, R12
   \   00013C   ........     CALLA   #strcpy
    116                      USCI_A0_transmit();
   \   000140   ........     CALLA   #USCI_A0_transmit
    117                      iot_setup_state = GET_IP_Rx;
   \   000144   F2406900.... MOV.B   #0x69, &iot_setup_state
    118                      break;
   \   00014A   593C         JMP     ??Init_IOT_3
    119          
    120                  case GET_IP_Rx:
    121                      if(UCA0IE & UCTXIE) break;
   \                     ??Init_IOT_22:
   \   00014C   A2B31A05     BIT.W   #0x2, &0x51a
   \   000150   562C         JC      ??Init_IOT_3
    122          
    123                      if(pb0_buffered) {
   \   000152   8293....     CMP.W   #0x0, &pb0_buffered
   \   000156   5324         JEQ     ??Init_IOT_3
    124                          if(strncmp(IP_RESPONSE, (char*)USB0_Char_Rx_Process, IP_RESPONSE_LEN) == 0) {
   \   000158   3E400D00     MOV.W   #0xd, R14
   \   00015C   3D40....     MOV.W   #USB0_Char_Rx_Process, R13
   \   000160   3C40....     MOV.W   #`?<Constant "+CIFSR:STAIP,">`, R12
   \   000164   ........     CALLA   #strncmp
   \   000168   0C93         CMP.W   #0x0, R12
   \   00016A   4120         JNE     ??Init_IOT_29
    125                              int i;
    126          
    127                              for(i = 0; i <= IP_LEN && USB0_Char_Rx_Process[i + IP_RESPONSE_LEN + 1] != '"'; ++i) {
   \   00016C   0A43         MOV.W   #0x0, R10
   \                     ??Init_IOT_1:
   \   00016E   3A900E00     CMP.W   #0xe, R10
   \   000172   1C34         JGE     ??Init_IOT_30
   \   000174   FA902200.... CMP.B   #0x22, LWRD(USB0_Char_Rx_Process + 14)(R10)
   \   00017A   1824         JEQ     ??Init_IOT_30
    128                                  IP[i] = USB0_Char_Rx_Process[i + IP_RESPONSE_LEN + 1];
   \   00017C   DA4A........ MOV.B   LWRD(USB0_Char_Rx_Process + 14)(R10), IP(R10)
    129          
    130                                  if(USB0_Char_Rx_Process[i + IP_RESPONSE_LEN + 1] == '.') {
   \   000182   FA902E00.... CMP.B   #0x2e, LWRD(USB0_Char_Rx_Process + 14)(R10)
   \   000188   0F20         JNE     ??Init_IOT_14
    131                                      if(!dotFound)dotFound = 1;
   \   00018A   C293....     CMP.B   #0x0, &dotFound
   \   00018E   0320         JNE     ??Init_IOT_31
   \   000190   D243....     MOV.B   #0x1, &dotFound
   \   000194   093C         JMP     ??Init_IOT_14
    132                                      else {
    133                                          dotFound = 0;
   \                     ??Init_IOT_31:
   \   000196   C243....     MOV.B   #0x0, &dotFound
    134          
    135                                          if(!midFound) {
   \   00019A   C293....     CMP.B   #0x0, &midFound
   \   00019E   0420         JNE     ??Init_IOT_14
    136                                              midIndex = i;
   \   0001A0   824A....     MOV.W   R10, &midIndex
    137                                              midFound = 1;
   \   0001A4   D243....     MOV.B   #0x1, &midFound
    138                                          }
    139                                      }
    140                                  }
    141                              }
   \                     ??Init_IOT_14:
   \   0001A8   1A53         ADD.W   #0x1, R10
   \   0001AA   E13F         JMP     ??Init_IOT_1
    142          
    143                              IP[i + IP_RESPONSE_LEN + 2] = 0;
   \                     ??Init_IOT_30:
   \   0001AC   CA43....     MOV.B   #0x0, LWRD(IP + 15)(R10)
    144                              IP[IP_LEN] = 0;
   \   0001B0   C243....     MOV.B   #0x0, &IP + 13
    145                              IP[midIndex] = 0;
   \   0001B4   1F42....     MOV.W   &midIndex, R15
   \   0001B8   CF43....     MOV.B   #0x0, IP(R15)
    146                              strcpy(display_line[1], "IP ADDRESS");
   \   0001BC   3D40....     MOV.W   #`?<Constant "IP ADDRESS">`, R13
   \   0001C0   3C40....     MOV.W   #display_line + 11, R12
   \   0001C4   ........     CALLA   #strcpy
    147                              centerStringToDisplay(2, IP);
   \   0001C8   3D40....     MOV.W   #IP, R13
   \   0001CC   2C43         MOV.W   #0x2, R12
   \   0001CE   ........     CALLA   #centerStringToDisplay
    148                              centerStringToDisplay(3, IP + midIndex + 1);
   \   0001D2   3D40....     MOV.W   #IP + 1, R13
   \   0001D6   1D52....     ADD.W   &midIndex, R13
   \   0001DA   3C400300     MOV.W   #0x3, R12
   \   0001DE   ........     CALLA   #centerStringToDisplay
    149                              display_changed = 1;
   \   0001E2   D243....     MOV.B   #0x1, &display_changed
    150                              iot_setup_state = IOT_SETUP_FINISHED;
   \   0001E6   F2404600.... MOV.B   #0x46, &iot_setup_state
   \   0001EC   033C         JMP     ??Init_IOT_15
    151                          } else iot_setup_state = GET_IP_Tx;
   \                     ??Init_IOT_29:
   \   0001EE   F2404900.... MOV.B   #0x49, &iot_setup_state
    152          
    153                          clearProcessBuff_0();
   \                     ??Init_IOT_15:
   \   0001F4   ........     CALLA   #clearProcessBuff_0
    154                      }
    155          
    156                      break;
   \   0001F8   023C         JMP     ??Init_IOT_3
    157          
    158                  default:
    159                      return 1;
   \                     ??Init_IOT_12:
   \   0001FA   1C43         MOV.W   #0x1, R12
   \   0001FC   013C         JMP     ??Init_IOT_16
    160                      break;
    161              }
    162          
    163              return 0;
   \                     ??Init_IOT_3:
   \   0001FE   0C43         MOV.W   #0x0, R12
   \                     ??Init_IOT_16:
   \   000200   3A41         POP.W   R10
   \   000202   1001         RETA
   \   000204                REQUIRE _A_UCA0IE_L
    164          }
    165          

   \                                 In  segment CODE, align 2
    166          void centerStringToDisplay(unsigned int line, char * s) {
   \                     centerStringToDisplay:
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
    167              strcpy(display_line[line] + ((10 - strlen(s)) >> 1), s);
   \   000006   0C4B         MOV.W   R11, R12
   \   000008   ........     CALLA   #strlen
   \   00000C   0D4B         MOV.W   R11, R13
   \   00000E   0F4A         MOV.W   R10, R15
   \   000010                RPT     #0xa
   \   000010   49180F5A     ADDX.W  R10, R15
   \   000014   3E400A00     MOV.W   #0xa, R14
   \   000018   0E8C         SUB.W   R12, R14
   \   00001A   5E03         RRUM.W  #0x1, R14
   \   00001C   0F5E         ADD.W   R14, R15
   \   00001E   3F50....     ADD.W   #display_line, R15
   \   000022   0C4F         MOV.W   R15, R12
   \   000024   ........     CALLA   #strcpy
    168          }
   \   000028   1A17         POPM.W  #0x2, R11
   \   00002A   1001         RETA
    169          

   \                                 In  segment CODE, align 2
    170          void IOTBufferCommands(void) {
   \                     IOTBufferCommands:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   B1000400     SUBA    #0x4, SP
    171              if(pb0_buffered) {
   \   000006   8293....     CMP.W   #0x0, &pb0_buffered
   \   00000A   3624         JEQ     ??IOTBufferCommands_2
    172                  char * pos = strstr((char*)USB0_Char_Rx_Process, CARET_SECURITY_CODE);
   \   00000C   3D40....     MOV.W   #`?<Constant "^9A73">`, R13
   \   000010   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   000014   ........     CALLA   #strstr
   \   000018   0A4C         MOV.W   R12, R10
    173          
    174                  while(pos) {
   \                     ??IOTBufferCommands_0:
   \   00001A   0A93         CMP.W   #0x0, R10
   \   00001C   2B24         JEQ     ??IOTBufferCommands_3
    175                      pos += CARET_SECURITY_CODE_LEN; // now should be on where the command actually is
   \   00001E   3A500500     ADD.W   #0x5, R10
    176                      char comm = *pos;
   \   000022   6B4A         MOV.B   @R10, R11
    177                      pos++;
   \   000024   1A53         ADD.W   #0x1, R10
    178                      char * end_caret = strchr(pos, '^');
   \   000026   3D405E00     MOV.W   #0x5e, R13
   \   00002A   0C4A         MOV.W   R10, R12
   \   00002C   ........     CALLA   #strchr
   \   000030   084C         MOV.W   R12, R8
    179                      char * end_null = strchr(pos, 0);
   \   000032   0D43         MOV.W   #0x0, R13
   \   000034   0C4A         MOV.W   R10, R12
   \   000036   ........     CALLA   #strchr
   \   00003A   094C         MOV.W   R12, R9
    180                      char * end = end_caret ? end_caret : end_null;
                                    ^
Warning[Pe177]: variable "end" was declared but never referenced
   \   00003C   0893         CMP.W   #0x0, R8
   \   00003E   0224         JEQ     ??IOTBufferCommands_4
   \   000040   0648         MOV.W   R8, R6
   \   000042   013C         JMP     ??IOTBufferCommands_1
   \                     ??IOTBufferCommands_4:
   \   000044   0649         MOV.W   R9, R6
    181                      int time = stoi(pos);//strtol(pos,&end,10);
   \                     ??IOTBufferCommands_1:
   \   000046   0C4A         MOV.W   R10, R12
   \   000048   ........     CALLA   #stoi
   \   00004C   074C         MOV.W   R12, R7
    182                      command c = {
    183                          .comm = comm,
    184                          .duration = time
    185                      };
   \   00004E   C14B0000     MOV.B   R11, 0(SP)
   \   000052   81470200     MOV.W   R7, 0x2(SP)
    186                      pushCB(c);
   \   000056   11120400     PUSH.W  0x4(SP)
   \   00005A   11120400     PUSH.W  0x4(SP)
   \   00005E   ........     CALLA   #pushCB
    187                      pos = strstr(pos, CARET_SECURITY_CODE);
   \   000062   3D40....     MOV.W   #`?<Constant "^9A73">`, R13
   \   000066   0C4A         MOV.W   R10, R12
   \   000068   ........     CALLA   #strstr
   \   00006C   0A4C         MOV.W   R12, R10
   \   00006E   A1000400     ADDA    #0x4, SP
   \   000072   D33F         JMP     ??IOTBufferCommands_0
    188                  }
    189          
    190                  clearProcessBuff_0();
   \                     ??IOTBufferCommands_3:
   \   000074   ........     CALLA   #clearProcessBuff_0
    191              }
    192          
    193          }
   \                     ??IOTBufferCommands_2:
   \   000078   A1000400     ADDA    #0x4, SP
   \   00007C   5617         POPM.W  #0x6, R11
   \   00007E   1001         RETA
    194          

   \                                 In  segment CODE, align 2
    195          int stoi(char* str) {
   \                     stoi:
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4C         MOV.W   R12, R11
    196          
    197              int num = 0;
   \   000004   0A43         MOV.W   #0x0, R10
    198              int n = strlen(str);
   \   000006   0C4B         MOV.W   R11, R12
   \   000008   ........     CALLA   #strlen
   \   00000C   0E4C         MOV.W   R12, R14
    199          
    200              for(int i = 0; i < n && str[i] >= 48 && str[i] <= 57; ++i)
   \   00000E   0D43         MOV.W   #0x0, R13
   \                     ??stoi_0:
   \   000010   0D9E         CMP.W   R14, R13
   \   000012   1734         JGE     ??stoi_1
   \   000014   0F4B         MOV.W   R11, R15
   \   000016   0F5D         ADD.W   R13, R15
   \   000018   FF9030000000 CMP.B   #0x30, 0(R15)
   \   00001E   1128         JNC     ??stoi_1
   \   000020   0F4B         MOV.W   R11, R15
   \   000022   0F5D         ADD.W   R13, R15
   \   000024   FF903A000000 CMP.B   #0x3a, 0(R15)
   \   00002A   0B2C         JC      ??stoi_1
    201                  num = num * 10 + (int)(str[i] - 48);
   \   00002C   0F4B         MOV.W   R11, R15
   \   00002E   0F5D         ADD.W   R13, R15
   \   000030   6F4F         MOV.B   @R15, R15
   \   000032   4F4F         MOV.B   R15, R15
   \   000034                RPT     #0xa
   \   000034   49180F5A     ADDX.W  R10, R15
   \   000038   0A4F         MOV.W   R15, R10
   \   00003A   3A50D0FF     ADD.W   #0xffd0, R10
   \   00003E   1D53         ADD.W   #0x1, R13
   \   000040   E73F         JMP     ??stoi_0
    202          
    203              return num;
   \                     ??stoi_1:
   \   000042   0C4A         MOV.W   R10, R12
   \   000044   1A17         POPM.W  #0x2, R11
   \   000046   1001         RETA
    204          }
    205          

   \                                 In  segment CODE, align 2
    206          command popCB(void) {
   \                     popCB:
   \   000000   0A12         PUSH.W  R10
   \   000002   B1000400     SUBA    #0x4, SP
    207              command ret = CommandBuffer[0];
   \   000006   9142....0000 MOV.W   &CommandBuffer, 0(SP)
   \   00000C   9142....0200 MOV.W   &CommandBuffer + 2, 0x2(SP)
    208          
    209              for(int i = 0; i < COMMAND_BUFFER_LEN - 1; ++i) CommandBuffer[i] = CommandBuffer[i + 1];
   \   000012   0E43         MOV.W   #0x0, R14
   \                     ??popCB_0:
   \   000014   2E92         CMP.W   #0x4, R14
   \   000016   0C34         JGE     ??popCB_1
   \   000018   0D4E         MOV.W   R14, R13
   \   00001A   5D06         RLAM.W  #0x2, R13
   \   00001C   0F4E         MOV.W   R14, R15
   \   00001E   5F06         RLAM.W  #0x2, R15
   \   000020   9D4F........ MOV.W   CommandBuffer + 4(R15), CommandBuffer(R13)
   \   000026   9D4F........ MOV.W   CommandBuffer + 6(R15), CommandBuffer + 2(R13)
   \   00002C   1E53         ADD.W   #0x1, R14
   \   00002E   F23F         JMP     ??popCB_0
    210          
    211              CommandBuffer[COMMAND_BUFFER_LEN - 1] = emptyCommand;
   \                     ??popCB_1:
   \   000030   9242........ MOV.W   &emptyCommand, &CommandBuffer + 16
   \   000036   9242........ MOV.W   &emptyCommand + 2, &CommandBuffer + 18
   \   00003C   AC410000     MOV.W   @SP, 0(R12)
   \   000040   9C4102000200 MOV.W   0x2(SP), 0x2(R12)
   \   000046   A1000400     ADDA    #0x4, SP
   \   00004A   3A41         POP.W   R10
   \   00004C   1001         RETA
    212              return ret;
    213          }

   \                                 In  segment CODE, align 2
    214          void pushCB(command c) {
   \                     pushCB:
    215              int i;
    216          
    217              for(i = 0; i < COMMAND_BUFFER_LEN; ++i)
   \   000000   0F43         MOV.W   #0x0, R15
   \                     ??pushCB_0:
   \   000002   3F900500     CMP.W   #0x5, R15
   \   000006   0C34         JGE     ??pushCB_2
    218                  if(CommandBuffer[i].comm == 0 && CommandBuffer[i].duration == 0) break;
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   5E06         RLAM.W  #0x2, R14
   \   00000C   CE93....     CMP.B   #0x0, CommandBuffer(R14)
   \   000010   0520         JNE     ??pushCB_1
   \   000012   0E4F         MOV.W   R15, R14
   \   000014   5E06         RLAM.W  #0x2, R14
   \   000016   8E93....     CMP.W   #0x0, CommandBuffer + 2(R14)
   \   00001A   0224         JEQ     ??pushCB_2
   \                     ??pushCB_1:
   \   00001C   1F53         ADD.W   #0x1, R15
   \   00001E   F13F         JMP     ??pushCB_0
    219          
    220              if(i == COMMAND_BUFFER_LEN) {
   \                     ??pushCB_2:
   \   000020   3F900500     CMP.W   #0x5, R15
   \   000024   0824         JEQ     ??pushCB_4
    221                  return;
    222              }
    223          
    224              CommandBuffer[i] = c;
   \   000026   0E4F         MOV.W   R15, R14
   \   000028   5E06         RLAM.W  #0x2, R14
   \   00002A   9E410400.... MOV.W   0x4(SP), CommandBuffer(R14)
   \   000030   9E410600.... MOV.W   0x6(SP), CommandBuffer + 2(R14)
    225          }
   \                     ??pushCB_4:
   \   000036   1001         RETA
    226          

   \                                 In  segment CODE, align 2
    227          void ProcessCommands(void) {
   \                     ProcessCommands:
   \   000000   B1000400     SUBA    #0x4, SP
    228              if(state == START && (CommandBuffer[0].comm != 0 && CommandBuffer[0].duration != 0)) {
   \   000004   F2905300.... CMP.B   #0x53, &state
   \   00000A   5C20         JNE     ??ProcessCommands_2
   \   00000C   C293....     CMP.B   #0x0, &CommandBuffer
   \   000010   5924         JEQ     ??ProcessCommands_2
   \   000012   8293....     CMP.W   #0x0, &CommandBuffer + 2
   \   000016   5624         JEQ     ??ProcessCommands_2
    229                  command c = popCB();
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   ........     CALLA   #popCB
    230                  stopwatch_seconds = 0;
   \   00001E   8243....     MOV.W   #0x0, &stopwatch_seconds
    231                  cycle_count = 0;
   \   000022   8243....     MOV.W   #0x0, &cycle_count
    232                  state = DRIVE;
   \   000026   F2404400.... MOV.B   #0x44, &state
    233                  display_line[1][2] = c.comm;
   \   00002C   E241....     MOV.B   @SP, &display_line + 13
    234                  HEXtoBCD(c.duration, 1, 4);
   \   000030   2E42         MOV.W   #0x4, R14
   \   000032   1D43         MOV.W   #0x1, R13
   \   000034   1C410200     MOV.W   0x2(SP), R12
   \   000038   ........     CALLA   #HEXtoBCD
    235                  driveTime = (int)(c.duration * (c.comm == RIGHT_COMMAND || c.comm == LEFT_COMMAND ? TURN_CONSTANT : 1));
   \   00003C   F19052000000 CMP.B   #0x52, 0(SP)
   \   000042   0424         JEQ     ??ProcessCommands_3
   \   000044   F1904C000000 CMP.B   #0x4c, 0(SP)
   \   00004A   0320         JNE     ??ProcessCommands_4
   \                     ??ProcessCommands_3:
   \   00004C   3F400300     MOV.W   #0x3, R15
   \   000050   013C         JMP     ??ProcessCommands_0
   \                     ??ProcessCommands_4:
   \   000052   1F43         MOV.W   #0x1, R15
   \                     ??ProcessCommands_0:
   \   000054   0212         PUSH.W  SR
   \   000056   32C2         DINT
   \   000058   0343         NOP
   \   00005A   92410400.... MOV.W   0x4(SP), &__iar_HWMUL          // MPY
   \   000060   824F....     MOV.W   R15, &__iar_HWMUL + 8          // OP2
   \   000064   9242........ MOV.W   &__iar_HWMUL + 10, &driveTime  // RESLO
   \   00006A   0343         NOP
   \   00006C   3241         POP.W   SR
    236          
    237                  switch(c.comm) {
   \   00006E   6E41         MOV.B   @SP, R14
   \   000070   7E804200     SUB.B   #0x42, R14
   \   000074   1124         JEQ     ??ProcessCommands_5
   \   000076   6E82         SUB.B   #0x4, R14
   \   000078   0A24         JEQ     ??ProcessCommands_6
   \   00007A   7E800600     SUB.B   #0x6, R14
   \   00007E   1624         JEQ     ??ProcessCommands_7
   \   000080   7E800300     SUB.B   #0x3, R14
   \   000084   1824         JEQ     ??ProcessCommands_8
   \   000086   7E800300     SUB.B   #0x3, R14
   \   00008A   0B24         JEQ     ??ProcessCommands_9
   \   00008C   183C         JMP     ??ProcessCommands_1
    238                      case (FORWARD_COMMAND):
    239                          polarityRight = 1;
   \                     ??ProcessCommands_6:
   \   00008E   9243....     MOV.W   #0x1, &polarityRight
    240                          polarityLeft = 1;
   \   000092   9243....     MOV.W   #0x1, &polarityLeft
    241                          break;
   \   000096   163C         JMP     ??ProcessCommands_2
    242          
    243                      case (REVERSE_COMMAND):
    244                          polarityRight = -1;
   \                     ??ProcessCommands_5:
   \   000098   B243....     MOV.W   #0xffff, &polarityRight
    245                          polarityLeft = -1;
   \   00009C   B243....     MOV.W   #0xffff, &polarityLeft
    246                          break;
   \   0000A0   113C         JMP     ??ProcessCommands_2
    247          
    248                      case (RIGHT_COMMAND):
    249                          polarityRight = 1;
   \                     ??ProcessCommands_9:
   \   0000A2   9243....     MOV.W   #0x1, &polarityRight
    250                          polarityLeft = -1;
   \   0000A6   B243....     MOV.W   #0xffff, &polarityLeft
    251                          break;
   \   0000AA   0C3C         JMP     ??ProcessCommands_2
    252          
    253                      case (LEFT_COMMAND):
    254                          polarityRight = -1;
   \                     ??ProcessCommands_7:
   \   0000AC   B243....     MOV.W   #0xffff, &polarityRight
    255                          polarityLeft = 1;
   \   0000B0   9243....     MOV.W   #0x1, &polarityLeft
    256                          break;
   \   0000B4   073C         JMP     ??ProcessCommands_2
    257          
    258                      case (LINEFOLLOW_COMMAND):
    259                          state = STRAIGHT;
   \                     ??ProcessCommands_8:
   \   0000B6   F2407300.... MOV.B   #0x73, &state
    260                          break;
   \   0000BC   033C         JMP     ??ProcessCommands_2
    261          
    262                      default:
    263                          state = START;
   \                     ??ProcessCommands_1:
   \   0000BE   F2405300.... MOV.B   #0x53, &state
    264                          break;
    265                  }
    266              }
    267          }
   \                     ??ProcessCommands_2:
   \   0000C4   A1000400     ADDA    #0x4, SP
   \   0000C8   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for iot_setup_state>`:
   \   000000   42           DC8 66

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "WIFI GOT IP\\r\\n">`:
   \   000000   574946492047 DC8 "WIFI GOT IP\015\012"
   \            4F542049500D
   \            0A00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CIPMUX=1\\r\\n">`:
   \   000000   41542B434950 DC8 "AT+CIPMUX=1\015\012"
   \            4D55583D310D
   \            0A00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CIPSERVER=1,4764\\r\\n">`:
   \   000000   41542B434950 DC8 "AT+CIPSERVER=1,4764\015\012"
   \            534552564552
   \            3D312C343736
   \            340D0A00    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CWJAP?\\r\\n">`:
   \   000000   41542B43574A DC8 "AT+CWJAP?\015\012"
   \            41503F0D0A00

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "+CWJAP:">`:
   \   000000   2B43574A4150 DC8 "+CWJAP:"
   \            3A00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CIFSR\\r\\n">`:
   \   000000   41542B434946 DC8 "AT+CIFSR\015\012"
   \            53520D0A00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "+CIFSR:STAIP,">`:
   \   000000   2B4349465352 DC8 "+CIFSR:STAIP,"
   \            3A5354414950
   \            2C00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "IP ADDRESS">`:
   \   000000   495020414444 DC8 "IP ADDRESS"
   \            5245535300  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "^9A73">`:
   \   000000   5E3941373300 DC8 "^9A73"

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     24   IOTBufferCommands
       20   -> clearProcessBuff_0
       24   -> pushCB
       20   -> stoi
       20   -> strchr
       20   -> strstr
       24   -> strstr
      6   Init_IOT
        6   -> USCI_A0_transmit
        6   -> centerStringToDisplay
        6   -> clearProcessBuff_0
        6   -> strcmp
        6   -> strcpy
        6   -> strncmp
     10   ProcessCommands
        8   -> HEXtoBCD
        8   -> popCB
      8   centerStringToDisplay
        8   -> strcpy
        8   -> strlen
     10   popCB
      4   pushCB
      8   stoi
        8   -> strlen
      8   strchr
        8   -> __iar_Strchr
      8   strstr
        8   -> __iar_Strstr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      14  ?<Constant "+CIFSR:STAIP,">
       8  ?<Constant "+CWJAP:">
      11  ?<Constant "AT+CIFSR\r\n">
      14  ?<Constant "AT+CIPMUX=1\r\n">
      22  ?<Constant "AT+CIPSERVER=1,4764\r\n">
      12  ?<Constant "AT+CWJAP?\r\n">
      11  ?<Constant "IP ADDRESS">
      14  ?<Constant "WIFI GOT IP\r\n">
       6  ?<Constant "^9A73">
       1  ?<Initializer for iot_setup_state>
      20  CommandBuffer
     128  IOTBufferCommands
      14  IP
     516  Init_IOT
     202  ProcessCommands
      11  SSID
       2  _A_UCA0IE_L
       1  cb_index
      44  centerStringToDisplay
       1  dotFound
       4  emptyCommand
       1  iot_setup_state
       1  midFound
       2  midIndex
      78  popCB
      56  pushCB
      72  stoi
      18  strchr
      18  strstr

 
 1 132 bytes in segment CODE
     2 bytes in segment DATA16_AN
   112 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    54 bytes in segment DATA16_Z
 
 1 096 bytes of CODE  memory (+ 36 bytes shared)
   113 bytes of CONST memory
    55 bytes of DATA  memory (+  2 bytes shared)

Errors: none
Warnings: 1
