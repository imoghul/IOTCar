###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          04/Apr/2022  16:56:36
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 09\sm.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWF6C4.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 09\sm.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 09\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 09\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 09\Debug\List\sm.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 09\Debug\Obj\sm.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 09\sm.c
      1          #include "msp430.h"
      2          #include "ports.h"
      3          #include "wheels.h"
      4          #include "sm.h"
      5          #include <string.h>
      6          #include "adc.h"
      7          #include "timers.h"
      8          #include "detectors.h"
      9          #include "pid.h"
     10          
     11          extern volatile unsigned int cycle_count;
     12          extern volatile unsigned int stopwatch_milliseconds;
     13          extern volatile unsigned int stopwatch_seconds;
     14          extern volatile unsigned char display_changed;
     15          extern char display_line[4][11];
     16          extern volatile unsigned int wheel_periods;
     17          volatile char state = CALIBRATE;
     18          volatile int stateCounter;
     19          volatile char nextState = STRAIGHT;
     20          extern volatile unsigned int Time_Sequence;
     21          extern volatile unsigned int Last_Time_Sequence;
     22          extern volatile unsigned int time_change;
     23          volatile unsigned int delayTime = 1;
     24          extern volatile unsigned int ADC_Left_Detect, ADC_Right_Detect;
     25          extern volatile unsigned int rightSwitchable, leftSwitchable;
     26          extern unsigned int temp;
     27          extern char movingDirection;
     28          char enteringDirection = NOT_MOVING;
     29          extern int leftVals[VALUES_TO_HOLD];
     30          extern int rightVals[VALUES_TO_HOLD];
     31          extern volatile unsigned int calibrationMode;
     32          extern unsigned int LBDetect, LWDetect, RBDetect, RWDetect;
     33          extern PIDController rightFollowController, rightAdjustController;
     34          extern PIDController leftFollowController, leftAdjustController;
     35          
     36          void Straight(void) {
     37          
     38              if (stateCounter == 0) {
     39                  strcpy(display_line[0], "INTERCEPT ");
     40                  display_changed = 1;
     41                  EmitterOn();
     42                  stateCounter++;
     43              }
     44          
     45              if(stateCounter == 1) {
     46                  if ((ADC_Left_Detect < LEFT_WHITE_DETECT || ADC_Right_Detect < RIGHT_WHITE_DETECT)) {
     47                      Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 0);
     48                  } else {
     49                      int left = ADC_Left_Detect;
     50                      int right = ADC_Right_Detect;
     51          
     52                      if(left > right) enteringDirection = MOVING_LEFT;
     53                      else enteringDirection = MOVING_RIGHT;
     54          
     55                      stateCounter++;
     56                  }
     57              }
     58          
     59              if(stateCounter == 2) {
     60                  if(LockMotors(-1, -1)) stateCounter++;
     61              }
     62          
     63              else if (stateCounter == 3) {
     64                  ShutoffMotors();
     65                  stateCounter = 0 ;
     66                  state = START;
     67                  stopwatch_seconds = 0;
     68                  cycle_count = 0;
     69                  EmitterOff();
     70                  //strcpy(display_line[1], "BLACK LINE");
     71                  //strcpy(display_line[2], " DETECTED ");
     72                  //display_changed = 1;
     73              }
     74          }
     75          
     76          void Turn() {
     77              if (stateCounter == 0) {
     78                  EmitterOn();
     79                  strcpy(display_line[0], "  TURNING ");
     80                  strcpy(display_line[1], "          ");
     81                  strcpy(display_line[2], "          ");
     82                  display_changed = 1;
     83                  stateCounter = 1;
     84              }
     85          
     86              if(stateCounter == 1) {
     87                  if(enteringDirection == MOVING_LEFT) {
     88                      if(Drive_Path(STRAIGHT_RIGHT / 2, -STRAIGHT_LEFT / 2, 20)) stateCounter++;
     89                  } else if(enteringDirection == MOVING_RIGHT) {
     90                      if(Drive_Path(-STRAIGHT_RIGHT / 2, STRAIGHT_LEFT / 2, 20)) stateCounter++;
     91                  }
     92              }
     93          
     94              if (stateCounter == 2) {
     95                  if (((ADC_Left_Detect <= LEFT_GRAY_DETECT || ADC_Right_Detect <= RIGHT_GRAY_DETECT))) {
     96                      if(enteringDirection == MOVING_LEFT)Drive_Path(STRAIGHT_RIGHT >> 2, -STRAIGHT_LEFT >> 2, 0);
     97          
     98                      if(enteringDirection == MOVING_RIGHT)Drive_Path(-STRAIGHT_RIGHT >> 2, STRAIGHT_LEFT >> 2, 0);
     99                  } else stateCounter++;
    100              } else if (stateCounter == 3) {
    101                  ShutoffMotors();
    102                  stateCounter = 0 ;
    103                  state = START;
    104                  stopwatch_seconds = 0;
    105                  cycle_count = 0;
    106                  EmitterOff();
    107              }
    108          }
    109          
    110          void LineFollow() {
    111          
    112          
    113              if (stateCounter == 0) {
    114                  EmitterOn();
    115                  strcpy(display_line[0], " CIRCLING ");
    116                  display_changed = 1;
    117                  stopwatch_seconds = 0;
    118                  cycle_count = 0;
    119          
    120                  if(rightSwitchable && leftSwitchable)stateCounter++;
    121              }
    122          
    123              int rFollowSpeed, rAdjustSpeed;
                                       ^
Warning[Pe177]: variable "rAdjustSpeed" was declared but never referenced
    124              int lFollowSpeed, lAdjustSpeed;
                                       ^
Warning[Pe177]: variable "lAdjustSpeed" was declared but never referenced
    125          
    126              int leftPIDOut = GetOutput(&leftFollowController, LEFT_WHITE_DETECT, ADC_Left_Detect);
    127              int rightPIDOut = GetOutput(&rightFollowController, RIGHT_WHITE_DETECT, ADC_Right_Detect);
    128              rFollowSpeed = additionSafe(RIGHT_FORWARD_SPEED, RIGHT_MAX, RIGHT_MIN >> 1, leftPIDOut); // swapped b/c they are physically swapped
    129              lFollowSpeed = additionSafe(LEFT_FORWARD_SPEED, LEFT_MAX, LEFT_MIN >> 1, rightPIDOut); // swapped b/c they are physically swapped
    130          
    131              /*leftPIDOut = GetOutput(&leftAdjustController,LEFT_GRAY_DETECT,ADC_Left_Detect);
    132              rightPIDOut = GetOutput(&rightAdjustController,RIGHT_GRAY_DETECT,ADC_Right_Detect);
    133              rAdjustSpeed = additionSafe(RIGHT_FORWARD_SPEED,RIGHT_MAX,RIGHT_MIN>>1,leftPIDOut); // swapped b/c they are physically swapped
    134              lAdjustSpeed = additionSafe(LEFT_FORWARD_SPEED,LEFT_MAX,LEFT_MIN>>1,rightPIDOut); // swapped b/c they are physically swapped*/
    135          
    136              if(stateCounter == 1 && rFollowSpeed != lFollowSpeed) P6OUT |= GRN_LED;
    137              else P6OUT &= ~GRN_LED;
    138          
    139              if(stateCounter == 1) {
    140                  if(ADC_Left_Detect < (LEFT_GRAY_DETECT) ^ ADC_Right_Detect < (RIGHT_GRAY_DETECT)) stateCounter = 2;
    141                  else if (ADC_Left_Detect < (LEFT_GRAY_DETECT) && ADC_Right_Detect < (RIGHT_GRAY_DETECT)) {
    142                      rFollowSpeed = -RIGHT_MIN;
    143                      lFollowSpeed = -LEFT_MIN;
    144                  } else {
    145                      ClearController(&rightFollowController);
    146                      ClearController(&leftFollowController);
    147                  }
    148          
    149                  /*if(ADC_Left_Detect>(LEFT_BLACK_DETECT+50) && ADC_Right_Detect>(RIGHT_BLACK_DETECT+50)){
    150                    rFollowSpeed = RIGHT_MIN;
    151                    lFollowSpeed = LEFT_MIN;
    152                  }*/
    153                  if(delay(70, 0)) stateCounter = 5;
    154          
    155                  Drive_Path(rFollowSpeed, lFollowSpeed, 0);
    156              }
    157          
    158              if(stateCounter == 10)
    159                  if(LockMotorsTime(-1, -1, 1)) stateCounter = 2;
    160          
    161              if(stateCounter == 2) {
    162                  if(ADC_Left_Detect < LEFT_BLACK_DETECT && ADC_Right_Detect >= RIGHT_BLACK_DETECT) //
    163                      stateCounter = 3;
    164                  else if(ADC_Left_Detect >= LEFT_BLACK_DETECT && ADC_Right_Detect < RIGHT_BLACK_DETECT) // LCIRC
    165                      stateCounter = 4;
    166                  else stateCounter = 1;
    167              }
    168          
    169              if(stateCounter == 3) { // turn left ()
    170                  if(ADC_Left_Detect < LEFT_BLACK_DETECT)Drive_Path((RIGHT_MIN - 2000), -(LEFT_MIN - 2000), 0);
    171                  else if (ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 1;
    172                  else stateCounter = 4;
    173              }
    174          
    175              if(stateCounter == 4) {
    176                  if(ADC_Right_Detect < RIGHT_BLACK_DETECT)Drive_Path(-(RIGHT_MIN - 2000), (LEFT_MIN - 2000), 0);
    177                  else if (ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 1;
    178                  else stateCounter = 3;
    179              }
    180          
    181              else if (stateCounter == 5) {
    182                  ShutoffMotors();
    183                  stateCounter = 0 ;
    184                  state = START;
    185                  stopwatch_seconds = 0;
    186                  cycle_count = 0;
    187                  EmitterOff();
    188              }
    189          }
    190          
    191          void Exit() {
    192              if (stateCounter == 0) {
    193                  EmitterOn();
    194                  strcpy(display_line[0], "  EXITING ");
    195                  display_changed = 1;
    196          
    197                  if(rightSwitchable && leftSwitchable)stateCounter++;
    198              }
    199          
    200              if (stateCounter == 1) {
    201                  if(enteringDirection == MOVING_RIGHT) {
    202                      if(Drive_Path(-STRAIGHT_RIGHT, STRAIGHT_LEFT, 90)) stateCounter++;
    203                  } else if (enteringDirection == MOVING_LEFT) {
    204                      if(Drive_Path(STRAIGHT_RIGHT, -STRAIGHT_LEFT, 90)) stateCounter++;
    205                  }
    206              }
    207          
    208              if (stateCounter == 2) {
    209                  if(enteringDirection == MOVING_LEFT) {
    210                      if(LockMotors(1, -1)) stateCounter++;
    211                  } else if (enteringDirection == MOVING_RIGHT) {
    212                      if(LockMotors(-1, 1)) stateCounter++;
    213                  }
    214              }
    215          
    216              if (stateCounter == 3) {
    217                  if(Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 300)) stateCounter++;
    218              }
    219          
    220              if (stateCounter == 4) {
    221                  if(LockMotors(-1, -1)) stateCounter++;
    222              }
    223          
    224              else if (stateCounter == 5) {
    225                  ShutoffMotors();
    226                  stateCounter = 0 ;
    227                  state = START;
    228                  stopwatch_seconds = 0;
    229                  cycle_count = 0;
    230                  EmitterOff();
    231              }
    232          }
    233          
    234          void Straight(void) {
                      ^
Error[Pe247]: function "Straight" has already been defined (at line 36)
    235          
    236              if (stateCounter == 0) {
    237                  display_changed = 1;
    238                  EmitterOn();
    239                  stateCounter++;
    240              }
    241          
    242              if(stateCounter == 1) {
    243                  if ((ADC_Left_Detect < LEFT_WHITE_DETECT || ADC_Right_Detect < RIGHT_WHITE_DETECT)) {
    244                      Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 0);
    245                  } else {
    246                      int left = ADC_Left_Detect;
    247                      int right = ADC_Right_Detect;
    248          
    249                      if(left > right) enteringDirection = MOVING_LEFT;
    250                      else enteringDirection = MOVING_RIGHT;
    251          
    252                      stateCounter++;
    253                  }
    254              }
    255          
    256              if(stateCounter == 2) {
    257                  if(LockMotors(-1, -1)) stateCounter++;
    258              }
    259          
    260              else if (stateCounter == 3) {
    261                  ShutoffMotors();
    262                  stateCounter = 0 ;
    263                  state = START;
    264                  stopwatch_seconds = 0;
    265                  cycle_count = 0;
    266                  EmitterOff();
    267              }
    268          }
    269          
    270          
    271          
    272          // delays for a specified time and then switches state to global nextState
    273          // make sure nextState is set to desired vlaue before the end of delay
    274          int delay(int seconds, int cycles) {
    275              if(stopwatch_seconds == 0 && cycle_count <= 1) {
    276                  display_changed = 1;
    277              }
    278          
    279              if(stopwatch_seconds >= seconds && cycle_count >= cycles) {
    280                  stopwatch_seconds = 0;
    281                  cycle_count = 0;
    282                  return 1;
    283              } else return 0;
    284          }
    285          
    286          
    287          
    288          void StateMachine(void) {
    289              switch(state) {
    290                  case (CALIBRATE):
    291                      calibrate();
    292          
    293                      if(calibrationMode >= 2) {
    294                          state = START;
    295                      }
    296          
    297                      break;
    298          
    299                  case (START):
    300                      strcpy(display_line[0], "WAITING...");
    301                      //display_changed = 1;
    302                      stopwatch_seconds = 0;
    303                      cycle_count = 0;
    304                      break;
    305          
    306                  case (WAIT):
    307                      strcpy(display_line[0], "WAITING...");
    308          
    309                      if (delay(delayTime, 0)) state = nextState;
    310          
    311                      break;
    312          
    313                  case (STRAIGHT):
    314                      Straight();
    315                      break;
    316          
    317                  case (TURN):
    318                      Turn();
    319                      break;
    320          
    321                  case (LINEFOLLOW):
    322                      LineFollow();
    323                      break;
    324          
    325                  case (EXIT):
    326                      Exit();
    327                      break;
    328          
    329                  case (END):
    330                      strcpy(display_line[0], "  STOPPED ");
    331                      display_changed = 1;
    332                      break;
    333          
    334                  default:
    335                      break;
    336              }
    337          }

Errors: 1
Warnings: 2
