###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          25/Mar/2022  15:57:46
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 08\serial.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EW4548.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 08\serial.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 08\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 08\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 08\Debug\List\serial.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 08\Debug\Obj\serial.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 08\serial.c
      1          #include "serial.h"
      2          #include <string.h>
      3          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x500
   \   union <unnamed> _A_UCA0CTLW0_L
   \                     _A_UCA0CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x506
   \   union <unnamed> _A_UCA0BRW_L
   \                     _A_UCA0BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x508
   \   union <unnamed> _A_UCA0MCTLW_L
   \                     _A_UCA0MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50c
   \   union <unnamed> _A_UCA0RXBUF_L
   \                     _A_UCA0RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50e
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51c
   \   union <unnamed> _A_UCA0IFG_L
   \                     _A_UCA0IFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51e
   \   union <unnamed> _A_UCA0IV_L
   \                     _A_UCA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x580
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x586
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x588
   \   union <unnamed> _A_UCA1MCTLW_L
   \                     _A_UCA1MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59a
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2
      4          
      5          // global variables

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      6          volatile unsigned int usb0_rx_wr,usb0_rx_rd,usb1_rx_wr,usb1_rx_rd ;
   \                     usb0_rx_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb0_rx_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      7          volatile char USB0_Char_Rx_Ring[SMALL_RING_SIZE],USB0_Char_Rx_Process[LARGE_RING_SIZE];
   \                     USB0_Char_Rx_Ring:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB0_Char_Rx_Process:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      8          volatile char USB1_Char_Rx_Ring[SMALL_RING_SIZE],USB1_Char_Rx_Process[LARGE_RING_SIZE];
   \                     USB1_Char_Rx_Ring:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Rx_Process:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      9          volatile char USB0_Char_Tx[LARGE_RING_SIZE],USB1_Char_Tx[LARGE_RING_SIZE];
   \                     USB0_Char_Tx:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Tx:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     10          unsigned volatile int pb0_index,pb1_index;
   \                     pb0_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     pb1_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     11          unsigned volatile int tx0_index,tx1_index;
   \                     tx0_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     tx1_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     12          unsigned volatile int pb0_buffered,pb1_buffered;
   \                     pb0_buffered:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     pb1_buffered:
   \   000000                DS8 2
     13          extern volatile unsigned char display_changed;
     14          extern char display_line[4][11];
     15          
     16          //----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
     17          void Init_Serial_UCA(void) {
   \                     Init_Serial_UCA:
     18              int i;
     19          
     20              for(i = 0; i < SMALL_RING_SIZE; i++) {
   \   000000   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_0:
   \   000002   3F901000     CMP.W   #0x10, R15
   \   000006   0634         JGE     ??Init_Serial_UCA_2
     21                  USB0_Char_Rx_Ring[i] = 0x00;
   \   000008   CF43....     MOV.B   #0x0, USB0_Char_Rx_Ring(R15)
     22                  USB1_Char_Rx_Ring[i] = 0x00;
   \   00000C   CF43....     MOV.B   #0x0, USB1_Char_Rx_Ring(R15)
     23              }
   \   000010   1F53         ADD.W   #0x1, R15
   \   000012   F73F         JMP     ??Init_Serial_UCA_0
     24          
     25              usb0_rx_wr = BEGINNING;
   \                     ??Init_Serial_UCA_2:
   \   000014   8243....     MOV.W   #0x0, &usb0_rx_wr
     26              usb0_rx_rd = BEGINNING;
   \   000018   8243....     MOV.W   #0x0, &usb0_rx_rd
     27              usb1_rx_wr = BEGINNING;
   \   00001C   8243....     MOV.W   #0x0, &usb1_rx_wr
     28              usb1_rx_rd = BEGINNING;
   \   000020   8243....     MOV.W   #0x0, &usb1_rx_rd
     29          
     30              for(i = 0; i < LARGE_RING_SIZE; i++) {
   \   000024   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_1:
   \   000026   3F901900     CMP.W   #0x19, R15
   \   00002A   0634         JGE     ??Init_Serial_UCA_3
     31                  USB0_Char_Tx[i] = 0x00;
   \   00002C   CF43....     MOV.B   #0x0, USB0_Char_Tx(R15)
     32                  USB1_Char_Tx[i] = 0x00;
   \   000030   CF43....     MOV.B   #0x0, USB1_Char_Tx(R15)
     33              }
   \   000034   1F53         ADD.W   #0x1, R15
   \   000036   F73F         JMP     ??Init_Serial_UCA_1
     34          
     35              //usb0_tx_ring_wr = BEGINNING;
     36              //usb0_tx_ring_rd = BEGINNING;
     37              //usb1_tx_ring_wr = BEGINNING;
     38              //usb1_tx_ring_rd = BEGINNING;
     39              
     40              // Configure UART 0
     41              UCA0CTLW0 = 0;
   \                     ??Init_Serial_UCA_3:
   \   000038   82430005     MOV.W   #0x0, &0x500
     42              UCA0CTLW0 |= UCSWRST;
   \   00003C   92D30005     BIS.W   #0x1, &0x500
     43              UCA0CTLW0 |= UCSSEL__SMCLK;
   \   000040   B2D080000005 BIS.W   #0x80, &0x500
     44              UCA0BRW = 4;
   \   000046   A2420605     MOV.W   #0x4, &0x506
     45              UCA0MCTLW = 0x5551;
   \   00004A   B24051550805 MOV.W   #0x5551, &0x508
     46              UCA0CTLW0 &= ~UCSWRST;
   \   000050   92C30005     BIC.W   #0x1, &0x500
     47              UCA0IE |= UCRXIE;
   \   000054   92D31A05     BIS.W   #0x1, &0x51a
     48              // Configure UART 1
     49              UCA1CTLW0 = 0;
   \   000058   82438005     MOV.W   #0x0, &0x580
     50              UCA1CTLW0 |= UCSWRST;
   \   00005C   92D38005     BIS.W   #0x1, &0x580
     51              UCA1CTLW0 |= UCSSEL__SMCLK;
   \   000060   B2D080008005 BIS.W   #0x80, &0x580
     52              UCA1BRW = 4;
   \   000066   A2428605     MOV.W   #0x4, &0x586
     53              UCA1MCTLW = 0x5551;
   \   00006A   B24051558805 MOV.W   #0x5551, &0x588
     54              UCA1CTLW0 &= ~UCSWRST;
   \   000070   92C38005     BIC.W   #0x1, &0x580
     55              UCA1IE |= UCRXIE;
   \   000074   92D39A05     BIS.W   #0x1, &0x59a
     56          }
   \   000078   1001         RETA
   \   00007A                REQUIRE _A_UCA0CTLW0_L
   \   00007A                REQUIRE _A_UCA0BRW_L
   \   00007A                REQUIRE _A_UCA0MCTLW_L
   \   00007A                REQUIRE _A_UCA0IE_L
   \   00007A                REQUIRE _A_UCA1CTLW0_L
   \   00007A                REQUIRE _A_UCA1BRW_L
   \   00007A                REQUIRE _A_UCA1MCTLW_L
   \   00007A                REQUIRE _A_UCA1IE_L
     57          //------------------------------------------------------------------------------
     58          #pragma vector=EUSCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
     59          __interrupt void eUSCI_A0_ISR(void) {
   \                     eUSCI_A0_ISR:
   \   000000   2F15         PUSHM.W #0x3, R15
     60              unsigned int temp;
     61          
     62              switch(__even_in_range(UCA0IV, 0x08)) {
   \   000002   1F421E05     MOV.W   &0x51e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A0_ISR>_0`:
   \   000008   2E3C         JMP     ??eUSCI_A0_ISR_2
   \   00000A   033C         JMP     ??eUSCI_A0_ISR_3
   \   00000C   143C         JMP     ??eUSCI_A0_ISR_4
   \   00000E   2B3C         JMP     ??eUSCI_A0_ISR_2
   \   000010   2A3C         JMP     ??eUSCI_A0_ISR_2
     63                  case 0:
     64                      break;
     65          
     66                  case 2: // RXIFG
     67                      temp = usb0_rx_wr++;
   \                     ??eUSCI_A0_ISR_3:
   \   000012   1F42....     MOV.W   &usb0_rx_wr, R15
   \   000016   0E4F         MOV.W   R15, R14
   \   000018   1E53         ADD.W   #0x1, R14
   \   00001A   824E....     MOV.W   R14, &usb0_rx_wr
   \   00001E   0D4F         MOV.W   R15, R13
     68                      USB0_Char_Rx_Ring[temp] = UCA0RXBUF;
   \   000020   1E420C05     MOV.W   &0x50c, R14
   \   000024   CD4E....     MOV.B   R14, USB0_Char_Rx_Ring(R13)
     69                      
     70                      if (usb0_rx_wr >= (sizeof(USB0_Char_Rx_Ring))) {
   \   000028   B2901000.... CMP.W   #0x10, &usb0_rx_wr
   \   00002E   1B28         JNC     ??eUSCI_A0_ISR_2
     71                          usb0_rx_wr = BEGINNING;
   \   000030   8243....     MOV.W   #0x0, &usb0_rx_wr
     72                      }
     73          
     74                      break;
   \   000034   183C         JMP     ??eUSCI_A0_ISR_2
     75          
     76                  case 4: // TXIFG
     77                    UCA0TXBUF = USB0_Char_Tx[tx0_index];
   \                     ??eUSCI_A0_ISR_4:
   \   000036   1F42....     MOV.W   &tx0_index, R15
   \   00003A   5F4F....     MOV.B   USB0_Char_Tx(R15), R15
   \   00003E   4F4F         MOV.B   R15, R15
   \   000040   824F0E05     MOV.W   R15, &0x50e
     78                    USB0_Char_Tx[tx0_index++] = 0;
   \   000044   1F42....     MOV.W   &tx0_index, R15
   \   000048   0E4F         MOV.W   R15, R14
   \   00004A   1E53         ADD.W   #0x1, R14
   \   00004C   824E....     MOV.W   R14, &tx0_index
   \   000050   CF43....     MOV.B   #0x0, USB0_Char_Tx(R15)
     79                    if(USB0_Char_Tx[tx0_index] == 0) {
   \   000054   1F42....     MOV.W   &tx0_index, R15
   \   000058   CF93....     CMP.B   #0x0, USB0_Char_Tx(R15)
   \   00005C   0420         JNE     ??eUSCI_A0_ISR_2
     80                      UCA0IE &= ~UCTXIE;
   \   00005E   A2C31A05     BIC.W   #0x2, &0x51a
     81                      clearProcessBuff0();
   \   000062   ........     CALLA   #clearProcessBuff0
     82                    }
     83                    break;
     84          
     85                  default:
     86                      break;
     87              }
     88          }
   \                     ??eUSCI_A0_ISR_2:
   \   000066   2D17         POPM.W  #0x3, R15
   \   000068   0013         RETI
   \   00006A                REQUIRE _A_UCA0RXBUF_L
   \   00006A                REQUIRE _A_UCA0TXBUF_L
   \   00006A                REQUIRE _A_UCA0IE_L
   \   00006A                REQUIRE _A_UCA0IV_L
     89          
     90          
     91          

   \                                 In  segment CODE, align 2
     92          void clearProcessBuff0(){
   \                     clearProcessBuff0:
     93            for(int i = 0;i<sizeof(USB0_Char_Rx_Process);++i)USB0_Char_Rx_Process[i]=0;
   \   000000   0F43         MOV.W   #0x0, R15
   \                     ??clearProcessBuff0_0:
   \   000002   3F901900     CMP.W   #0x19, R15
   \   000006   042C         JC      ??clearProcessBuff0_1
   \   000008   CF43....     MOV.B   #0x0, USB0_Char_Rx_Process(R15)
   \   00000C   1F53         ADD.W   #0x1, R15
   \   00000E   F93F         JMP     ??clearProcessBuff0_0
     94            pb0_index=0;
   \                     ??clearProcessBuff0_1:
   \   000010   8243....     MOV.W   #0x0, &pb0_index
     95            pb0_buffered=0;
   \   000014   8243....     MOV.W   #0x0, &pb0_buffered
     96          }
   \   000018   1001         RETA
     97          

   \                                 In  segment CODE, align 2
     98          void out_character(char character) {
   \                     out_character:
   \                     ??out_character_0:
     99              //------------------------------------------------------------------------------
    100              // The while loop will stall as long as the Flag is not set [port is busy]
    101              while (!(UCA0IFG & UCTXIFG)); // USCI_A0 TX buffer ready?
   \   000000   A2B31C05     BIT.W   #0x2, &0x51c
   \   000004   FD2B         JNC     ??out_character_0
    102          
    103              UCA0TXBUF = character;
   \   000006   4C4C         MOV.B   R12, R12
   \   000008   824C0E05     MOV.W   R12, &0x50e
    104              //------------------------------------------------------------------------------
    105          }
   \   00000C   1001         RETA
   \   00000E                REQUIRE _A_UCA0IFG_L
   \   00000E                REQUIRE _A_UCA0TXBUF_L
    106          

   \                                 In  segment CODE, align 2
    107          void USCI_A0_transmit(void){
   \                     USCI_A0_transmit:
    108            tx0_index=0;
   \   000000   8243....     MOV.W   #0x0, &tx0_index
    109            UCA0IE |= UCTXIE;
   \   000004   A2D31A05     BIS.W   #0x2, &0x51a
    110          }
   \   000008   1001         RETA
   \   00000A                REQUIRE _A_UCA0IE_L

   \                                 In  segment CODE, align 2
    111          void USCI_A1_transmit(void){
   \                     USCI_A1_transmit:
    112            tx1_index=0;
   \   000000   8243....     MOV.W   #0x0, &tx1_index
    113            UCA1IE |= UCTXIE;
   \   000004   A2D39A05     BIS.W   #0x2, &0x59a
    114          }
   \   000008   1001         RETA
   \   00000A                REQUIRE _A_UCA1IE_L
    115          

   \                                 In  segment CODE, align 2
    116          void loadRingtoPB_0(void){
   \                     loadRingtoPB_0:
    117            if(usb0_rx_wr != usb0_rx_rd){
                   ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   000000   1F42....     MOV.W   &usb0_rx_wr, R15
   \   000004   1F92....     CMP.W   &usb0_rx_rd, R15
   \   000008   1D24         JEQ     ??loadRingtoPB_0_0
    118              USB0_Char_Rx_Process[pb0_index] = USB0_Char_Rx_Ring[usb0_rx_rd];
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   00000A   1F42....     MOV.W   &pb0_index, R15
   \   00000E   1E42....     MOV.W   &usb0_rx_rd, R14
   \   000012   DF4E........ MOV.B   USB0_Char_Rx_Ring(R14), USB0_Char_Rx_Process(R15)
    119              if(usb0_rx_rd++ >= SMALL_RING_SIZE-1) usb0_rx_rd = BEGINNING;
   \   000018   1F42....     MOV.W   &usb0_rx_rd, R15
   \   00001C   0E4F         MOV.W   R15, R14
   \   00001E   1E53         ADD.W   #0x1, R14
   \   000020   824E....     MOV.W   R14, &usb0_rx_rd
   \   000024   3F900F00     CMP.W   #0xf, R15
   \   000028   0228         JNC     ??loadRingtoPB_0_1
   \   00002A   8243....     MOV.W   #0x0, &usb0_rx_rd
    120              if(pb0_index++ >= LARGE_RING_SIZE-1) pb0_index=BEGINNING;
   \                     ??loadRingtoPB_0_1:
   \   00002E   1F42....     MOV.W   &pb0_index, R15
   \   000032   0E4F         MOV.W   R15, R14
   \   000034   1E53         ADD.W   #0x1, R14
   \   000036   824E....     MOV.W   R14, &pb0_index
   \   00003A   3F901800     CMP.W   #0x18, R15
   \   00003E   0228         JNC     ??loadRingtoPB_0_0
   \   000040   8243....     MOV.W   #0x0, &pb0_index
    121            }
    122            if(pb0_index>=2 && USB0_Char_Rx_Process[pb0_index-1]=='\n' && USB0_Char_Rx_Process[pb0_index-2]=='\r') {
   \                     ??loadRingtoPB_0_0:
   \   000044   A293....     CMP.W   #0x2, &pb0_index
   \   000048   1028         JNC     ??loadRingtoPB_0_2
   \   00004A   1F42....     MOV.W   &pb0_index, R15
   \   00004E   FF900A00.... CMP.B   #0xa, LWRD(USB0_Char_Rx_Process + 65535)(R15)
   \   000054   0A20         JNE     ??loadRingtoPB_0_2
   \   000056   1F42....     MOV.W   &pb0_index, R15
   \   00005A   FF900D00.... CMP.B   #0xd, LWRD(USB0_Char_Rx_Process + 65534)(R15)
   \   000060   0420         JNE     ??loadRingtoPB_0_2
    123              pb0_buffered = 1;
   \   000062   9243....     MOV.W   #0x1, &pb0_buffered
    124              pb0_index = BEGINNING;
   \   000066   8243....     MOV.W   #0x0, &pb0_index
    125            }
    126          }
   \                     ??loadRingtoPB_0_2:
   \   00006A   1001         RETA
    127          

   \                                 In  segment CODE, align 2
    128          void copyPBtoTx_0(void){
   \                     copyPBtoTx_0:
    129            if(!pb0_buffered)return;
   \   000000   8293....     CMP.W   #0x0, &pb0_buffered
   \   000004   2124         JEQ     ??copyPBtoTx_0_3
    130            for(int i = 0;i<sizeof(USB0_Char_Rx_Process);++i) USB0_Char_Tx[i] = USB0_Char_Rx_Process[i];
   \   000006   0F43         MOV.W   #0x0, R15
   \                     ??copyPBtoTx_0_0:
   \   000008   3F901900     CMP.W   #0x19, R15
   \   00000C   052C         JC      ??copyPBtoTx_0_4
   \   00000E   DF4F........ MOV.B   USB0_Char_Rx_Process(R15), USB0_Char_Tx(R15)
   \   000014   1F53         ADD.W   #0x1, R15
   \   000016   F83F         JMP     ??copyPBtoTx_0_0
    131            strcpy(display_line[3],(char*)USB0_Char_Tx);
   \                     ??copyPBtoTx_0_4:
   \   000018   3D40....     MOV.W   #USB0_Char_Tx, R13
   \   00001C   3C40....     MOV.W   #display_line + 33, R12
   \   000020   ........     CALLA   #strcpy
    132            for(int i = 0;i<10;++i)
   \   000024   0F43         MOV.W   #0x0, R15
   \                     ??copyPBtoTx_0_1:
   \   000026   3F900A00     CMP.W   #0xa, R15
   \   00002A   0C34         JGE     ??copyPBtoTx_0_5
    133              if(display_line[3][i] == '\r' || display_line[3][i]=='\n') display_line[3][i]=0;
   \   00002C   FF900D00.... CMP.B   #0xd, display_line + 33(R15)
   \   000032   0424         JEQ     ??copyPBtoTx_0_6
   \   000034   FF900A00.... CMP.B   #0xa, display_line + 33(R15)
   \   00003A   0220         JNE     ??copyPBtoTx_0_7
   \                     ??copyPBtoTx_0_6:
   \   00003C   CF43....     MOV.B   #0x0, display_line + 33(R15)
   \                     ??copyPBtoTx_0_7:
   \   000040   1F53         ADD.W   #0x1, R15
   \   000042   F13F         JMP     ??copyPBtoTx_0_1
    134            clearProcessBuff0();
   \                     ??copyPBtoTx_0_5:
   \   000044   ........     CALLA   #clearProcessBuff0
    135          }
   \                     ??copyPBtoTx_0_3:
   \   000048   1001         RETA

   \                                 In  segment INTVEC, offset 0x42, root
   \                     `??eUSCI_A0_ISR::??INTVEC 66`:
   \   000042   ....         DC16    eUSCI_A0_ISR
    136          
    137          
    138          
    139          //int i = 0;
    140                      //for(;i<10 && USB1_Char_Rx[i]!=0;++i)
    141                      //  display_line[1][i] = USB1_Char_Rx[i];
    142                      //for(;i<10;++i) display_line[1][i]=' ';
    143                      //display_line[1][10] = 0;
    144                  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Init_Serial_UCA
      4   USCI_A0_transmit
      4   USCI_A1_transmit
      4   clearProcessBuff0
      4   copyPBtoTx_0
        4   -> clearProcessBuff0
        4   -> strcpy
     10   eUSCI_A0_ISR
       10   -> clearProcessBuff0
      4   loadRingtoPB_0
      4   out_character


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     122  Init_Serial_UCA
      25  USB0_Char_Rx_Process
      16  USB0_Char_Rx_Ring
      25  USB0_Char_Tx
      25  USB1_Char_Rx_Process
      16  USB1_Char_Rx_Ring
      25  USB1_Char_Tx
      10  USCI_A0_transmit
      10  USCI_A1_transmit
       2  _A_UCA0BRW_L
       2  _A_UCA0CTLW0_L
       2  _A_UCA0IE_L
       2  _A_UCA0IFG_L
       2  _A_UCA0IV_L
       2  _A_UCA0MCTLW_L
       2  _A_UCA0RXBUF_L
       2  _A_UCA0TXBUF_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1IE_L
       2  _A_UCA1MCTLW_L
      26  clearProcessBuff0
      74  copyPBtoTx_0
     106  eUSCI_A0_ISR
       2  eUSCI_A0_ISR::??INTVEC 66
     108  loadRingtoPB_0
      14  out_character
       2  pb0_buffered
       2  pb0_index
       2  pb1_buffered
       2  pb1_index
       2  tx0_index
       2  tx1_index
       2  usb0_rx_rd
       2  usb0_rx_wr
       2  usb1_rx_rd
       2  usb1_rx_wr

 
 364 bytes in segment CODE
  24 bytes in segment DATA16_AN
 152 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
 106 bytes in segment ISR_CODE
 
 470 bytes of CODE  memory
   0 bytes of CONST memory (+  2 bytes shared)
 152 bytes of DATA  memory (+ 24 bytes shared)

Errors: none
Warnings: 2
