###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          22/Mar/2022  18:58:53
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 07\sm.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWFD56.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 07\sm.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 07\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 07\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 07\Debug\List\sm.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 07\Debug\Obj\sm.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 07\sm.c
      1          #include "msp430.h"
      2          #include "ports.h"
      3          #include "wheels.h"
      4          #include "sm.h"
      5          #include <string.h>
      6          #include "adc.h"
      7          #include "timers.h"
      8          #include "detectors.h"
      9          #include "pid.h"
     10          
     11          extern volatile unsigned int cycle_count;
     12          extern volatile unsigned int stopwatch_milliseconds;
     13          extern volatile unsigned int stopwatch_seconds;
     14          extern volatile unsigned char display_changed;
     15          extern char display_line[4][11];
     16          extern volatile unsigned int wheel_periods;
     17          volatile char state = CALIBRATE;
     18          volatile int stateCounter;
     19          volatile char nextState = STRAIGHT;
     20          extern volatile unsigned int Time_Sequence;
     21          extern volatile unsigned int Last_Time_Sequence;
     22          extern volatile unsigned int time_change;
     23          volatile unsigned int delayTime = 1;
     24          extern volatile unsigned int ADC_Left_Detect, ADC_Right_Detect;
     25          extern volatile unsigned int rightSwitchable, leftSwitchable;
     26          extern unsigned int temp;
     27          extern char movingDirection;
     28          char enteringDirection = NOT_MOVING;
     29          extern int leftVals[VALUES_TO_HOLD];
     30          extern int rightVals[VALUES_TO_HOLD];
     31          extern volatile unsigned int calibrationMode;
     32          extern unsigned int LBDetect, LWDetect, RBDetect, RWDetect;
     33          extern PIDController rightFollowController, rightAdjustController;
     34          extern PIDController leftFollowController, leftAdjustController;
     35          
     36          void Straight(void) {
     37          
     38              if (stateCounter == 0) {
     39                  strcpy(display_line[0], "INTERCEPT ");
     40                  display_changed = 1;
     41                  EmitterOn();
     42                  stateCounter++;
     43              }
     44          
     45              if(stateCounter == 1) {
     46                  if ((ADC_Left_Detect < LEFT_WHITE_DETECT || ADC_Right_Detect < RIGHT_WHITE_DETECT)) {
     47                      Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 0);
     48                  } else {
     49                      int left = ADC_Left_Detect;
     50                      int right = ADC_Right_Detect;
     51          
     52                      if(left > right) enteringDirection = MOVING_LEFT;
     53                      else enteringDirection = MOVING_RIGHT;
     54          
     55                      stateCounter++;
     56                  }
     57              }
     58          
     59              if(stateCounter == 2) {
     60                  if(LockMotors(-1, -1)) stateCounter++;
     61              }
     62          
     63              else if (stateCounter == 3) {
     64                  ShutoffMotors();
     65                  stateCounter = 0 ;
     66                  state = WAIT;
     67                  delayTime = 3;
     68                  stopwatch_seconds = 0;
     69                  cycle_count = 0;
     70                  nextState = TURN;
     71                  EmitterOff();
     72                  //strcpy(display_line[1], "BLACK LINE");
     73                  //strcpy(display_line[2], " DETECTED ");
     74                  //display_changed = 1;
     75              }
     76          }
     77          
     78          void Turn() {
     79              if (stateCounter == 0) {
     80                  EmitterOn();
     81                  strcpy(display_line[0], "  TURNING ");
     82                  strcpy(display_line[1], "          ");
     83                  strcpy(display_line[2], "          ");
     84                  display_changed = 1;
     85                  stateCounter = 1;
     86              }
     87          
     88              if(stateCounter == 1) {
     89                  if(enteringDirection == MOVING_LEFT) {
     90                      if(Drive_Path(STRAIGHT_RIGHT / 2, -STRAIGHT_LEFT / 2, 20)) stateCounter++;
     91                  } else if(enteringDirection == MOVING_RIGHT) {
     92                      if(Drive_Path(-STRAIGHT_RIGHT / 2, STRAIGHT_LEFT / 2, 20)) stateCounter++;
     93                  }
     94              }
     95          
     96              if (stateCounter == 2) {
     97                  if (((ADC_Left_Detect <= LEFT_GRAY_DETECT || ADC_Right_Detect <= RIGHT_GRAY_DETECT))) {
                                                                                          ^
Error[Pe020]: identifier "RBDetec" is undefined
     98                      if(enteringDirection == MOVING_LEFT)Drive_Path(STRAIGHT_RIGHT >> 2, -STRAIGHT_LEFT >> 2, 0);
     99          
    100                      if(enteringDirection == MOVING_RIGHT)Drive_Path(-STRAIGHT_RIGHT >> 2, STRAIGHT_LEFT >> 2, 0);
    101                  } else stateCounter++;
    102              } else if (stateCounter == 3) {
    103                  ShutoffMotors();
    104                  stateCounter = 0 ;
    105                  state = WAIT;
    106                  delayTime = 3;
    107                  stopwatch_seconds = 0;
    108                  cycle_count = 0;
    109                  nextState = LINEFOLLOW;
    110                  EmitterOff();
    111              }
    112          }
    113          
    114          void LineFollow() {
    115          
    116          
    117              if (stateCounter == 0) {
    118                  EmitterOn();
    119                  strcpy(display_line[0], " CIRCLING ");
    120                  display_changed = 1;
    121                  stopwatch_seconds = 0;
    122                  cycle_count = 0;
    123          
    124                  if(rightSwitchable && leftSwitchable)stateCounter++;
    125              }
    126          
    127              int rFollowSpeed, rAdjustSpeed;
    128              int lFollowSpeed, lAdjustSpeed;
    129          
    130              int leftPIDOut = GetOutput(&leftFollowController, LEFT_WHITE_DETECT, ADC_Left_Detect);
    131              int rightPIDOut = GetOutput(&rightFollowController, RIGHT_WHITE_DETECT, ADC_Right_Detect);
    132              rFollowSpeed = additionSafe(RIGHT_FORWARD_SPEED, RIGHT_MAX, RIGHT_MIN >> 1, leftPIDOut); // swapped b/c they are physically swapped
    133              lFollowSpeed = additionSafe(LEFT_FORWARD_SPEED, LEFT_MAX, LEFT_MIN >> 1, rightPIDOut); // swapped b/c they are physically swapped
    134          
    135              /*leftPIDOut = GetOutput(&leftAdjustController,LEFT_GRAY_DETECT,ADC_Left_Detect);
    136              rightPIDOut = GetOutput(&rightAdjustController,RIGHT_GRAY_DETECT,ADC_Right_Detect);
    137              rAdjustSpeed = additionSafe(RIGHT_FORWARD_SPEED,RIGHT_MAX,RIGHT_MIN>>1,leftPIDOut); // swapped b/c they are physically swapped
    138              lAdjustSpeed = additionSafe(LEFT_FORWARD_SPEED,LEFT_MAX,LEFT_MIN>>1,rightPIDOut); // swapped b/c they are physically swapped*/
    139          
    140              if(stateCounter == 1 && rFollowSpeed != lFollowSpeed) P6OUT |= GRN_LED;
    141              else P6OUT &= ~GRN_LED;
    142          
    143              if(stateCounter == 1) {
    144                  if(ADC_Left_Detect < (LEFT_GRAY_DETECT) ^ ADC_Right_Detect < (RIGHT_GRAY_DETECT)) stateCounter = 2;
                                                                                       ^
Error[Pe020]: identifier "RBDetec" is undefined

      int rFollowSpeed, rAdjustSpeed;
                        ^
"C:\Users\saad\Documents\ece-306\Project 07\sm.c",127  Warning[Pe177]: variable
          "rAdjustSpeed" was declared but never referenced

      int lFollowSpeed, lAdjustSpeed;
                        ^
"C:\Users\saad\Documents\ece-306\Project 07\sm.c",128  Warning[Pe177]: variable
          "lAdjustSpeed" was declared but never referenced
    145                  else if (ADC_Left_Detect < (LEFT_GRAY_DETECT) && ADC_Right_Detect < (RIGHT_GRAY_DETECT)) {
    146                      rFollowSpeed = -RIGHT_MIN;
    147                      lFollowSpeed = -LEFT_MIN;
    148                  } else {
    149                      ClearController(&rightFollowController);
    150                      ClearController(&leftFollowController);
    151                  }
    152          
    153                  /*if(ADC_Left_Detect>(LEFT_BLACK_DETECT+50) && ADC_Right_Detect>(RIGHT_BLACK_DETECT+50)){
    154                    rFollowSpeed = RIGHT_MIN;
    155                    lFollowSpeed = LEFT_MIN;
    156                  }*/
    157                  if(delay(70, 0)) stateCounter = 5;
    158          
    159                  Drive_Path(rFollowSpeed, lFollowSpeed, 0);
    160              }
    161          
    162              if(stateCounter == 10)
    163                  if(LockMotorsTime(-1, -1, 1)) stateCounter = 2;
    164          
    165              if(stateCounter == 2) {
    166                  if(ADC_Left_Detect < LEFT_BLACK_DETECT && ADC_Right_Detect >= RIGHT_BLACK_DETECT) //
    167                      stateCounter = 3;
    168                  else if(ADC_Left_Detect >= LEFT_BLACK_DETECT && ADC_Right_Detect < RIGHT_BLACK_DETECT) // LCIRC
    169                      stateCounter = 4;
    170                  else stateCounter = 1;
    171              }
    172          
    173              if(stateCounter == 3) { // turn left ()
    174                  if(ADC_Left_Detect < LEFT_BLACK_DETECT)Drive_Path((RIGHT_MIN - 2000), -(LEFT_MIN - 2000), 0);
    175                  else if (ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 1;
    176                  else stateCounter = 4;
    177              }
    178          
    179              if(stateCounter == 4) {
    180                  if(ADC_Right_Detect < RIGHT_BLACK_DETECT)Drive_Path(-(RIGHT_MIN - 2000), (LEFT_MIN - 2000), 0);
    181                  else if (ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 1;
    182                  else stateCounter = 3;
    183              }
    184          
    185              else if (stateCounter == 5) {
    186                  ShutoffMotors();
    187                  stateCounter = 0 ;
    188                  state = WAIT;
    189                  stopwatch_seconds = 0;
    190                  cycle_count = 0;
    191                  nextState = EXIT;
    192                  EmitterOff();
    193              }
    194          }
    195          
    196          void Exit() {
    197              if (stateCounter == 0) {
    198                  EmitterOn();
    199                  strcpy(display_line[0], "  EXITING ");
    200                  display_changed = 1;
    201          
    202                  if(rightSwitchable && leftSwitchable)stateCounter++;
    203              }
    204          
    205              if (stateCounter == 1) {
    206                  if(enteringDirection == MOVING_RIGHT) {
    207                      if(Drive_Path(-STRAIGHT_RIGHT, STRAIGHT_LEFT, 90)) stateCounter++;
    208                  } else if (enteringDirection == MOVING_LEFT) {
    209                      if(Drive_Path(STRAIGHT_RIGHT, -STRAIGHT_LEFT, 90)) stateCounter++;
    210                  }
    211              }
    212          
    213              if (stateCounter == 2) {
    214                  if(enteringDirection == MOVING_LEFT) {
    215                      if(LockMotors(1, -1)) stateCounter++;
    216                  } else if (enteringDirection == MOVING_RIGHT) {
    217                      if(LockMotors(-1, 1)) stateCounter++;
    218                  }
    219              }
    220          
    221              if (stateCounter == 3) {
    222                  if(Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 300)) stateCounter++;
    223              }
    224          
    225              if (stateCounter == 4) {
    226                  if(LockMotors(-1, -1)) stateCounter++;
    227              }
    228          
    229              else if (stateCounter == 5) {
    230                  ShutoffMotors();
    231                  stateCounter = 0 ;
    232                  state = END;
    233                  stopwatch_seconds = 0;
    234                  cycle_count = 0;
    235                  nextState = END;
    236                  EmitterOff();
    237              }
    238          }
    239          
    240          
    241          // delays for a specified time and then switches state to global nextState
    242          // make sure nextState is set to desired vlaue before the end of delay
    243          int delay(int seconds, int cycles) {
    244              if(stopwatch_seconds == 0 && cycle_count <= 1) {
    245                  display_changed = 1;
    246              }
    247          
    248              if(stopwatch_seconds >= seconds && cycle_count >= cycles) {
    249                  stopwatch_seconds = 0;
    250                  cycle_count = 0;
    251                  return 1;
    252              } else return 0;
    253          }
    254          
    255          
    256          
    257          void StateMachine(void) {
    258              switch(state) {
    259                  case (CALIBRATE):
    260                      calibrate();
    261          
    262                      if(calibrationMode >= 2) {
    263                          state = START;
    264                      }
    265          
    266                      break;
    267          
    268                  case (START):
    269                      strcpy(display_line[0], "WAITING...");
    270                      //display_changed = 1;
    271                      stopwatch_seconds = 0;
    272                      cycle_count = 0;
    273                      break;
    274          
    275                  case (WAIT):
    276                      strcpy(display_line[0], "WAITING...");
    277          
    278                      if (delay(delayTime, 0)) state = nextState;
    279          
    280                      break;
    281          
    282                  case (STRAIGHT):
    283                      Straight();
    284                      break;
    285          
    286                  case (TURN):
    287                      Turn();
    288                      break;
    289          
    290                  case (LINEFOLLOW):
    291                      LineFollow();
    292                      break;
    293          
    294                  case (EXIT):
    295                      Exit();
    296                      break;
    297          
    298                  case (END):
    299                      strcpy(display_line[0], "  STOPPED ");
    300                      display_changed = 1;
    301                      break;
    302          
    303                  default:
    304                      break;
    305              }
    306          }

Errors: 2
Warnings: 2
