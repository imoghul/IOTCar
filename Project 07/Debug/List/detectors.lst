###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          06/Mar/2022  17:23:42
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 07\detectors.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWEFA7.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 07\detectors.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 07\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 07\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 07\Debug\List\detectors.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 07\Debug\Obj\detectors.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 07\detectors.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2
      2          #include "ports.h"
      3          #include "adc.h"
      4          #include "wheels.h"
      5          #include <string.h>
      6          #include "sm.h"
      7          #include "detectors.h"
      8          extern volatile unsigned char display_changed;
      9          extern char display_line[4][11];

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     10          char movingDirection;
   \                     movingDirection:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     11          int rightVals[VALUES_TO_HOLD];
   \                     rightVals:
   \   000000                DS8 8
     12          extern volatile unsigned int ADC_Left_Detect,ADC_Right_Detect;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     13          int lastLeft;
   \                     lastLeft:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     14          int lastRight;
   \                     lastRight:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          int leftVals[VALUES_TO_HOLD];
   \                     leftVals:
   \   000000                DS8 8

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          unsigned int leftBlackVal, rightBlackVal, leftWhiteVal, rightWhiteVal;
   \                     leftBlackVal:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     rightBlackVal:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     leftWhiteVal:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     rightWhiteVal:
   \   000000                DS8 2
     17          extern volatile unsigned int adcUpdated;
     18          extern volatile unsigned int calibratingMode;
     19          

   \                                 In  segment CODE, align 2
     20          void EmitterOn(void){
   \                     EmitterOn:
     21            P6OUT |= IR_LED;
   \   000000   F2D010004302 BIS.B   #0x10, &0x243
     22            //P6OUT |= GRN_LED;
     23            //strcpy(display_line[0], "EMITTER ON");
     24            //display_changed = 1;
     25          }
   \   000006   1001         RETA
   \   000008                REQUIRE _A_PCOUT_L
     26          

   \                                 In  segment CODE, align 2
     27          void EmitterOff(void){
   \                     EmitterOff:
     28            P6OUT &= ~IR_LED;
   \   000000   F2C010004302 BIC.B   #0x10, &0x243
     29            //P6OUT &= ~GRN_LED;
     30            //strcpy(display_line[0], "EMITER OFF");
     31            //strcpy(display_line[2], "          ");
     32            //strcpy(display_line[3], "          ");
     33            //display_changed = 1;
     34          }
   \   000006   1001         RETA
   \   000008                REQUIRE _A_PCOUT_L
     35          

   \                                 In  segment CODE, align 2
     36          void DetectMovement(void){
   \                     DetectMovement:
   \   000000   5B15         PUSHM.W #0x6, R11
     37            if(adcUpdated==0) return;
   \   000002   8293....     CMP.W   #0x0, &adcUpdated
   \   000006   6424         JEQ     ??DetectMovement_0
     38            adcUpdated = 0;
   \   000008   8243....     MOV.W   #0x0, &adcUpdated
     39            int currLeft = ADC_Left_Detect;
   \   00000C   1A42....     MOV.W   &ADC_Left_Detect, R10
     40            int currRight = ADC_Right_Detect;
   \   000010   1B42....     MOV.W   &ADC_Right_Detect, R11
     41            int leftDiff = currLeft-lastLeft;
   \   000014   084A         MOV.W   R10, R8
   \   000016   1882....     SUB.W   &lastLeft, R8
     42            int rightDiff = currRight-lastRight;
   \   00001A   094B         MOV.W   R11, R9
   \   00001C   1982....     SUB.W   &lastRight, R9
     43            lastLeft = currLeft;
   \   000020   824A....     MOV.W   R10, &lastLeft
     44            lastRight = currRight;
   \   000024   824B....     MOV.W   R11, &lastRight
     45            
     46            if(abs(rightDiff)<2) rightDiff = 0;
   \   000028   0C49         MOV.W   R9, R12
   \   00002A   ........     CALLA   #abs
   \   00002E   2C93         CMP.W   #0x2, R12
   \   000030   012C         JC      ??DetectMovement_4
   \   000032   0943         MOV.W   #0x0, R9
     47            if(abs(leftDiff)<2) leftDiff = 0;
   \                     ??DetectMovement_4:
   \   000034   0C48         MOV.W   R8, R12
   \   000036   ........     CALLA   #abs
   \   00003A   2C93         CMP.W   #0x2, R12
   \   00003C   012C         JC      ??DetectMovement_5
   \   00003E   0843         MOV.W   #0x0, R8
     48            
     49            if(leftDiff)push(leftVals,currLeft);
   \                     ??DetectMovement_5:
   \   000040   0893         CMP.W   #0x0, R8
   \   000042   0624         JEQ     ??DetectMovement_6
   \   000044   0D4A         MOV.W   R10, R13
   \   000046   3C40....     MOV.W   #leftVals, R12
   \   00004A   ........     CALLA   #`push`
   \   00004E   043C         JMP     ??DetectMovement_2
     50            else clearList(leftVals);
   \                     ??DetectMovement_6:
   \   000050   3C40....     MOV.W   #leftVals, R12
   \   000054   ........     CALLA   #clearList
     51            if(rightDiff)push(rightVals,currRight);
   \                     ??DetectMovement_2:
   \   000058   0993         CMP.W   #0x0, R9
   \   00005A   0624         JEQ     ??DetectMovement_7
   \   00005C   0D4B         MOV.W   R11, R13
   \   00005E   3C40....     MOV.W   #rightVals, R12
   \   000062   ........     CALLA   #`push`
   \   000066   043C         JMP     ??DetectMovement_3
     52            else clearList(rightVals);
   \                     ??DetectMovement_7:
   \   000068   3C40....     MOV.W   #rightVals, R12
   \   00006C   ........     CALLA   #clearList
     53            
     54            if(validList(rightVals) || validList(leftVals)){
   \                     ??DetectMovement_3:
   \   000070   3C40....     MOV.W   #rightVals, R12
   \   000074   ........     CALLA   #validList
   \   000078   0C93         CMP.W   #0x0, R12
   \   00007A   0620         JNE     ??DetectMovement_8
   \   00007C   3C40....     MOV.W   #leftVals, R12
   \   000080   ........     CALLA   #validList
   \   000084   0C93         CMP.W   #0x0, R12
   \   000086   2124         JEQ     ??DetectMovement_9
     55              char dirR = getDirection(rightVals);
   \                     ??DetectMovement_8:
   \   000088   3C40....     MOV.W   #rightVals, R12
   \   00008C   ........     CALLA   #getDirection
   \   000090   464C         MOV.B   R12, R6
     56              char dirL= getDirection(leftVals);
   \   000092   3C40....     MOV.W   #leftVals, R12
   \   000096   ........     CALLA   #getDirection
     57              
     58              if(dirR==INCREASING || dirL==DECREASING) movingDirection = MOVING_RIGHT;
   \   00009A   76904900     CMP.B   #0x49, R6
   \   00009E   0324         JEQ     ??DetectMovement_10
   \   0000A0   7C904400     CMP.B   #0x44, R12
   \   0000A4   0420         JNE     ??DetectMovement_11
   \                     ??DetectMovement_10:
   \   0000A6   F2405200.... MOV.B   #0x52, &movingDirection
   \   0000AC   113C         JMP     ??DetectMovement_0
     59              else if(dirR==DECREASING || dirL==INCREASING) movingDirection = MOVING_LEFT;
   \                     ??DetectMovement_11:
   \   0000AE   76904400     CMP.B   #0x44, R6
   \   0000B2   0324         JEQ     ??DetectMovement_12
   \   0000B4   7C904900     CMP.B   #0x49, R12
   \   0000B8   0420         JNE     ??DetectMovement_13
   \                     ??DetectMovement_12:
   \   0000BA   F2404C00.... MOV.B   #0x4c, &movingDirection
   \   0000C0   073C         JMP     ??DetectMovement_0
     60              else movingDirection = NOT_MOVING;
   \                     ??DetectMovement_13:
   \   0000C2   F2404E00.... MOV.B   #0x4e, &movingDirection
   \   0000C8   033C         JMP     ??DetectMovement_0
     61            }
     62            else movingDirection = NOT_MOVING;
   \                     ??DetectMovement_9:
   \   0000CA   F2404E00.... MOV.B   #0x4e, &movingDirection
     63          }
   \                     ??DetectMovement_0:
   \   0000D0   5617         POPM.W  #0x6, R11
   \   0000D2   1001         RETA
     64          

   \                                 In  segment CODE, align 2
     65          void push(int list[], int val){
   \                     `push`:
   \   000000   1B15         PUSHM.W #0x2, R11
     66            for(int i = VALUES_TO_HOLD-1;i>0;--i) list[i] = list[i-1];
   \   000002   3A400300     MOV.W   #0x3, R10
   \                     ??push_0:
   \   000006   1A93         CMP.W   #0x1, R10
   \   000008   0D38         JL      ??push_1
   \   00000A   0F4A         MOV.W   R10, R15
   \   00000C   0F5F         RLA.W   R15
   \   00000E   0B4C         MOV.W   R12, R11
   \   000010   0B5F         ADD.W   R15, R11
   \   000012   0E4A         MOV.W   R10, R14
   \   000014   0E5E         RLA.W   R14
   \   000016   0F4C         MOV.W   R12, R15
   \   000018   0F5E         ADD.W   R14, R15
   \   00001A   9F4BFEFF0000 MOV.W   0xfffe(R11), 0(R15)
   \   000020   3A53         ADD.W   #0xffff, R10
   \   000022   F13F         JMP     ??push_0
     67            list[0] = val;
   \                     ??push_1:
   \   000024   8C4D0000     MOV.W   R13, 0(R12)
     68          }
   \   000028   1A17         POPM.W  #0x2, R11
   \   00002A   1001         RETA
     69          

   \                                 In  segment CODE, align 2
     70          void clearList(int list[]){
   \                     clearList:
     71            for (int i = 0;list[i]!=0;++i) list[i]=0;
   \   000000   0D43         MOV.W   #0x0, R13
   \                     ??clearList_0:
   \   000002   0F4D         MOV.W   R13, R15
   \   000004   0F5F         RLA.W   R15
   \   000006   0E4C         MOV.W   R12, R14
   \   000008   0E5F         ADD.W   R15, R14
   \   00000A   8E930000     CMP.W   #0x0, 0(R14)
   \   00000E   0824         JEQ     ??clearList_1
   \   000010   0E4D         MOV.W   R13, R14
   \   000012   0E5E         RLA.W   R14
   \   000014   0F4C         MOV.W   R12, R15
   \   000016   0F5E         ADD.W   R14, R15
   \   000018   8F430000     MOV.W   #0x0, 0(R15)
   \   00001C   1D53         ADD.W   #0x1, R13
   \   00001E   F13F         JMP     ??clearList_0
     72          }
   \                     ??clearList_1:
   \   000020   1001         RETA
     73          

   \                                 In  segment CODE, align 2
     74          int validList(int* list){
   \                     validList:
   \   000000   0E4C         MOV.W   R12, R14
     75            for(int i = 0;i<VALUES_TO_HOLD;++i) if(list[i]==0)return 0;
   \   000002   0D43         MOV.W   #0x0, R13
   \                     ??validList_0:
   \   000004   2D92         CMP.W   #0x4, R13
   \   000006   0B34         JGE     ??validList_1
   \   000008   0F4D         MOV.W   R13, R15
   \   00000A   0F5F         RLA.W   R15
   \   00000C   0C4E         MOV.W   R14, R12
   \   00000E   0C5F         ADD.W   R15, R12
   \   000010   8C930000     CMP.W   #0x0, 0(R12)
   \   000014   0220         JNE     ??validList_2
   \   000016   0C43         MOV.W   #0x0, R12
   \   000018   1001         RETA
   \                     ??validList_2:
   \   00001A   1D53         ADD.W   #0x1, R13
   \   00001C   F33F         JMP     ??validList_0
     76            return 1;
   \                     ??validList_1:
   \   00001E   1C43         MOV.W   #0x1, R12
   \   000020   1001         RETA
     77          }
     78          

   \                                 In  segment CODE, align 2
     79          int rollingSum(int * list){
   \                     rollingSum:
   \   000000   0A12         PUSH.W  R10
   \   000002   0D4C         MOV.W   R12, R13
     80            int sum = 0;
   \   000004   0C43         MOV.W   #0x0, R12
     81            for (int i = 0;i<VALUES_TO_HOLD;++i){
   \   000006   0A43         MOV.W   #0x0, R10
   \                     ??rollingSum_0:
   \   000008   2A92         CMP.W   #0x4, R10
   \   00000A   0734         JGE     ??rollingSum_1
     82              sum+=list[i];
   \   00000C   0E4A         MOV.W   R10, R14
   \   00000E   0E5E         RLA.W   R14
   \   000010   0F4D         MOV.W   R13, R15
   \   000012   0F5E         ADD.W   R14, R15
   \   000014   2C5F         ADD.W   @R15, R12
     83            }
   \   000016   1A53         ADD.W   #0x1, R10
   \   000018   F73F         JMP     ??rollingSum_0
     84            return sum;
   \                     ??rollingSum_1:
   \   00001A   3A41         POP.W   R10
   \   00001C   1001         RETA
     85          }
     86          

   \                                 In  segment CODE, align 2
     87          char getDirection(int* list){
   \                     getDirection:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
     88            int increasing = 0,decreasing = 0;
   \   000004   0B43         MOV.W   #0x0, R11
   \   000006   0843         MOV.W   #0x0, R8
     89            for(int i = 1;i<VALUES_TO_HOLD && list[i]!=0;++i){
   \   000008   1943         MOV.W   #0x1, R9
   \                     ??getDirection_0:
   \   00000A   2992         CMP.W   #0x4, R9
   \   00000C   2634         JGE     ??getDirection_3
   \   00000E   0F49         MOV.W   R9, R15
   \   000010   0F5F         RLA.W   R15
   \   000012   0E4A         MOV.W   R10, R14
   \   000014   0E5F         ADD.W   R15, R14
   \   000016   8E930000     CMP.W   #0x0, 0(R14)
   \   00001A   1F24         JEQ     ??getDirection_3
     90              if(abs(list[i]-list[i-1])>0){
   \   00001C   0E49         MOV.W   R9, R14
   \   00001E   0E5E         RLA.W   R14
   \   000020   0F4A         MOV.W   R10, R15
   \   000022   0F5E         ADD.W   R14, R15
   \   000024   2C4F         MOV.W   @R15, R12
   \   000026   0F49         MOV.W   R9, R15
   \   000028   0F5F         RLA.W   R15
   \   00002A   0E4A         MOV.W   R10, R14
   \   00002C   0E5F         ADD.W   R15, R14
   \   00002E   1C8EFEFF     SUB.W   0xfffe(R14), R12
   \   000032   ........     CALLA   #abs
   \   000036   0C93         CMP.W   #0x0, R12
   \   000038   0E24         JEQ     ??getDirection_1
     91                if(list[i]>list[i-1]) decreasing++;
   \   00003A   0F49         MOV.W   R9, R15
   \   00003C   0F5F         RLA.W   R15
   \   00003E   0D4A         MOV.W   R10, R13
   \   000040   0D5F         ADD.W   R15, R13
   \   000042   0E49         MOV.W   R9, R14
   \   000044   0E5E         RLA.W   R14
   \   000046   0F4A         MOV.W   R10, R15
   \   000048   0F5E         ADD.W   R14, R15
   \   00004A   AD9FFEFF     CMP.W   @R15, 0xfffe(R13)
   \   00004E   0234         JGE     ??getDirection_4
   \   000050   1853         ADD.W   #0x1, R8
   \   000052   013C         JMP     ??getDirection_1
     92                else increasing++;
   \                     ??getDirection_4:
   \   000054   1B53         ADD.W   #0x1, R11
     93              }
     94            }
   \                     ??getDirection_1:
   \   000056   1953         ADD.W   #0x1, R9
   \   000058   D83F         JMP     ??getDirection_0
     95            return increasing>decreasing?INCREASING:(increasing==decreasing?NEUTRAL:DECREASING);
   \                     ??getDirection_3:
   \   00005A   089B         CMP.W   R11, R8
   \   00005C   0334         JGE     ??getDirection_5
   \   00005E   7C404900     MOV.B   #0x49, R12
   \   000062   073C         JMP     ??getDirection_2
   \                     ??getDirection_5:
   \   000064   0B98         CMP.W   R8, R11
   \   000066   0320         JNE     ??getDirection_6
   \   000068   7C406E00     MOV.B   #0x6e, R12
   \   00006C   023C         JMP     ??getDirection_2
   \                     ??getDirection_6:
   \   00006E   7C404400     MOV.B   #0x44, R12
   \                     ??getDirection_2:
   \   000072   3817         POPM.W  #0x4, R11
   \   000074   1001         RETA
     96          }
     97          

   \                                 In  segment CODE, align 2
     98          unsigned int abs(int n){
   \                     abs:
   \   000000   B1000400     SUBA    #0x4, SP
     99            const int ret[2] = {n,-n};
   \   000004   814C0000     MOV.W   R12, 0(SP)
   \   000008   0F4C         MOV.W   R12, R15
   \   00000A   3FE3         XOR.W   #0xffff, R15
   \   00000C   1F53         ADD.W   #0x1, R15
   \   00000E   814F0200     MOV.W   R15, 0x2(SP)
    100            return (unsigned int)(ret [n<0]);
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   0234         JGE     ??abs_1
   \   000016   5F43         MOV.B   #0x1, R15
   \   000018   013C         JMP     ??abs_0
   \                     ??abs_1:
   \   00001A   4F43         MOV.B   #0x0, R15
   \                     ??abs_0:
   \   00001C   4F4F         MOV.B   R15, R15
   \   00001E   0F5F         RLA.W   R15
   \   000020   0F51         ADD.W   SP, R15
   \   000022   2C4F         MOV.W   @R15, R12
   \   000024   A1000400     ADDA    #0x4, SP
   \   000028   1001         RETA
    101          }

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     16   DetectMovement
       16   -> abs
       16   -> clearList
       16   -> getDirection
       16   -> push
       16   -> validList
      4   EmitterOff
      4   EmitterOn
      8   abs
      4   clearList
     12   getDirection
       12   -> abs
      8   push
      6   rollingSum
      4   validList


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     212  DetectMovement
       8  EmitterOff
       8  EmitterOn
       2  _A_PCOUT_L
      42  abs
      34  clearList
     118  getDirection
       2  lastLeft
       2  lastRight
       2  leftBlackVal
       8  leftVals
       2  leftWhiteVal
       1  movingDirection
      44  push
       2  rightBlackVal
       8  rightVals
       2  rightWhiteVal
      30  rollingSum
      34  validList

 
 530 bytes in segment CODE
   2 bytes in segment DATA16_AN
  29 bytes in segment DATA16_Z
 
 530 bytes of CODE memory
  29 bytes of DATA memory (+ 2 bytes shared)

Errors: none
Warnings: none
