###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          17/Apr/2022  16:57:11
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 10\sm.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EW3CB6.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 10\sm.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj" --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -Ohz --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\List\sm.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj\sm.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 10\sm.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2
      2          #include "ports.h"
      3          #include "wheels.h"
      4          #include "sm.h"
      5          #include <string.h>
      6          #include "adc.h"
      7          #include "timers.h"
      8          #include "detectors.h"
      9          #include "pid.h"
     10          
     11          extern volatile unsigned int cycle_count;
     12          extern volatile unsigned int stopwatch_milliseconds;
     13          extern volatile unsigned int stopwatch_seconds;
     14          extern volatile unsigned char display_changed;
     15          extern char display_line[4][11];
     16          extern volatile unsigned int wheel_periods;

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     17          volatile char state = START;//CALIBRATE;
   \                     state:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for state>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile int stateCounter;
   \                     stateCounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     19          volatile char nextState = STRAIGHT;
   \                     nextState:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for nextState>`
     20          extern volatile unsigned int Time_Sequence;
     21          extern volatile unsigned int Last_Time_Sequence;
     22          extern volatile unsigned int time_change;

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     23          volatile unsigned int delayTime = 1;
   \                     delayTime:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for delayTime>`
     24          extern volatile unsigned int ADC_Left_Detect, ADC_Right_Detect;
     25          extern volatile unsigned int rightSwitchable, leftSwitchable;
     26          extern unsigned int temp;
     27          extern char movingDirection;

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     28          char enteringDirection = NOT_MOVING;
   \                     enteringDirection:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for enteringDirection>`
     29          extern int leftVals[VALUES_TO_HOLD];
     30          extern int rightVals[VALUES_TO_HOLD];
     31          extern volatile unsigned int calibrationMode;
     32          extern unsigned int LBDetect, LWDetect, RBDetect, RWDetect;
     33          extern PIDController rightFollowController, rightAdjustController;
     34          extern PIDController leftFollowController, leftAdjustController;
     35          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     36          int polarityRight, polarityLeft;
   \                     polarityRight:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     polarityLeft:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     37          unsigned int driveTime;
   \                     driveTime:
   \   000000                DS8 2
     38          
     39          

   \                                 In  segment CODE, align 2
     40          void Straight(char direction) {
   \                     Straight:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4E4C         MOV.B   R12, R14
     41            int rightTurn = direction?STRAIGHT_RIGHT:-STRAIGHT_RIGHT;
   \   000004   3C40204E     MOV.W   #0x4e20, R12
   \   000008   3D40803E     MOV.W   #0x3e80, R13
   \   00000C   4E93         CMP.B   #0x0, R14
   \   00000E   0420         JNE     ??Straight_18
   \   000010   3A40E0B1     MOV.W   #0xb1e0, R10
   \   000014   0F4D         MOV.W   R13, R15
   \   000016   033C         JMP     ??Straight_15
   \                     ??Straight_18:
   \   000018   0A4C         MOV.W   R12, R10
   \   00001A   3F4080C1     MOV.W   #0xc180, R15
     42            int leftTurn = direction?-STRAIGHT_LEFT:STRAIGHT_LEFT;
     43              switch(stateCounter) {
   \                     ??Straight_15:
   \   00001E   1842....     MOV.W   &RWDetect, R8
   \   000022   2853         ADD.W   #0x2, R8
   \   000024   1942....     MOV.W   &LWDetect, R9
   \   000028   2953         ADD.W   #0x2, R9
   \   00002A   0B4A         MOV.W   R10, R11
   \   00002C   3BE3         XOR.W   #0xffff, R11
   \   00002E   1B53         ADD.W   #0x1, R11
   \   000030   0E4F         MOV.W   R15, R14
   \   000032   3EE3         XOR.W   #0xffff, R14
   \   000034   1E53         ADD.W   #0x1, R14
   \   000036   1642....     MOV.W   &stateCounter, R6
   \   00003A   0683         SUB.W   #0x0, R6
   \   00003C   1924         JEQ     ??Straight_19
   \   00003E   1683         SUB.W   #0x1, R6
   \   000040   1A24         JEQ     ??Straight_14
   \   000042   1683         SUB.W   #0x1, R6
   \   000044   3A24         JEQ     ??Straight_0
   \   000046   1683         SUB.W   #0x1, R6
   \   000048   1924         JEQ     ??Straight_8
   \   00004A   1683         SUB.W   #0x1, R6
   \   00004C   1E24         JEQ     ??Straight_10
   \   00004E   1683         SUB.W   #0x1, R6
   \   000050   1224         JEQ     ??Straight_14
   \   000052   1683         SUB.W   #0x1, R6
   \   000054   3224         JEQ     ??Straight_0
   \   000056   1683         SUB.W   #0x1, R6
   \   000058   1124         JEQ     ??Straight_8
   \   00005A   1683         SUB.W   #0x1, R6
   \   00005C   1624         JEQ     ??Straight_10
   \   00005E   1683         SUB.W   #0x1, R6
   \   000060   1724         JEQ     ??Straight_20
   \   000062   1683         SUB.W   #0x1, R6
   \   000064   1D24         JEQ     ??Straight_21
   \   000066   1683         SUB.W   #0x1, R6
   \   000068   2824         JEQ     ??Straight_0
   \   00006A   1683         SUB.W   #0x1, R6
   \   00006C   2F24         JEQ     ??Straight_22
   \   00006E   3A3C         JMP     ??Straight_16
     44                  case 0:
     45                      EMITTER_ON;
   \                     ??Straight_19:
   \   000070   ........     CALLA   #?Subroutine1
     46                      stateCounter = 1;
     47                      strcpy(display_line[0], "          ");
     48                      display_changed = 1;
     49                      break;
   \                     ??CrossCallReturnLabel_10:
   \   000074   373C         JMP     ??Straight_16
     50          
     51                  case 1:
     52                      if(Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG1)) stateCounter++; // straight
     53                      break;
     54                      
     55                  case 2:
     56                      if(LockMotors(-1, -1)) stateCounter++;
     57                      break;
     58                      
     59                  case 3:
     60                    if(Drive_Path(rightTurn, leftTurn, TURN90)) stateCounter++;  // turn
     61                    break;
     62                  
     63                  case 4:
     64                      if(LockMotors(-rightTurn, -leftTurn)) stateCounter++;
     65                      break;
     66                      
     67                  case 5:
     68                      if(Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG2)) stateCounter++;// straight
   \                     ??Straight_14:
   \   000076   3E40D007     MOV.W   #0x7d0, R14
   \   00007A   043C         JMP     ??Straight_9
     69                      break;
     70                      
     71                  case 6:
     72                      if(LockMotors(-1, -1)) stateCounter++;
     73                      break;
     74                      
     75                  case 7:
     76                      if(Drive_Path(rightTurn, leftTurn, TURN90)) stateCounter++; // turn
   \                     ??Straight_8:
   \   00007C   3E402602     MOV.W   #0x226, R14
   \   000080   0D4F         MOV.W   R15, R13
   \   000082   0C4A         MOV.W   R10, R12
   \                     ??Straight_9:
   \   000084   ........     CALLA   #Drive_Path
   \   000088   1C3C         JMP     ??Straight_2
     77                      break;
     78                  case 8:
     79                      if(LockMotors(-rightTurn, -leftTurn)) stateCounter++;
   \                     ??Straight_10:
   \   00008A   0D4E         MOV.W   R14, R13
   \   00008C   0C4B         MOV.W   R11, R12
   \   00008E   173C         JMP     ??Straight_1
     80                      break;
     81                      
     82                  case 9:
     83                      if ((ADC_Left_Detect > LEFT_WHITE_DETECT || ADC_Right_Detect > RIGHT_WHITE_DETECT)) {
   \                     ??Straight_20:
   \   000090   1992....     CMP.W   &ADC_Left_Detect, R9
   \   000094   0328         JNC     ??Straight_23
   \   000096   1892....     CMP.W   &ADC_Right_Detect, R8
   \   00009A   152C         JC      ??Straight_3
     84                          Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 0);
   \                     ??Straight_23:
   \   00009C   0E43         MOV.W   #0x0, R14
   \   00009E   0A3C         JMP     ??Straight_17
     85                      }
     86                      else stateCounter++;
     87          
     88                      break;
     89                      
     90                  case 10:
     91                      if ((ADC_Left_Detect < LEFT_WHITE_DETECT || ADC_Right_Detect < RIGHT_WHITE_DETECT)) {
   \                     ??Straight_21:
   \   0000A0   8299....     CMP.W   R9, &ADC_Left_Detect
   \   0000A4   0328         JNC     ??Straight_24
   \   0000A6   8298....     CMP.W   R8, &ADC_Right_Detect
   \   0000AA   0D2C         JC      ??Straight_3
     92                          Drive_Path(RIGHT_MIN, RIGHT_MIN, 0);
   \                     ??Straight_24:
   \   0000AC   0E43         MOV.W   #0x0, R14
   \   0000AE   3D403421     MOV.W   #0x2134, R13
   \   0000B2   0C4D         MOV.W   R13, R12
   \                     ??Straight_17:
   \   0000B4   ........     CALLA   #Drive_Path
   \   0000B8   153C         JMP     ??Straight_16
     93                      }
     94                      else stateCounter++;
     95          
     96                      break;
     97          
     98                  case 11:
     99                      if(LockMotors(-1, -1)) stateCounter++;
   \                     ??Straight_0:
   \   0000BA   3D43         MOV.W   #0xffff, R13
   \   0000BC   3C43         MOV.W   #0xffff, R12
   \                     ??Straight_1:
   \   0000BE   ........     CALLA   #LockMotors
   \                     ??Straight_2:
   \   0000C2   0C93         CMP.W   #0x0, R12
   \   0000C4   0F24         JEQ     ??Straight_16
   \                     ??Straight_3:
   \   0000C6   9253....     ADD.W   #0x1, &stateCounter
   \   0000CA   0C3C         JMP     ??Straight_16
    100          
    101                      break;
    102          
    103                  case 12:
    104                      stateCounter = 0 ;
   \                     ??Straight_22:
   \   0000CC   ........     CALLA   #?Subroutine2
    105                      stopwatch_seconds = 0;
    106                      cycle_count = 0;
    107                      state = WAIT;
    108                      nextState = TURN;
   \                     ??CrossCallReturnLabel_0:
   \   0000D0   F2405400.... MOV.B   #0x54, &nextState
    109                      strcpy(display_line[0],"INTERCEPT ");
   \   0000D6   3D40....     MOV.W   #`?<Constant "INTERCEPT ">`, R13
   \   0000DA   ........     CALLA   #?Subroutine9
    110                      display_changed = 1;
    111                      EMITTER_OFF;
   \                     ??CrossCallReturnLabel_11:
   \   0000DE   F2C010004302 BIC.B   #0x10, &0x243
    112                      break;
    113              }
    114          }
   \                     ??Straight_16:
   \   0000E4   5617         POPM.W  #0x6, R11
   \   0000E6   1001         RETA
   \   0000E8                REQUIRE _A_PCOUT_L

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   F2D010004302 BIS.B   #0x10, &0x243
   \   000006   9243....     MOV.W   #0x1, &stateCounter
   \   00000A                REQUIRE ??Subroutine10_0
   \   00000A                // Fall through to label ??Subroutine10_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   3D40....     MOV.W   #`?<Constant "          ">`, R13
   \   000004   ....         JMP     ?Subroutine9

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   3C40....     MOV.W   #display_line, R12
   \   000004   ........     CALLA   #strcpy
   \   000008   D243....     MOV.B   #0x1, &display_changed
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   8243....     MOV.W   #0x0, &stateCounter
   \   000004   8243....     MOV.W   #0x0, &stopwatch_seconds
   \   000008   8243....     MOV.W   #0x0, &cycle_count
   \   00000C   F2405700.... MOV.B   #0x57, &state
   \   000012   1001         RETA
    115          

   \                                 In  segment CODE, align 2, keep-with-next
    116          void Turn(char direction) {
   \                     Turn:
    117              switch(stateCounter) {
   \   000000   1F42....     MOV.W   &stateCounter, R15
   \   000004   0F83         SUB.W   #0x0, R15
   \   000006   0724         JEQ     ??Turn_1
   \   000008   1F83         SUB.W   #0x1, R15
   \   00000A   0624         JEQ     ??Turn_2
   \   00000C   1F83         SUB.W   #0x1, R15
   \   00000E   1624         JEQ     ??Turn_3
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   3024         JEQ     ??Turn_4
   \   000014   1001         RETA
    118                  case 0:
    119                      EMITTER_ON;
   \                     ??Turn_1:
   \   000016   ....         JMP     ?Subroutine1
    120                      stateCounter = 1;
    121                      strcpy(display_line[0], "          ");
    122                      display_changed = 1;
    123                      break;
    124          
    125                  case 1: // gotta remove this
    126                    if(direction){
   \                     ??Turn_2:
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   3E406400     MOV.W   #0x64, R14
   \   00001E   0524         JEQ     ??Turn_5
    127                          if(Drive_Path(-RIGHT_MAX, LEFT_MAX, PRELIMINARY_TURN)) stateCounter++;
   \   000020   3D40204E     MOV.W   #0x4e20, R13
   \   000024   3C40E0B1     MOV.W   #0xb1e0, R12
   \   000028   043C         JMP     ??Turn_0
    128                    }else/* if(direction == MOVING_RIGHT)*/
    129                              if(Drive_Path(RIGHT_MAX, -LEFT_MAX, PRELIMINARY_TURN)) stateCounter++;
   \                     ??Turn_5:
   \   00002A   3D40E0B1     MOV.W   #0xb1e0, R13
   \   00002E   3C40204E     MOV.W   #0x4e20, R12
   \                     ??Turn_0:
   \   000032   ........     CALLA   #Drive_Path
   \   000036   0C93         CMP.W   #0x0, R12
   \   000038   2B24         JEQ     ??Turn_6
   \   00003A   ....         JMP     ?Subroutine0
    130          
    131                      break;
    132          
    133                  case 2:
    134                      if (((ADC_Left_Detect < LEFT_WHITE_DETECT || ADC_Right_Detect < RIGHT_WHITE_DETECT))) {
   \                     ??Turn_3:
   \   00003C   1F42....     MOV.W   &LWDetect, R15
   \   000040   2F53         ADD.W   #0x2, R15
   \   000042   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000046   0628         JNC     ??Turn_7
   \   000048   1F42....     MOV.W   &RWDetect, R15
   \   00004C   2F53         ADD.W   #0x2, R15
   \   00004E   829F....     CMP.W   R15, &ADC_Right_Detect
   \   000052   0F2C         JC      ??Turn_8
    135                          if(direction)Drive_Path(-RIGHT_MIN, LEFT_MIN, 0);
   \                     ??Turn_7:
   \   000054   4C93         CMP.B   #0x0, R12
   \   000056   0E43         MOV.W   #0x0, R14
   \   000058   0624         JEQ     ??Turn_9
   \   00005A   3D403421     MOV.W   #0x2134, R13
   \   00005E   3C40CCDE     MOV.W   #0xdecc, R12
   \   000062   ........     BRA     #Drive_Path
    136          
    137                          else Drive_Path(RIGHT_MIN, -LEFT_MIN, 0);
   \                     ??Turn_9:
   \   000066   3D40CCDE     MOV.W   #0xdecc, R13
   \   00006A   3C403421     MOV.W   #0x2134, R12
   \   00006E   ........     BRA     #Drive_Path
    138                      } else stateCounter++;
   \                     ??Turn_8:
   \   000072   ....         JMP     ?Subroutine0
    139          
    140                      break;
    141          
    142                  case 3:
    143                      ShutoffMotors();
   \                     ??Turn_4:
   \   000074   ........     CALLA   #ShutoffMotors
    144                      stateCounter = 0 ;
   \   000078   ........     CALLA   #?Subroutine2
    145                      stopwatch_seconds = 0;
    146                      cycle_count = 0;
    147                      state = WAIT;
    148                      nextState = LINEFOLLOW;
   \                     ??CrossCallReturnLabel_1:
   \   00007C   F2404C00.... MOV.B   #0x4c, &nextState
    149                      EMITTER_OFF;
   \   000082   F2C010004302 BIC.B   #0x10, &0x243
    150                      strcpy(display_line[0],"   TURN   ");
   \   000088   3D40....     MOV.W   #`?<Constant "   TURN   ">`, R13
   \   00008C   ........     CALLA   #?Subroutine9
    151                      display_changed = 1;
    152                      break;
    153              }
    154          }
   \                     ??Turn_6:
   \   000090   1001         RETA
   \   000092                REQUIRE _A_PCOUT_L

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   9253....     ADD.W   #0x1, &stateCounter
   \   000004   1001         RETA
    155          

   \                                 In  segment CODE, align 2, keep-with-next
    156          void LineFollow(char direction) {
   \                     LineFollow:
   \   000000   1B15         PUSHM.W #0x2, R11
    157              //HEXtoBCD(ADC_Left_Detect, 1, 6);
    158              //HEXtoBCD(ADC_Right_Detect, 1, 0);
    159              
    160              int rFollowSpeed,lFollowSpeed;
    161          
    162              //rFollowSpeed = RIGHT_MIN>>1;
    163              //lFollowSpeed = LEFT_MIN>>1;
    164              
    165              /*if(ADC_Left_Detect>LEFT_GRAY_DETECT)rFollowSpeed = 3000;
    166              else*/ rFollowSpeed = direction?additionSafe(RIGHT_FORWARD_SPEED, RIGHT_MAX, 4000, GetOutput(&leftFollowController, LEFT_BLACK_DETECT, ADC_Left_Detect)):RIGHT_MIN>>1; // swapped b/c they are physically swapped
                            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   000002   4C93         CMP.B   #0x0, R12
   \   000004   1120         JNE     ??LineFollow_14
   \   000006   3A409A10     MOV.W   #0x109a, R10
   \   00000A   1E42....     MOV.W   &ADC_Right_Detect, R14
   \   00000E   1D42....     MOV.W   &RBDetect, R13
   \   000012   2D83         SUB.W   #0x2, R13
   \   000014   3C40....     MOV.W   #rightFollowController, R12
   \   000018   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_7:
   \   00001C   1C425604     MOV.W   &0x456, R12
   \   000020   ........     CALLA   #additionSafe
   \   000024   0B4C         MOV.W   R12, R11
   \   000026   103C         JMP     ??LineFollow_11
   \                     ??LineFollow_14:
   \   000028   1E42....     MOV.W   &ADC_Left_Detect, R14
   \   00002C   1D42....     MOV.W   &LBDetect, R13
   \   000030   2D83         SUB.W   #0x2, R13
   \   000032   3C40....     MOV.W   #leftFollowController, R12
   \   000036   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_8:
   \   00003A   1C425404     MOV.W   &0x454, R12
   \   00003E   ........     CALLA   #additionSafe
   \   000042   0A4C         MOV.W   R12, R10
   \   000044   3B409A10     MOV.W   #0x109a, R11
    167              /*if(ADC_Right_Detect>RIGHT_GRAY_DETECT)lFollowSpeed = 3000;
    168              else*/ lFollowSpeed = direction?LEFT_MIN>>1:additionSafe(LEFT_FORWARD_SPEED, LEFT_MAX, 4000, GetOutput(&rightFollowController, RIGHT_BLACK_DETECT, ADC_Right_Detect));// swapped b/c they are physically swapped
                            ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
    169              
    170              switch(stateCounter) {
   \                     ??LineFollow_11:
   \   000048   1F42....     MOV.W   &LWDetect, R15
   \   00004C   2F53         ADD.W   #0x2, R15
   \   00004E   1E42....     MOV.W   &RWDetect, R14
   \   000052   2E53         ADD.W   #0x2, R14
   \   000054   1D42....     MOV.W   &stateCounter, R13
   \   000058   0D83         SUB.W   #0x0, R13
   \   00005A   0B24         JEQ     ??LineFollow_15
   \   00005C   1D83         SUB.W   #0x1, R13
   \   00005E   1924         JEQ     ??LineFollow_16
   \   000060   1D83         SUB.W   #0x1, R13
   \   000062   4C24         JEQ     ??LineFollow_17
   \   000064   1D83         SUB.W   #0x1, R13
   \   000066   5724         JEQ     ??LineFollow_18
   \   000068   1D83         SUB.W   #0x1, R13
   \   00006A   6924         JEQ     ??LineFollow_19
   \   00006C   1D83         SUB.W   #0x1, R13
   \   00006E   8624         JEQ     ??LineFollow_20
   \   000070   8E3C         JMP     ??LineFollow_12
    171                  case 0:
    172                      EMITTER_ON;
   \                     ??LineFollow_15:
   \   000072   F2D010004302 BIS.B   #0x10, &0x243
    173                      stopwatch_seconds = 0;
   \   000078   ........     CALLA   #?Subroutine7
    174                      cycle_count = 0;
    175                      strcpy(display_line[0],"          ");
   \                     ??CrossCallReturnLabel_5:
   \   00007C   ........     CALLA   #??Subroutine10_0
    176                      display_changed = 1;
    177                      if(rightSwitchable && leftSwitchable)stateCounter++;
   \                     ??CrossCallReturnLabel_9:
   \   000080   8293....     CMP.W   #0x0, &rightSwitchable
   \   000084   9024         JEQ     ??LineFollow_1
   \   000086   8293....     CMP.W   #0x0, &leftSwitchable
   \   00008A   8D24         JEQ     ??LineFollow_1
   \   00008C   9253....     ADD.W   #0x1, &stateCounter
    178                      else return;
    179          
    180                      break;
   \   000090   7E3C         JMP     ??LineFollow_12
    181          
    182                  case 1:
    183                      if(ADC_Left_Detect < (LEFT_WHITE_DETECT) ^ ADC_Right_Detect < (RIGHT_WHITE_DETECT)) stateCounter = 2;
                             ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \                     ??LineFollow_16:
   \   000092   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000096   4D7D         SUBC.B  R13, R13
   \   000098   5DF3         AND.B   #0x1, R13
   \   00009A   829E....     CMP.W   R14, &ADC_Right_Detect
   \   00009E   012C         JC      ??LineFollow_0
   \   0000A0   5DE3         XOR.B   #0x1, R13
   \                     ??LineFollow_0:
   \   0000A2   4D93         CMP.B   #0x0, R13
   \   0000A4   0324         JEQ     ??LineFollow_21
   \   0000A6   A243....     MOV.W   #0x2, &stateCounter
   \   0000AA   123C         JMP     ??LineFollow_13
    184                      else if (ADC_Left_Detect < (LEFT_WHITE_DETECT) && ADC_Right_Detect < (RIGHT_WHITE_DETECT)) {
   \                     ??LineFollow_21:
   \   0000AC   829F....     CMP.W   R15, &ADC_Left_Detect
   \   0000B0   072C         JC      ??LineFollow_22
   \   0000B2   829E....     CMP.W   R14, &ADC_Right_Detect
   \   0000B6   042C         JC      ??LineFollow_22
    185                          rFollowSpeed = -RIGHT_MIN;
   \   0000B8   3A40CCDE     MOV.W   #0xdecc, R10
    186                          lFollowSpeed = -LEFT_MIN;
   \   0000BC   0B4A         MOV.W   R10, R11
   \   0000BE   083C         JMP     ??LineFollow_13
    187                      } else {
    188                          ClearController(&rightFollowController);
   \                     ??LineFollow_22:
   \   0000C0   3C40....     MOV.W   #rightFollowController, R12
   \   0000C4   ........     CALLA   #ClearController
    189                          ClearController(&leftFollowController);
   \   0000C8   3C40....     MOV.W   #leftFollowController, R12
   \   0000CC   ........     CALLA   #ClearController
    190                      }
    191          
    192                      if(delay(CIRCLING_TIME, 0))  stateCounter = 5;
   \                     ??LineFollow_13:
   \   0000D0   0D43         MOV.W   #0x0, R13
   \   0000D2   3C404600     MOV.W   #0x46, R12
   \   0000D6   ........     CALLA   #delay
   \   0000DA   0C93         CMP.W   #0x0, R12
   \   0000DC   0324         JEQ     ??LineFollow_23
   \   0000DE   B2400500.... MOV.W   #0x5, &stateCounter
    193                      if(stopwatch_seconds>=TIME_TO_CIRCLE) strcpy(display_line[0]," CIRCLING ");
   \                     ??LineFollow_23:
   \   0000E4   B2900300.... CMP.W   #0x3, &stopwatch_seconds
   \   0000EA   0428         JNC     ??LineFollow_24
   \   0000EC   3D40....     MOV.W   #`?<Constant " CIRCLING ">`, R13
   \   0000F0   ........     CALLA   #?Subroutine5
    194          
    195                      Drive_Path(rFollowSpeed, lFollowSpeed,0);
   \                     ??LineFollow_24:
   \   0000F4   0E43         MOV.W   #0x0, R14
   \   0000F6   0D4B         MOV.W   R11, R13
   \   0000F8   0C4A         MOV.W   R10, R12
   \   0000FA   293C         JMP     ??LineFollow_3
    196                      break;
    197          
    198          
    199                  case 2:
    200                      if(ADC_Left_Detect < LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 3;
   \                     ??LineFollow_17:
   \   0000FC   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000100   032C         JC      ??LineFollow_25
   \   000102   829E....     CMP.W   R14, &ADC_Right_Detect
   \   000106   362C         JC      ??LineFollow_26
    201                      else if(ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect < RIGHT_WHITE_DETECT) stateCounter = 4;
   \                     ??LineFollow_25:
   \   000108   829F....     CMP.W   R15, &ADC_Left_Detect
   \   00010C   3028         JNC     ??LineFollow_27
   \   00010E   829E....     CMP.W   R14, &ADC_Right_Detect
   \   000112   1028         JNC     ??LineFollow_9
   \   000114   283C         JMP     ??LineFollow_7
    202                      else stateCounter = 1;
    203          
    204                      break;
    205          
    206                  case 3:// turn left ()
    207                      if(ADC_Left_Detect < LEFT_WHITE_DETECT) Drive_Path((RIGHT_MIN - LF_TURN_DECREMENT), -(LEFT_MIN - LF_TURN_DECREMENT), 0);
   \                     ??LineFollow_18:
   \   000116   829F....     CMP.W   R15, &ADC_Left_Detect
   \   00011A   062C         JC      ??LineFollow_28
   \   00011C   0E43         MOV.W   #0x0, R14
   \   00011E   3D4084EA     MOV.W   #0xea84, R13
   \   000122   3C407C15     MOV.W   #0x157c, R12
   \   000126   133C         JMP     ??LineFollow_3
    208                      else if (ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 1;
   \                     ??LineFollow_28:
   \   000128   829F....     CMP.W   R15, &ADC_Left_Detect
   \   00012C   0528         JNC     ??LineFollow_29
   \   00012E   829E....     CMP.W   R14, &ADC_Right_Detect
   \   000132   192C         JC      ??LineFollow_7
   \                     ??LineFollow_9:
   \   000134   2F42         MOV.W   #0x4, R15
   \   000136   183C         JMP     ??LineFollow_4
    209                      else stateCounter = 4;
   \                     ??LineFollow_29:
   \   000138   A242....     MOV.W   #0x4, &stateCounter
   \   00013C   283C         JMP     ??LineFollow_12
    210          
    211                      break;
    212          
    213                  case 4:
    214                      if(ADC_Right_Detect < RIGHT_WHITE_DETECT) Drive_Path(-(RIGHT_MIN - LF_TURN_DECREMENT), (LEFT_MIN - LF_TURN_DECREMENT), 0);
   \                     ??LineFollow_19:
   \   00013E   829E....     CMP.W   R14, &ADC_Right_Detect
   \   000142   082C         JC      ??LineFollow_30
   \   000144   0E43         MOV.W   #0x0, R14
   \   000146   3D407C15     MOV.W   #0x157c, R13
   \   00014A   3C4084EA     MOV.W   #0xea84, R12
   \                     ??LineFollow_3:
   \   00014E   ........     CALLA   #Drive_Path
   \   000152   1D3C         JMP     ??LineFollow_12
    215                      else if (ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 1;
   \                     ??LineFollow_30:
   \   000154   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000158   0D28         JNC     ??LineFollow_26
   \   00015A   829E....     CMP.W   R14, &ADC_Right_Detect
   \   00015E   032C         JC      ??LineFollow_7
   \   000160   3F400300     MOV.W   #0x3, R15
   \   000164   013C         JMP     ??LineFollow_4
   \                     ??LineFollow_7:
   \   000166   1F43         MOV.W   #0x1, R15
   \                     ??LineFollow_4:
   \   000168   824F....     MOV.W   R15, &stateCounter
   \   00016C   103C         JMP     ??LineFollow_12
   \                     ??LineFollow_27:
   \   00016E   9243....     MOV.W   #0x1, &stateCounter
   \   000172   0D3C         JMP     ??LineFollow_12
    216                      else stateCounter = 3;
   \                     ??LineFollow_26:
   \   000174   B2400300.... MOV.W   #0x3, &stateCounter
   \   00017A   093C         JMP     ??LineFollow_12
    217          
    218                      break;
    219          
    220                  //case 10:
    221                  //    if(LockMotorsTime(-1, -1, 1)) stateCounter = 2;
    222                  //    break;
    223          
    224                  case 5:
    225                      ShutoffMotors();
   \                     ??LineFollow_20:
   \   00017C   ........     CALLA   #?Subroutine3
    226                      stateCounter = 0 ;
    227                      state = START;
    228                      EMITTER_OFF;
   \                     ??CrossCallReturnLabel_2:
   \   000180   F2C010004302 BIC.B   #0x10, &0x243
    229                      strcpy(display_line[0],"          ");
   \   000186   3D40....     MOV.W   #`?<Constant "          ">`, R13
   \   00018A   ........     CALLA   #?Subroutine5
    230                      break;
    231              }
    232          
    233              if(rFollowSpeed!=lFollowSpeed && stateCounter==1) P6OUT|=GRN_LED;
   \                     ??LineFollow_12:
   \   00018E   0A9B         CMP.W   R11, R10
   \   000190   0724         JEQ     ??LineFollow_31
   \   000192   9293....     CMP.W   #0x1, &stateCounter
   \   000196   0420         JNE     ??LineFollow_31
   \   000198   F2D040004302 BIS.B   #0x40, &0x243
   \   00019E   033C         JMP     ??LineFollow_1
    234              else P6OUT&=~GRN_LED;
   \                     ??LineFollow_31:
   \   0001A0   F2C040004302 BIC.B   #0x40, &0x243
    235          }
   \                     ??LineFollow_1:
   \   0001A6   1A17         POPM.W  #0x2, R11
   \   0001A8   1001         RETA
   \   0001AA                REQUIRE _A_TB3CCR1_L
   \   0001AA                REQUIRE _A_TB3CCR2_L
   \   0001AA                REQUIRE _A_PCOUT_L

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   ........     CALLA   #GetOutput
   \   000004   0F4C         MOV.W   R12, R15
   \   000006   3E40A00F     MOV.W   #0xfa0, R14
   \   00000A   3D40204E     MOV.W   #0x4e20, R13
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   3C40....     MOV.W   #display_line, R12
   \   000004   ........     BRA     #strcpy

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   ........     CALLA   #ShutoffMotors
   \   000004   8243....     MOV.W   #0x0, &stateCounter
   \   000008   F2405300.... MOV.B   #0x53, &state
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   8243....     MOV.W   #0x0, &stopwatch_seconds
   \   000004   8243....     MOV.W   #0x0, &cycle_count
   \   000008   1001         RETA
    236          

   \                                 In  segment CODE, align 2, keep-with-next
    237          void Exit(int direction) {
   \                     Exit:
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    238              if (stateCounter == 0) {
   \   000004   8293....     CMP.W   #0x0, &stateCounter
   \   000008   0C20         JNE     ??Exit_7
    239                  strcpy(display_line[0]," EXITING  ");
   \   00000A   3D40....     MOV.W   #`?<Constant " EXITING  ">`, R13
   \   00000E   ........     CALLA   #?Subroutine5
    240                  if(rightSwitchable && leftSwitchable)stateCounter++;
   \                     ??CrossCallReturnLabel_4:
   \   000012   8293....     CMP.W   #0x0, &rightSwitchable
   \   000016   0524         JEQ     ??Exit_7
   \   000018   8293....     CMP.W   #0x0, &leftSwitchable
   \   00001C   0224         JEQ     ??Exit_7
   \   00001E   9253....     ADD.W   #0x1, &stateCounter
    241              }
    242          
    243              if (stateCounter == 1) {
   \                     ??Exit_7:
   \   000022   9293....     CMP.W   #0x1, &stateCounter
   \   000026   0F20         JNE     ??Exit_0
    244                  if(direction) {
   \   000028   0A93         CMP.W   #0x0, R10
   \   00002A   3E402602     MOV.W   #0x226, R14
   \   00002E   0524         JEQ     ??Exit_8
    245                      if(Drive_Path(-STRAIGHT_RIGHT, STRAIGHT_LEFT, TURN90)) stateCounter++;
   \   000030   3D40803E     MOV.W   #0x3e80, R13
   \   000034   3C40E0B1     MOV.W   #0xb1e0, R12
   \   000038   043C         JMP     ??Exit_4
    246                  } else {
    247                      if(Drive_Path(STRAIGHT_RIGHT, -STRAIGHT_LEFT, TURN90)) stateCounter++;
   \                     ??Exit_8:
   \   00003A   3D4080C1     MOV.W   #0xc180, R13
   \   00003E   3C40204E     MOV.W   #0x4e20, R12
    248                  }
    249              }
   \                     ??Exit_4:
   \   000042   ........     CALLA   #?Subroutine6
    250          
    251              if (stateCounter == 2) {
   \                     ??Exit_0:
   \   000046   A293....     CMP.W   #0x2, &stateCounter
   \   00004A   0D20         JNE     ??Exit_9
    252                  if(direction) {
   \   00004C   0A93         CMP.W   #0x0, R10
   \   00004E   0324         JEQ     ??Exit_10
    253                    if(LockMotors(1, -1)) stateCounter++;  
   \   000050   3D43         MOV.W   #0xffff, R13
   \   000052   1C43         MOV.W   #0x1, R12
   \   000054   023C         JMP     ??Exit_5
    254                  } else {
    255                      if(LockMotors(-1, 1)) stateCounter++;
   \                     ??Exit_10:
   \   000056   1D43         MOV.W   #0x1, R13
   \   000058   3C43         MOV.W   #0xffff, R12
   \                     ??Exit_5:
   \   00005A   ........     CALLA   #LockMotors
   \   00005E   0C93         CMP.W   #0x0, R12
   \   000060   0224         JEQ     ??Exit_9
   \   000062   9253....     ADD.W   #0x1, &stateCounter
    256                  }
    257              }
    258          
    259              if (stateCounter == 3) {
   \                     ??Exit_9:
   \   000066   B2900300.... CMP.W   #0x3, &stateCounter
   \   00006C   0820         JNE     ??Exit_1
    260                  if(Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 5000)) stateCounter++;
   \   00006E   3E408813     MOV.W   #0x1388, R14
   \   000072   3D40803E     MOV.W   #0x3e80, R13
   \   000076   3C40204E     MOV.W   #0x4e20, R12
   \   00007A   ........     CALLA   #?Subroutine6
    261              }
    262          
    263              if (stateCounter == 4) {
   \                     ??Exit_1:
   \   00007E   A292....     CMP.W   #0x4, &stateCounter
   \   000082   0920         JNE     ??Exit_11
    264                  if(LockMotors(-1, -1)) stateCounter++;
   \   000084   3D43         MOV.W   #0xffff, R13
   \   000086   3C43         MOV.W   #0xffff, R12
   \   000088   ........     CALLA   #LockMotors
   \   00008C   0C93         CMP.W   #0x0, R12
   \   00008E   0B24         JEQ     ??Exit_6
   \   000090   9253....     ADD.W   #0x1, &stateCounter
   \   000094   083C         JMP     ??Exit_6
    265              }
    266          
    267              else if (stateCounter == 5) {
   \                     ??Exit_11:
   \   000096   B2900500.... CMP.W   #0x5, &stateCounter
   \   00009C   0420         JNE     ??Exit_6
    268                  ShutoffMotors();
   \   00009E   ........     CALLA   #?Subroutine3
    269                  stateCounter = 0 ;
    270                  state = START;
    271                  stopwatch_seconds = 0;
   \                     ??CrossCallReturnLabel_3:
   \   0000A2   ........     CALLA   #?Subroutine7
    272                  cycle_count = 0;
    273              }
    274          }
   \                     ??Exit_6:
   \   0000A6   3A41         POP.W   R10
   \   0000A8   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   ........     CALLA   #Drive_Path
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0224         JEQ     ??Exit_2
   \   000008   9253....     ADD.W   #0x1, &stateCounter
   \                     ??Exit_2:
   \   00000C   1001         RETA
    275          

   \                                 In  segment CODE, align 2, keep-with-next
    276          void Drive(int polR, int polL, unsigned int time) {
   \                     Drive:
    277              switch(stateCounter) {
   \   000000   1F42....     MOV.W   &stateCounter, R15
   \   000004   0F83         SUB.W   #0x0, R15
   \   000006   0724         JEQ     ??Drive_3
   \   000008   1F83         SUB.W   #0x1, R15
   \   00000A   0624         JEQ     ??Drive_4
   \   00000C   1F83         SUB.W   #0x1, R15
   \   00000E   1524         JEQ     ??Drive_5
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   1C24         JEQ     ??Drive_6
   \   000014   1001         RETA
    278          
    279                  case 0 :
    280                      stateCounter++;
   \                     ??Drive_3:
   \   000016   ....         JMP     ?Subroutine0
    281                      break;
    282          
    283                  case 1 :
    284                    if(Drive_Path(polR>0?STRAIGHT_RIGHT:-STRAIGHT_RIGHT, polL>0?STRAIGHT_LEFT:-STRAIGHT_LEFT, time))stateCounter++;
   \                     ??Drive_4:
   \   000018   1D93         CMP.W   #0x1, R13
   \   00001A   0334         JGE     ??Drive_7
   \   00001C   3D4080C1     MOV.W   #0xc180, R13
   \   000020   023C         JMP     ??Drive_0
   \                     ??Drive_7:
   \   000022   3D40803E     MOV.W   #0x3e80, R13
   \                     ??Drive_0:
   \   000026   1C93         CMP.W   #0x1, R12
   \   000028   0334         JGE     ??Drive_8
   \   00002A   3C40E0B1     MOV.W   #0xb1e0, R12
   \   00002E   023C         JMP     ??Drive_1
   \                     ??Drive_8:
   \   000030   3C40204E     MOV.W   #0x4e20, R12
   \                     ??Drive_1:
   \   000034   ........     CALLA   #Drive_Path
   \   000038   063C         JMP     ??Drive_2
    285          
    286                      break;
    287          
    288                  case 2 :
    289                      if(LockMotors(-polR, -polL)) stateCounter++;
   \                     ??Drive_5:
   \   00003A   3DE3         XOR.W   #0xffff, R13
   \   00003C   1D53         ADD.W   #0x1, R13
   \   00003E   3CE3         XOR.W   #0xffff, R12
   \   000040   1C53         ADD.W   #0x1, R12
   \   000042   ........     CALLA   #LockMotors
   \                     ??Drive_2:
   \   000046   0C93         CMP.W   #0x0, R12
   \   000048   0324         JEQ     ??Drive_9
   \   00004A   ....         JMP     ?Subroutine0
    290          
    291                      break;
    292          
    293                  case 3 :
    294                      ShutoffMotors();
   \                     ??Drive_6:
   \   00004C   ........     CALLA   #?Subroutine3
    295                      stateCounter = 0 ;
    296                      state = START;
    297                      break;
    298              }
    299          }
   \                     ??Drive_9:
   \   000050   1001         RETA
    300          
    301          
    302          
    303          // delays for a specified time make sure stopwatch_seconds and cycle_count are 0 before calling

   \                                 In  segment CODE, align 2
    304          int delay(int seconds, int cycles) {
   \                     delay:
    305              if(stopwatch_seconds == 0 && cycle_count <= 1) {
   \   000000   8293....     CMP.W   #0x0, &stopwatch_seconds
   \   000004   0520         JNE     ??delay_0
   \   000006   A293....     CMP.W   #0x2, &cycle_count
   \   00000A   022C         JC      ??delay_0
    306                  display_changed = 1;
   \   00000C   D243....     MOV.B   #0x1, &display_changed
    307              }
    308          
    309              if(stopwatch_seconds >= seconds && cycle_count >= cycles) {
   \                     ??delay_0:
   \   000010   829C....     CMP.W   R12, &stopwatch_seconds
   \   000014   0728         JNC     ??delay_1
   \   000016   829D....     CMP.W   R13, &cycle_count
   \   00001A   0428         JNC     ??delay_1
    310                  stopwatch_seconds = 0;
   \   00001C   ........     CALLA   #?Subroutine7
    311                  cycle_count = 0;
    312                  return 1;
   \                     ??CrossCallReturnLabel_6:
   \   000020   1C43         MOV.W   #0x1, R12
   \   000022   1001         RETA
    313              } else return 0;
   \                     ??delay_1:
   \   000024   0C43         MOV.W   #0x0, R12
   \   000026   1001         RETA
    314          }
    315          
    316          
    317          
    318          
    319          

   \                                 In  segment CODE, align 2
    320          void StateMachine(void) {
   \                     StateMachine:
    321            
    322              switch(state) {
   \   000000   1C42....     MOV.W   &polarityRight, R12
   \   000004   5E42....     MOV.B   &state, R14
   \   000008   7E804300     SUB.B   #0x43, R14
   \   00000C   1324         JEQ     ??StateMachine_0
   \   00000E   5E83         SUB.B   #0x1, R14
   \   000010   2724         JEQ     ??StateMachine_1
   \   000012   7E82         SUB.B   #0x8, R14
   \   000014   2124         JEQ     ??StateMachine_2
   \   000016   7E800700     SUB.B   #0x7, R14
   \   00001A   0E24         JEQ     ??StateMachine_3
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   1A24         JEQ     ??StateMachine_4
   \   000020   7E800300     SUB.B   #0x3, R14
   \   000024   0A24         JEQ     ??StateMachine_5
   \   000026   7E800E00     SUB.B   #0xe, R14
   \   00002A   1824         JEQ     ??StateMachine_6
   \   00002C   7E800E00     SUB.B   #0xe, R14
   \   000030   0F24         JEQ     ??StateMachine_7
   \   000032   1001         RETA
    323                  case (CALIBRATE):
    324                      calibrate();
   \                     ??StateMachine_0:
   \   000034   ........     BRA     #calibrate
    325          
    326                      /*if(calibrationMode >= 2) {
    327                          state = START;
    328                      }*/
    329          
    330                      break;
    331          
    332                  case (START):
    333                      stopwatch_seconds = 0;
   \                     ??StateMachine_3:
   \   000038   ....         JMP     ?Subroutine7
    334                      cycle_count = 0;
    335                      break;
    336          
    337                  case (WAIT):
    338                      //strcpy(display_line[0], "WAITING...");
    339          
    340                      if (delay(delayTime, 0)) state = nextState;
   \                     ??StateMachine_5:
   \   00003A   0D43         MOV.W   #0x0, R13
   \   00003C   1C42....     MOV.W   &delayTime, R12
   \   000040   ........     CALLA   #delay
   \   000044   0C93         CMP.W   #0x0, R12
   \   000046   1224         JEQ     ??StateMachine_8
   \   000048   D242........ MOV.B   &nextState, &state
   \   00004E   1001         RETA
    341          
    342                      break;
    343          
    344                  case (STRAIGHT):
    345                      Straight(polarityRight);
   \                     ??StateMachine_7:
   \   000050   ........     BRA     #Straight
    346                      break;
    347          
    348                  case (TURN):
    349                      Turn(polarityRight);
   \                     ??StateMachine_4:
   \   000054   ........     BRA     #Turn
    350                      break;
    351          
    352                  case (LINEFOLLOW):
    353                      LineFollow(polarityRight);
   \                     ??StateMachine_2:
   \   000058   ........     BRA     #LineFollow
    354                      break;
    355                      
    356                  case (EXIT):
    357                      Exit(polarityRight);
   \                     ??StateMachine_6:
   \   00005C   ........     BRA     #Exit
    358                      break;
    359                      
    360                  case (DRIVE):
    361                      Drive(polarityRight, polarityLeft, driveTime);
   \                     ??StateMachine_1:
   \   000060   1E42....     MOV.W   &driveTime, R14
   \   000064   1D42....     MOV.W   &polarityLeft, R13
   \   000068   ........     CALLA   #Drive
    362                      break;
    363          
    364                  default:
    365                      break;
    366              }
    367          }
   \                     ??StateMachine_8:
   \   00006C   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for state>`:
   \   000000   53           DC8 83

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for nextState>`:
   \   000000   73           DC8 115

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delayTime>`:
   \   000000   0100         DC16 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for enteringDirection>`:
   \   000000   4E           DC8 78

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "          ">`:
   \   000000   202020202020 DC8 "          "
   \            2020202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "INTERCEPT ">`:
   \   000000   494E54455243 DC8 "INTERCEPT "
   \            4550542000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "   TURN   ">`:
   \   000000   202020545552 DC8 "   TURN   "
   \            4E20202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " CIRCLING ">`:
   \   000000   20434952434C DC8 " CIRCLING "
   \            494E472000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " EXITING  ">`:
   \   000000   204558495449 DC8 " EXITING  "
   \            4E47202000  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Drive
        4   -> Drive_Path
        4   -> LockMotors
        8   -> ShutoffMotors
      6   Exit
       10   -> Drive_Path
        6   -> LockMotors
       10   -> ShutoffMotors
        6   -> strcpy
      8   LineFollow
        8   -> ClearController
        8   -> Drive_Path
       12   -> GetOutput
       12   -> ShutoffMotors
        8   -> additionSafe
        8   -> delay
       12   -> strcpy
        8   -> strcpy
      4   StateMachine
        4   -> Drive
        0   -> Exit
        0   -> LineFollow
        0   -> Straight
        0   -> Turn
        0   -> calibrate
        4   -> delay
     16   Straight
       16   -> Drive_Path
       16   -> LockMotors
       20   -> strcpy
      4   Turn
        0   -> Drive_Path
        4   -> Drive_Path
        4   -> ShutoffMotors
        4   -> strcpy
        8   -> strcpy
      4   delay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "          ">
      11  ?<Constant "   TURN   ">
      11  ?<Constant " CIRCLING ">
      11  ?<Constant " EXITING  ">
      11  ?<Constant "INTERCEPT ">
       2  ?<Initializer for delayTime>
       1  ?<Initializer for enteringDirection>
       1  ?<Initializer for nextState>
       1  ?<Initializer for state>
       6  ??Subroutine10_0
       6  ?Subroutine0
      10  ?Subroutine1
      20  ?Subroutine2
      16  ?Subroutine3
       8  ?Subroutine5
      14  ?Subroutine6
      10  ?Subroutine7
      16  ?Subroutine8
      14  ?Subroutine9
      82  Drive
     170  Exit
     426  LineFollow
     110  StateMachine
     232  Straight
     146  Turn
       2  _A_PCOUT_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
      40  delay
       2  delayTime
       2  driveTime
       1  enteringDirection
       1  nextState
       2  polarityLeft
       2  polarityRight
       1  state
       2  stateCounter

 
 1 326 bytes in segment CODE
     6 bytes in segment DATA16_AN
    55 bytes in segment DATA16_C
     5 bytes in segment DATA16_I
     5 bytes in segment DATA16_ID
     8 bytes in segment DATA16_Z
 
 1 326 bytes of CODE  memory
    60 bytes of CONST memory
    13 bytes of DATA  memory (+ 6 bytes shared)

Errors: none
Warnings: 3
