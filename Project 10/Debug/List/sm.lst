###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          21/Apr/2022  09:37:24
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 10\sm.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWEE14.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 10\sm.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj" --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -Ohz --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\List\sm.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj\sm.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 10\sm.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2
      2          #include "ports.h"
      3          #include "wheels.h"
      4          #include "sm.h"
      5          #include <string.h>
      6          #include "adc.h"
      7          #include "timers.h"
      8          #include "detectors.h"
      9          #include "pid.h"
     10          
     11          extern volatile unsigned int cycle_count;
     12          extern volatile unsigned int stopwatch_milliseconds;
     13          extern volatile unsigned int stopwatch_seconds;
     14          extern volatile unsigned char display_changed;
     15          extern char display_line[4][11];
     16          extern volatile unsigned int wheel_periods;

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     17          volatile char state = START;//CALIBRATE;
   \                     state:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for state>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile int stateCounter, driveStateCounter;
   \                     stateCounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     driveStateCounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     19          volatile char nextState = STRAIGHT;
   \                     nextState:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for nextState>`
     20          extern volatile unsigned int Time_Sequence;
     21          extern volatile unsigned int Last_Time_Sequence;
     22          extern volatile unsigned int time_change;

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     23          volatile unsigned int delayTime = 5;
   \                     delayTime:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for delayTime>`
     24          extern volatile unsigned int ADC_Left_Detect, ADC_Right_Detect;
     25          extern volatile unsigned int rightSwitchable, leftSwitchable;
     26          extern unsigned int temp;
     27          extern char movingDirection;

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     28          char enteringDirection = NOT_MOVING;
   \                     enteringDirection:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for enteringDirection>`
     29          extern int leftVals[VALUES_TO_HOLD];
     30          extern int rightVals[VALUES_TO_HOLD];
     31          extern volatile unsigned int calibrationMode;
     32          extern unsigned int LBDetect, LWDetect, RBDetect, RWDetect;
     33          extern PIDController rightFollowController, rightAdjustController;
     34          extern PIDController leftFollowController, leftAdjustController;
     35          
     36          extern short l_LessBlack, l_LessGray, l_LessWhite, r_LessBlack, r_LessGray, r_LessWhite, l_GreaterBlack, l_GreaterGray, l_GreaterWhite, r_GreaterBlack, r_GreaterGray, r_GreaterWhite, lessWhiteOr, lessWhiteAnd, greaterWhiteOr, greaterWhiteAnd, lessWhiteOr, lessWhiteAnd, greaterWhiteOr, greaterWhiteAnd, lessGrayOr, lessGrayAnd, greaterGrayOr, greaterGrayAnd, lessGrayOr, lessGrayAnd, greaterGrayOr, greaterGrayAnd, lessBlackOr, lessBlackAnd, greaterBlackOr, greaterBlackAnd, lessBlackOr, lessBlackAnd, greaterBlackOr, greaterBlackAnd;
     37          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     38          int speedRight, speedLeft;
   \                     speedRight:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     speedLeft:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     39          unsigned int driveTime;
   \                     driveTime:
   \   000000                DS8 2
     40          
     41          

   \                                 In  segment CODE, align 2, keep-with-next
     42          void Straight(char direction) {
   \                     Straight:
   \   000000   4E4C         MOV.B   R12, R14
     43              int rightTurn = direction ? STRAIGHT_RIGHT : -STRAIGHT_RIGHT;
   \   000002   3C40204E     MOV.W   #0x4e20, R12
   \   000006   4E93         CMP.B   #0x0, R14
   \   000008   0420         JNE     ??Straight_6
   \   00000A   3F40E0B1     MOV.W   #0xb1e0, R15
   \   00000E   0D4C         MOV.W   R12, R13
   \   000010   033C         JMP     ??Straight_3
   \                     ??Straight_6:
   \   000012   0F4C         MOV.W   R12, R15
   \   000014   3D40E0B1     MOV.W   #0xb1e0, R13
     44              int leftTurn = direction ? -STRAIGHT_LEFT : STRAIGHT_LEFT;
     45          
     46              switch(stateCounter) {
   \                     ??Straight_3:
   \   000018   1E42....     MOV.W   &stateCounter, R14
   \   00001C   0E83         SUB.W   #0x0, R14
   \   00001E   1324         JEQ     ??Straight_7
   \   000020   1E83         SUB.W   #0x1, R14
   \   000022   1624         JEQ     ??Straight_8
   \   000024   1E83         SUB.W   #0x1, R14
   \   000026   1B24         JEQ     ??Straight_0
   \   000028   1E83         SUB.W   #0x1, R14
   \   00002A   1524         JEQ     ??Straight_9
   \   00002C   1E83         SUB.W   #0x1, R14
   \   00002E   1724         JEQ     ??Straight_0
   \   000030   1E83         SUB.W   #0x1, R14
   \   000032   1D24         JEQ     ??Straight_10
   \   000034   1E83         SUB.W   #0x1, R14
   \   000036   1B24         JEQ     ??Straight_10
   \   000038   1E83         SUB.W   #0x1, R14
   \   00003A   2124         JEQ     ??Straight_11
   \   00003C   1E83         SUB.W   #0x1, R14
   \   00003E   2C24         JEQ     ??Straight_12
   \   000040   1E83         SUB.W   #0x1, R14
   \   000042   2F24         JEQ     ??Straight_13
   \   000044   1001         RETA
     47                  case 0:
     48                      stateCounter = 1;
   \                     ??Straight_7:
   \   000046   9243....     MOV.W   #0x1, &stateCounter
     49                      strcpy(display_line[0], " BL START ");
   \   00004A   3D40....     MOV.W   #`?<Constant " BL START ">`, R13
   \   00004E   ....         JMP     ?Subroutine2
     50                      display_changed = 1;
     51                      break;
     52          
     53                  case 1:
     54                      if(Drive(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG1))stateCounter++;
   \                     ??Straight_8:
   \   000050   3E40C409     MOV.W   #0x9c4, R14
   \   000054   023C         JMP     ??Straight_4
     55          
     56                      break;
     57          
     58                  case 2:
     59                      if(Drive(rightTurn, leftTurn, TURN90))stateCounter++;
     60          
     61                      break;
     62          
     63                  case 3:
     64                      if(Drive(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG2))stateCounter++;
   \                     ??Straight_9:
   \   000056   3E408813     MOV.W   #0x1388, R14
   \                     ??Straight_4:
   \   00005A   0D4C         MOV.W   R12, R13
   \   00005C   033C         JMP     ??Straight_1
     65          
     66                      break;
     67          
     68                  case 4:
     69                      if(Drive(rightTurn, leftTurn, TURN90))stateCounter++;
   \                     ??Straight_0:
   \   00005E   3E406801     MOV.W   #0x168, R14
   \   000062   0C4F         MOV.W   R15, R12
   \                     ??Straight_1:
   \   000064   ........     CALLA   #Drive
   \                     ??Straight_5:
   \   000068   0C93         CMP.W   #0x0, R12
   \   00006A   2724         JEQ     ??Straight_14
   \   00006C   ....         JMP     ?Subroutine1
     70          
     71                      break;
     72          
     73                  case 5:
     74                  case 6:
     75                      if (greaterWhiteOr) {
   \                     ??Straight_10:
   \   00006E   8293....     CMP.W   #0x0, &greaterWhiteOr
   \   000072   0424         JEQ     ??Straight_15
     76                          Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 0);
   \   000074   0E43         MOV.W   #0x0, R14
   \   000076   0D4C         MOV.W   R12, R13
   \   000078   ........     BRA     #Drive_Path
     77                      } else stateCounter++;
   \                     ??Straight_15:
   \   00007C   ....         JMP     ?Subroutine1
     78          
     79                      break;
     80          
     81                  case 7:
     82                      EMITTER_ON;
   \                     ??Straight_11:
   \   00007E   F2D010004302 BIS.B   #0x10, &0x243
     83          
     84                      if (lessWhiteOr) {
   \   000084   8293....     CMP.W   #0x0, &lessWhiteOr
   \   000088   0624         JEQ     ??Straight_16
     85                          Drive_Path(RIGHT_MIN, RIGHT_MIN, 0);
   \   00008A   0E43         MOV.W   #0x0, R14
   \   00008C   3D403421     MOV.W   #0x2134, R13
   \   000090   0C4D         MOV.W   R13, R12
   \   000092   ........     BRA     #Drive_Path
     86                      } else stateCounter++;
   \                     ??Straight_16:
   \   000096   ....         JMP     ?Subroutine1
     87          
     88                      break;
     89          
     90                  case 8:
     91                      if(LockMotors(-1, -1)) stateCounter++;
   \                     ??Straight_12:
   \   000098   3D43         MOV.W   #0xffff, R13
   \   00009A   3C43         MOV.W   #0xffff, R12
   \   00009C   ........     CALLA   #LockMotors
   \   0000A0   E33F         JMP     ??Straight_5
     92          
     93                      break;
     94          
     95                  case 9:
     96                      stateCounter = 0 ;
   \                     ??Straight_13:
   \   0000A2   ........     CALLA   #?Subroutine3
     97                      stopwatch_seconds = 0;
     98                      cycle_count = 0;
     99                      state = WAIT;
    100                      nextState = TURN;
   \                     ??CrossCallReturnLabel_2:
   \   0000A6   F2405400.... MOV.B   #0x54, &nextState
    101                      strcpy(display_line[0], "INTERCEPT ");
   \   0000AC   3D40....     MOV.W   #`?<Constant "INTERCEPT ">`, R13
   \   0000B0   ........     CALLA   #?Subroutine2
    102                      display_changed = 1;
    103                      EMITTER_OFF;
   \                     ??CrossCallReturnLabel_0:
   \   0000B4   F2C010004302 BIC.B   #0x10, &0x243
    104                      break;
    105              }
    106          }
   \                     ??Straight_14:
   \   0000BA   1001         RETA
   \   0000BC                REQUIRE _A_PCOUT_L

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_9:
   \   000004   D243....     MOV.B   #0x1, &display_changed
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   8243....     MOV.W   #0x0, &stateCounter
   \   000004   8243....     MOV.W   #0x0, &stopwatch_seconds
   \   000008   8243....     MOV.W   #0x0, &cycle_count
   \   00000C   F2405700.... MOV.B   #0x57, &state
   \   000012   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   9253....     ADD.W   #0x1, &stateCounter
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   3C40....     MOV.W   #display_line, R12
   \   000004   ........     BRA     #strcpy
    107          

   \                                 In  segment CODE, align 2, keep-with-next
    108          void Turn(char direction) {
   \                     Turn:
    109              switch(stateCounter) {
   \   000000   1F42....     MOV.W   &stateCounter, R15
   \   000004   0F83         SUB.W   #0x0, R15
   \   000006   0724         JEQ     ??Turn_1
   \   000008   1F83         SUB.W   #0x1, R15
   \   00000A   0D24         JEQ     ??Turn_2
   \   00000C   1F83         SUB.W   #0x1, R15
   \   00000E   1D24         JEQ     ??Turn_3
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   2E24         JEQ     ??Turn_4
   \   000014   1001         RETA
    110                  case 0:
    111                      EMITTER_ON;
   \                     ??Turn_1:
   \   000016   F2D010004302 BIS.B   #0x10, &0x243
    112                      stateCounter = 1;
   \   00001C   9243....     MOV.W   #0x1, &stateCounter
    113                      strcpy(display_line[0], " BL TURN ");
   \   000020   3D40....     MOV.W   #`?<Constant " BL TURN ">`, R13
   \   000024   ....         JMP     ?Subroutine2
    114                      display_changed = 1;
    115                      break;
    116          
    117                  case 1: // gotta remove this
    118                      if(direction) {
   \                     ??Turn_2:
   \   000026   4C93         CMP.B   #0x0, R12
   \   000028   3E406400     MOV.W   #0x64, R14
   \   00002C   0524         JEQ     ??Turn_5
    119                          if(Drive_Path(-RIGHT_MAX, LEFT_MAX, PRELIMINARY_TURN)) stateCounter++;
   \   00002E   3D40204E     MOV.W   #0x4e20, R13
   \   000032   3C40E0B1     MOV.W   #0xb1e0, R12
   \   000036   043C         JMP     ??Turn_0
    120                      } else if(Drive_Path(RIGHT_MAX, -LEFT_MAX, PRELIMINARY_TURN)) stateCounter++;
   \                     ??Turn_5:
   \   000038   3D40E0B1     MOV.W   #0xb1e0, R13
   \   00003C   3C40204E     MOV.W   #0x4e20, R12
   \                     ??Turn_0:
   \   000040   ........     CALLA   #Drive_Path
   \   000044   0C93         CMP.W   #0x0, R12
   \   000046   2024         JEQ     ??Turn_6
   \   000048   ....         JMP     ?Subroutine1
    121          
    122                      break;
    123          
    124                  case 2:
    125                      if (lessWhiteOr){//(((ADC_Left_Detect < LEFT_GRAY_DETECT || ADC_Right_Detect < RIGHT_GRAY_DETECT))) {
   \                     ??Turn_3:
   \   00004A   8293....     CMP.W   #0x0, &lessWhiteOr
   \   00004E   0F24         JEQ     ??Turn_7
    126                          if(direction)Drive_Path(-RIGHT_MIN, LEFT_MIN, 0);
   \   000050   4C93         CMP.B   #0x0, R12
   \   000052   0E43         MOV.W   #0x0, R14
   \   000054   0624         JEQ     ??Turn_8
   \   000056   3D403421     MOV.W   #0x2134, R13
   \   00005A   3C40CCDE     MOV.W   #0xdecc, R12
   \   00005E   ........     BRA     #Drive_Path
    127          
    128                          else Drive_Path(RIGHT_MIN, -LEFT_MIN, 0);
   \                     ??Turn_8:
   \   000062   3D40CCDE     MOV.W   #0xdecc, R13
   \   000066   3C403421     MOV.W   #0x2134, R12
   \   00006A   ........     BRA     #Drive_Path
    129                      } else stateCounter++;
   \                     ??Turn_7:
   \   00006E   ....         JMP     ?Subroutine1
    130          
    131                      break;
    132          
    133                  case 3:
    134                      ShutoffMotors();
   \                     ??Turn_4:
   \   000070   ........     CALLA   #ShutoffMotors
    135                      stateCounter = 0 ;
   \   000074   ........     CALLA   #?Subroutine3
    136                      stopwatch_seconds = 0;
    137                      cycle_count = 0;
    138                      state = WAIT;
    139                      nextState = LINEFOLLOW;
   \                     ??CrossCallReturnLabel_3:
   \   000078   F2404C00.... MOV.B   #0x4c, &nextState
    140                      EMITTER_OFF;
   \   00007E   F2C010004302 BIC.B   #0x10, &0x243
    141                      //strcpy(display_line[0], " BL TURN ");
    142                      display_changed = 1;
   \   000084   D243....     MOV.B   #0x1, &display_changed
    143                      break;
    144              }
    145          }
   \                     ??Turn_6:
   \   000088   1001         RETA
   \   00008A                REQUIRE _A_PCOUT_L
    146          

   \                                 In  segment CODE, align 2, keep-with-next
    147          void LineFollow(char direction) {
   \                     LineFollow:
   \   000000   1B15         PUSHM.W #0x2, R11
    148              //HEXtoBCD(ADC_Left_Detect, 1, 6);
    149              //HEXtoBCD(ADC_Right_Detect, 1, 0);
    150          
    151              int rFollowSpeed, lFollowSpeed, rAdjustSpeed, lAdjustSpeed;
    152          
    153              //rFollowSpeed = RIGHT_MIN>>1;
    154              //lFollowSpeed = LEFT_MIN>>1;
    155          
    156              /*if(ADC_Left_Detect>LEFT_GRAY_DETECT)rFollowSpeed = 3000;
    157              else*/ 
    158              rFollowSpeed = additionSafe(RIGHT_FORWARD_SPEED, RIGHT_MAX, RIGHT_MIN>>1, GetOutput(&leftFollowController, LEFT_BLACK_DETECT, ADC_Left_Detect)); // swapped b/c they are physically swapped
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   000002   1E42....     MOV.W   &ADC_Left_Detect, R14
   \   000006   1D42....     MOV.W   &LBDetect, R13
   \   00000A   2D83         SUB.W   #0x2, R13
   \   00000C   3C40....     MOV.W   #leftFollowController, R12
   \   000010   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_6:
   \   000014   1C425404     MOV.W   &0x454, R12
   \   000018   ........     CALLA   #additionSafe
   \   00001C   0A4C         MOV.W   R12, R10
    159              /*if(ADC_Right_Detect>RIGHT_GRAY_DETECT)lFollowSpeed = 3000;
    160              else*/ 
    161              lFollowSpeed = additionSafe(LEFT_FORWARD_SPEED, LEFT_MAX, RIGHT_MIN>>1, GetOutput(&rightFollowController, RIGHT_BLACK_DETECT, ADC_Right_Detect));// swapped b/c they are physically swapped
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   00001E   1E42....     MOV.W   &ADC_Right_Detect, R14
   \   000022   1D42....     MOV.W   &RBDetect, R13
   \   000026   2D83         SUB.W   #0x2, R13
   \   000028   3C40....     MOV.W   #rightFollowController, R12
   \   00002C   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_7:
   \   000030   1C425604     MOV.W   &0x456, R12
   \   000034   ........     CALLA   #additionSafe
   \   000038   0B4C         MOV.W   R12, R11
    162              rAdjustSpeed = (RIGHT_MIN - LF_TURN_DECREMENT);
    163              lAdjustSpeed = (LEFT_MIN - LF_TURN_DECREMENT);
    164          
    165              switch(stateCounter) {
   \   00003A   1F42....     MOV.W   &l_LessWhite, R15
   \   00003E   1E42....     MOV.W   &r_LessWhite, R14
   \   000042   1D42....     MOV.W   &stateCounter, R13
   \   000046   0D83         SUB.W   #0x0, R13
   \   000048   0E24         JEQ     ??LineFollow_12
   \   00004A   1D83         SUB.W   #0x1, R13
   \   00004C   1E24         JEQ     ??LineFollow_13
   \   00004E   1D83         SUB.W   #0x1, R13
   \   000050   3E24         JEQ     ??LineFollow_14
   \   000052   1D83         SUB.W   #0x1, R13
   \   000054   4724         JEQ     ??LineFollow_15
   \   000056   1D83         SUB.W   #0x1, R13
   \   000058   5224         JEQ     ??LineFollow_16
   \   00005A   1D83         SUB.W   #0x1, R13
   \   00005C   7524         JEQ     ??LineFollow_17
   \   00005E   3D800500     SUB.W   #0x5, R13
   \   000062   6824         JEQ     ??LineFollow_18
   \   000064   7B3C         JMP     ??LineFollow_10
    166                  case 0:
    167                      EMITTER_ON;
   \                     ??LineFollow_12:
   \   000066   F2D010004302 BIS.B   #0x10, &0x243
    168                      strcpy(display_line[0], "BL TRAVEL ");
   \   00006C   3D40....     MOV.W   #`?<Constant "BL TRAVEL ">`, R13
   \   000070   ........     CALLA   #?Subroutine2
    169                      display_changed = 1;
    170          
    171                      if(rightSwitchable && leftSwitchable)stateCounter++;
   \                     ??CrossCallReturnLabel_1:
   \   000074   8293....     CMP.W   #0x0, &rightSwitchable
   \   000078   7D24         JEQ     ??LineFollow_0
   \   00007A   8293....     CMP.W   #0x0, &leftSwitchable
   \   00007E   7A24         JEQ     ??LineFollow_0
   \   000080   9253....     ADD.W   #0x1, &stateCounter
    172                      else return;
    173          
    174                      stopwatch_seconds = 0;
   \   000084   ........     CALLA   #?Subroutine4
    175                      cycle_count = 0;
    176          
    177                      break;
   \                     ??CrossCallReturnLabel_4:
   \   000088   693C         JMP     ??LineFollow_10
    178          
    179                  case 1:
    180                      if(l_LessWhite ^ r_LessWhite) stateCounter = 10;
   \                     ??LineFollow_13:
   \   00008A   0FEE         XOR.W   R14, R15
   \   00008C   0424         JEQ     ??LineFollow_19
   \   00008E   B2400A00.... MOV.W   #0xa, &stateCounter
   \   000094   063C         JMP     ??LineFollow_11
    181                      else if (lessWhiteAnd) {
   \                     ??LineFollow_19:
   \   000096   8293....     CMP.W   #0x0, &lessWhiteAnd
   \   00009A   0324         JEQ     ??LineFollow_11
    182                          rFollowSpeed = -RIGHT_MIN;
   \   00009C   3A40CCDE     MOV.W   #0xdecc, R10
    183                          lFollowSpeed = -LEFT_MIN;
   \   0000A0   0B4A         MOV.W   R10, R11
    184                      }/* else {
    185          
    186                          ClearController(&rightFollowController);
    187                          ClearController(&leftFollowController);
    188                      }*/
    189          
    190                      if(delay(CIRCLING_TIME, 0))  stateCounter = 5;
   \                     ??LineFollow_11:
   \   0000A2   0D43         MOV.W   #0x0, R13
   \   0000A4   3C407800     MOV.W   #0x78, R12
   \   0000A8   ........     CALLA   #delay
   \   0000AC   0C93         CMP.W   #0x0, R12
   \   0000AE   0324         JEQ     ??LineFollow_20
   \   0000B0   B2400500.... MOV.W   #0x5, &stateCounter
    191          
    192                      if(stopwatch_seconds >= TIME_TO_CIRCLE) strcpy(display_line[0], "BL CIRCLE ");
   \                     ??LineFollow_20:
   \   0000B6   B2900300.... CMP.W   #0x3, &stopwatch_seconds
   \   0000BC   0428         JNC     ??LineFollow_21
   \   0000BE   3D40....     MOV.W   #`?<Constant "BL CIRCLE ">`, R13
   \   0000C2   ........     CALLA   #?Subroutine6
    193          
    194                      Drive_Path(rFollowSpeed, lFollowSpeed, 0);
   \                     ??LineFollow_21:
   \   0000C6   0E43         MOV.W   #0x0, R14
   \   0000C8   0D4B         MOV.W   R11, R13
   \   0000CA   0C4A         MOV.W   R10, R12
   \   0000CC   1F3C         JMP     ??LineFollow_2
    195                      break;
    196          
    197          
    198                  case 2:
    199                      if(l_LessWhite && r_GreaterWhite) stateCounter = 3;
   \                     ??LineFollow_14:
   \   0000CE   0F93         CMP.W   #0x0, R15
   \   0000D0   0324         JEQ     ??LineFollow_22
   \   0000D2   8293....     CMP.W   #0x0, &r_GreaterWhite
   \   0000D6   2A20         JNE     ??LineFollow_23
    200                      else if(l_GreaterWhite && r_LessWhite) stateCounter = 4;
   \                     ??LineFollow_22:
   \   0000D8   8293....     CMP.W   #0x0, &l_GreaterWhite
   \   0000DC   2424         JEQ     ??LineFollow_24
   \   0000DE   0E93         CMP.W   #0x0, R14
   \   0000E0   0C20         JNE     ??LineFollow_8
   \   0000E2   1D3C         JMP     ??LineFollow_6
    201                      else stateCounter = 1;
    202          
    203                      break;
    204          
    205                  case 3:// turn left ()
    206                      if(l_LessWhite) Drive_Path(rAdjustSpeed, -lAdjustSpeed, 0);
   \                     ??LineFollow_15:
   \   0000E4   0F93         CMP.W   #0x0, R15
   \   0000E6   0624         JEQ     ??LineFollow_25
   \   0000E8   0E43         MOV.W   #0x0, R14
   \   0000EA   3D4090E8     MOV.W   #0xe890, R13
   \   0000EE   3C407017     MOV.W   #0x1770, R12
   \   0000F2   0C3C         JMP     ??LineFollow_2
    207                      else if (greaterWhiteAnd) stateCounter = 1;
   \                     ??LineFollow_25:
   \   0000F4   8293....     CMP.W   #0x0, &greaterWhiteAnd
   \   0000F8   1220         JNE     ??LineFollow_6
   \                     ??LineFollow_8:
   \   0000FA   2F42         MOV.W   #0x4, R15
   \   0000FC   113C         JMP     ??LineFollow_3
    208                      else stateCounter = 4;
    209          
    210                      break;
    211          
    212                  case 4:
    213                      if(r_LessWhite) Drive_Path(-rAdjustSpeed, lAdjustSpeed, 0);
   \                     ??LineFollow_16:
   \   0000FE   0E93         CMP.W   #0x0, R14
   \   000100   0824         JEQ     ??LineFollow_26
   \   000102   0E43         MOV.W   #0x0, R14
   \   000104   3D407017     MOV.W   #0x1770, R13
   \   000108   3C4090E8     MOV.W   #0xe890, R12
   \                     ??LineFollow_2:
   \   00010C   ........     CALLA   #Drive_Path
   \   000110   253C         JMP     ??LineFollow_10
    214                      else if (greaterWhiteAnd) stateCounter = 1;
   \                     ??LineFollow_26:
   \   000112   8293....     CMP.W   #0x0, &greaterWhiteAnd
   \   000116   0320         JNE     ??LineFollow_6
   \   000118   3F400300     MOV.W   #0x3, R15
   \   00011C   013C         JMP     ??LineFollow_3
   \                     ??LineFollow_6:
   \   00011E   1F43         MOV.W   #0x1, R15
   \                     ??LineFollow_3:
   \   000120   824F....     MOV.W   R15, &stateCounter
   \   000124   1B3C         JMP     ??LineFollow_10
   \                     ??LineFollow_24:
   \   000126   9243....     MOV.W   #0x1, &stateCounter
   \   00012A   183C         JMP     ??LineFollow_10
    215                      else stateCounter = 3;
   \                     ??LineFollow_23:
   \   00012C   B2400300.... MOV.W   #0x3, &stateCounter
   \   000132   143C         JMP     ??LineFollow_10
    216          
    217                      break;
    218          
    219                  case 10:
    220                      if(LockMotorsTime(-1, -1, 1)) stateCounter = 2;
   \                     ??LineFollow_18:
   \   000134   1E43         MOV.W   #0x1, R14
   \   000136   3D43         MOV.W   #0xffff, R13
   \   000138   3C43         MOV.W   #0xffff, R12
   \   00013A   ........     CALLA   #LockMotorsTime
   \   00013E   0C93         CMP.W   #0x0, R12
   \   000140   0D24         JEQ     ??LineFollow_10
   \   000142   A243....     MOV.W   #0x2, &stateCounter
   \   000146   0A3C         JMP     ??LineFollow_10
    221          
    222                      break;
    223          
    224                  case 5:
    225                      ShutoffMotors();
   \                     ??LineFollow_17:
   \   000148   ........     CALLA   #ShutoffMotors
    226                      stateCounter = 0 ;
   \   00014C   8243....     MOV.W   #0x0, &stateCounter
    227                      state = START;
   \   000150   F2405300.... MOV.B   #0x53, &state
    228                      EMITTER_OFF;
   \   000156   F2C010004302 BIC.B   #0x10, &0x243
    229                      //strcpy(display_line[0], "          ");
    230                      break;
    231              }
    232          
    233              if(rFollowSpeed != lFollowSpeed && stateCounter == 1) P6OUT |= GRN_LED;
   \                     ??LineFollow_10:
   \   00015C   0A9B         CMP.W   R11, R10
   \   00015E   0724         JEQ     ??LineFollow_27
   \   000160   9293....     CMP.W   #0x1, &stateCounter
   \   000164   0420         JNE     ??LineFollow_27
   \   000166   F2D040004302 BIS.B   #0x40, &0x243
   \   00016C   033C         JMP     ??LineFollow_0
    234              else P6OUT &= ~GRN_LED;
   \                     ??LineFollow_27:
   \   00016E   F2C040004302 BIC.B   #0x40, &0x243
    235          }
   \                     ??LineFollow_0:
   \   000174   1A17         POPM.W  #0x2, R11
   \   000176   1001         RETA
   \   000178                REQUIRE _A_TB3CCR1_L
   \   000178                REQUIRE _A_TB3CCR2_L
   \   000178                REQUIRE _A_PCOUT_L

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   ........     CALLA   #GetOutput
   \   000004   0F4C         MOV.W   R12, R15
   \   000006   3E409A10     MOV.W   #0x109a, R14
   \   00000A   3D40204E     MOV.W   #0x4e20, R13
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   8243....     MOV.W   #0x0, &stopwatch_seconds
   \   000004   8243....     MOV.W   #0x0, &cycle_count
   \   000008   1001         RETA
    236          

   \                                 In  segment CODE, align 2
    237          void Exit(int direction) {
   \                     Exit:
    238              switch(stateCounter) {
   \   000000   3F40204E     MOV.W   #0x4e20, R15
   \   000004   1E42....     MOV.W   &stateCounter, R14
   \   000008   0E83         SUB.W   #0x0, R14
   \   00000A   0724         JEQ     ??Exit_2
   \   00000C   1E83         SUB.W   #0x1, R14
   \   00000E   0A24         JEQ     ??Exit_3
   \   000010   1E83         SUB.W   #0x1, R14
   \   000012   1324         JEQ     ??Exit_4
   \   000014   1E83         SUB.W   #0x1, R14
   \   000016   1A24         JEQ     ??Exit_5
   \   000018   1001         RETA
    239                  case 0:
    240                      strcpy(display_line[0], " BL STOP  ");
   \                     ??Exit_2:
   \   00001A   3D40....     MOV.W   #`?<Constant " BL STOP  ">`, R13
   \   00001E   ........     CALLA   #?Subroutine6
    241                      /*if(rightSwitchable && leftSwitchable)*/stateCounter++;
   \                     ??CrossCallReturnLabel_8:
   \   000022   ....         JMP     ?Subroutine1
    242                      break;
    243          
    244                  case 1:
    245                      if ( Drive(direction ? -STRAIGHT_RIGHT : STRAIGHT_RIGHT, direction ? STRAIGHT_LEFT : -STRAIGHT_LEFT, TURN90) )
   \                     ??Exit_3:
   \   000024   0C93         CMP.W   #0x0, R12
   \   000026   0320         JNE     ??Exit_6
   \   000028   3D40E0B1     MOV.W   #0xb1e0, R13
   \   00002C   033C         JMP     ??Exit_0
   \                     ??Exit_6:
   \   00002E   0D4F         MOV.W   R15, R13
   \   000030   3F40E0B1     MOV.W   #0xb1e0, R15
   \                     ??Exit_0:
   \   000034   3E406801     MOV.W   #0x168, R14
   \   000038   033C         JMP     ??Exit_1
    246                          stateCounter++;
    247          
    248                      break;
    249          
    250                  case 2:
    251                      if(Drive(STRAIGHT_RIGHT, STRAIGHT_LEFT, 5000)) stateCounter++;
   \                     ??Exit_4:
   \   00003A   3E408813     MOV.W   #0x1388, R14
   \   00003E   0D4F         MOV.W   R15, R13
   \                     ??Exit_1:
   \   000040   0C4F         MOV.W   R15, R12
   \   000042   ........     CALLA   #Drive
   \   000046   0C93         CMP.W   #0x0, R12
   \   000048   0A24         JEQ     ??Exit_7
   \   00004A   ....         JMP     ?Subroutine1
    252          
    253                      break;
    254          
    255                  case 3:
    256                      ShutoffMotors();
   \                     ??Exit_5:
   \   00004C   ........     CALLA   #ShutoffMotors
    257                      stateCounter = 0 ;
   \   000050   8243....     MOV.W   #0x0, &stateCounter
    258                      state = DONE;
   \   000054   F2406400.... MOV.B   #0x64, &state
    259                      stopwatch_seconds = 0;
   \   00005A   ........     CALLA   #?Subroutine4
    260                      cycle_count = 0;
    261                      break;
    262              }
    263          }
   \                     ??Exit_7:
   \   00005E   1001         RETA
    264          

   \                                 In  segment CODE, align 2
    265          int Drive(int r, int l, unsigned int time) {
   \                     Drive:
    266              switch(driveStateCounter) {
   \   000000   1F42....     MOV.W   &driveStateCounter, R15
   \   000004   0F83         SUB.W   #0x0, R15
   \   000006   0724         JEQ     ??Drive_2
   \   000008   1F83         SUB.W   #0x1, R15
   \   00000A   0924         JEQ     ??Drive_4
   \   00000C   1F83         SUB.W   #0x1, R15
   \   00000E   0C24         JEQ     ??Drive_5
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   1124         JEQ     ??Drive_6
   \   000014   023C         JMP     ??Drive_0
    267          
    268                  case 0 :
    269                      driveStateCounter++;
   \                     ??Drive_2:
   \   000016   9253....     ADD.W   #0x1, &driveStateCounter
    270                      break;
    271          
    272                  case 1 :
    273                      if(Drive_Path(r, l, time))driveStateCounter++;
    274          
    275                      break;
    276          
    277                  case 2 :
    278                      if(LockMotors(-r, -l)) driveStateCounter++;
    279          
    280                      break;
    281          
    282                  case 3 :
    283                      ShutoffMotors();
    284                      driveStateCounter = 0 ;
    285                      //state = START;
    286                      return 1;
    287                      break;
    288              }
    289          
    290              return 0;
   \                     ??Drive_0:
   \   00001A   0C43         MOV.W   #0x0, R12
   \   00001C   1001         RETA
   \                     ??Drive_4:
   \   00001E   ........     CALLA   #Drive_Path
   \                     ??Drive_3:
   \   000022   0C93         CMP.W   #0x0, R12
   \   000024   FA27         JEQ     ??Drive_0
   \   000026   F73F         JMP     ??Drive_2
   \                     ??Drive_5:
   \   000028   3DE3         XOR.W   #0xffff, R13
   \   00002A   1D53         ADD.W   #0x1, R13
   \   00002C   3CE3         XOR.W   #0xffff, R12
   \   00002E   1C53         ADD.W   #0x1, R12
   \   000030   ........     CALLA   #LockMotors
   \   000034   F63F         JMP     ??Drive_3
   \                     ??Drive_6:
   \   000036   ........     CALLA   #ShutoffMotors
   \   00003A   8243....     MOV.W   #0x0, &driveStateCounter
   \   00003E   1C43         MOV.W   #0x1, R12
   \   000040   1001         RETA
    291          }
    292          
    293          
    294          
    295          // delays for a specified time make sure stopwatch_seconds and cycle_count are 0 before calling

   \                                 In  segment CODE, align 2
    296          int delay(int seconds, int cycles) {
   \                     delay:
    297              if(stopwatch_seconds == 0 && cycle_count <= 1) {
   \   000000   8293....     CMP.W   #0x0, &stopwatch_seconds
   \   000004   0520         JNE     ??delay_0
   \   000006   A293....     CMP.W   #0x2, &cycle_count
   \   00000A   022C         JC      ??delay_0
    298                  display_changed = 1;
   \   00000C   D243....     MOV.B   #0x1, &display_changed
    299              }
    300          
    301              if(stopwatch_seconds >= seconds && cycle_count >= cycles) {
   \                     ??delay_0:
   \   000010   829C....     CMP.W   R12, &stopwatch_seconds
   \   000014   0728         JNC     ??delay_1
   \   000016   829D....     CMP.W   R13, &cycle_count
   \   00001A   0428         JNC     ??delay_1
    302                  stopwatch_seconds = 0;
   \   00001C   ........     CALLA   #?Subroutine4
    303                  cycle_count = 0;
    304                  return 1;
   \                     ??CrossCallReturnLabel_5:
   \   000020   1C43         MOV.W   #0x1, R12
   \   000022   1001         RETA
    305              } else return 0;
   \                     ??delay_1:
   \   000024   0C43         MOV.W   #0x0, R12
   \   000026   1001         RETA
    306          }
    307          
    308          
    309          
    310          
    311          

   \                                 In  segment CODE, align 2
    312          void StateMachine(void) {
   \                     StateMachine:
    313              updateDetectors();
   \   000000   ........     CALLA   #updateDetectors
    314          
    315              switch(state) {
   \   000004   1C42....     MOV.W   &speedRight, R12
   \   000008   5E42....     MOV.B   &state, R14
   \   00000C   7E804300     SUB.B   #0x43, R14
   \   000010   1324         JEQ     ??StateMachine_0
   \   000012   5E83         SUB.B   #0x1, R14
   \   000014   2724         JEQ     ??StateMachine_1
   \   000016   7E82         SUB.B   #0x8, R14
   \   000018   2124         JEQ     ??StateMachine_2
   \   00001A   7E800700     SUB.B   #0x7, R14
   \   00001E   0E24         JEQ     ??StateMachine_3
   \   000020   5E83         SUB.B   #0x1, R14
   \   000022   1A24         JEQ     ??StateMachine_4
   \   000024   7E800300     SUB.B   #0x3, R14
   \   000028   0A24         JEQ     ??StateMachine_5
   \   00002A   7E800E00     SUB.B   #0xe, R14
   \   00002E   1824         JEQ     ??StateMachine_6
   \   000030   7E800E00     SUB.B   #0xe, R14
   \   000034   0F24         JEQ     ??StateMachine_7
   \   000036   1001         RETA
    316                  case (CALIBRATE):
    317                      calibrate();
   \                     ??StateMachine_0:
   \   000038   ........     BRA     #calibrate
    318          
    319                      /*if(calibrationMode >= 2) {
    320                          state = START;
    321                      }*/
    322          
    323                      break;
    324          
    325                  case (START):
    326                      stopwatch_seconds = 0;
   \                     ??StateMachine_3:
   \   00003C   ....         JMP     ?Subroutine4
    327                      cycle_count = 0;
    328                      break;
    329          
    330                  case (WAIT):
    331          
    332                      //strcpy(display_line[0], "WAITING...");
    333          
    334                      if (delay(delayTime, 0)) state = nextState;
   \                     ??StateMachine_5:
   \   00003E   0D43         MOV.W   #0x0, R13
   \   000040   1C42....     MOV.W   &delayTime, R12
   \   000044   ........     CALLA   #delay
   \   000048   0C93         CMP.W   #0x0, R12
   \   00004A   1724         JEQ     ??StateMachine_8
   \   00004C   D242........ MOV.B   &nextState, &state
   \   000052   1001         RETA
    335          
    336                      break;
    337          
    338                  case (STRAIGHT):
    339                      Straight(speedRight);
   \                     ??StateMachine_7:
   \   000054   ........     BRA     #Straight
    340                      break;
    341          
    342                  case (TURN):
    343                      Turn(speedRight);
   \                     ??StateMachine_4:
   \   000058   ........     BRA     #Turn
    344                      break;
    345          
    346                  case (LINEFOLLOW):
    347                      LineFollow(speedRight);
   \                     ??StateMachine_2:
   \   00005C   ........     BRA     #LineFollow
    348                      break;
    349          
    350                  case (EXIT):
    351                      Exit(speedRight);
   \                     ??StateMachine_6:
   \   000060   ........     BRA     #Exit
    352                      break;
    353          
    354                  case (DRIVE):
    355                      if(Drive(speedRight, speedLeft, driveTime)) state = START;
   \                     ??StateMachine_1:
   \   000064   1E42....     MOV.W   &driveTime, R14
   \   000068   1D42....     MOV.W   &speedLeft, R13
   \   00006C   ........     CALLA   #Drive
   \   000070   0C93         CMP.W   #0x0, R12
   \   000072   0324         JEQ     ??StateMachine_8
   \   000074   F2405300.... MOV.B   #0x53, &state
    356                      break;
    357          
    358                  case (DONE):
    359                      break;
    360          
    361                  default:
    362                      break;
    363              }
    364          }
   \                     ??StateMachine_8:
   \   00007A   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for state>`:
   \   000000   53           DC8 83

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for nextState>`:
   \   000000   73           DC8 115

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delayTime>`:
   \   000000   0500         DC16 5

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for enteringDirection>`:
   \   000000   4E           DC8 78

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " BL START ">`:
   \   000000   20424C205354 DC8 " BL START "
   \            4152542000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "INTERCEPT ">`:
   \   000000   494E54455243 DC8 "INTERCEPT "
   \            4550542000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " BL TURN ">`:
   \   000000   20424C205455 DC8 " BL TURN "
   \            524E2000    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BL TRAVEL ">`:
   \   000000   424C20545241 DC8 "BL TRAVEL "
   \            56454C2000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BL CIRCLE ">`:
   \   000000   424C20434952 DC8 "BL CIRCLE "
   \            434C452000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " BL STOP  ">`:
   \   000000   20424C205354 DC8 " BL STOP  "
   \            4F50202000  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Drive
        4   -> Drive_Path
        4   -> LockMotors
        4   -> ShutoffMotors
      4   Exit
        4   -> Drive
        4   -> ShutoffMotors
        4   -> strcpy
      8   LineFollow
        8   -> Drive_Path
       12   -> GetOutput
        8   -> LockMotorsTime
        8   -> ShutoffMotors
        8   -> additionSafe
        8   -> delay
       12   -> strcpy
        8   -> strcpy
      4   StateMachine
        4   -> Drive
        0   -> Exit
        0   -> LineFollow
        0   -> Straight
        0   -> Turn
        0   -> calibrate
        4   -> delay
        4   -> updateDetectors
      4   Straight
        4   -> Drive
        0   -> Drive_Path
        4   -> LockMotors
        4   -> strcpy
        8   -> strcpy
      4   Turn
        0   -> Drive_Path
        4   -> Drive_Path
        4   -> ShutoffMotors
        4   -> strcpy
      4   delay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant " BL START ">
      11  ?<Constant " BL STOP  ">
      10  ?<Constant " BL TURN ">
      11  ?<Constant "BL CIRCLE ">
      11  ?<Constant "BL TRAVEL ">
      11  ?<Constant "INTERCEPT ">
       2  ?<Initializer for delayTime>
       1  ?<Initializer for enteringDirection>
       1  ?<Initializer for nextState>
       1  ?<Initializer for state>
       6  ?Subroutine1
      10  ?Subroutine2
      20  ?Subroutine3
      10  ?Subroutine4
      16  ?Subroutine5
       8  ?Subroutine6
      66  Drive
      96  Exit
     376  LineFollow
     124  StateMachine
     188  Straight
     138  Turn
       2  _A_PCOUT_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
      40  delay
       2  delayTime
       2  driveStateCounter
       2  driveTime
       1  enteringDirection
       1  nextState
       2  speedLeft
       2  speedRight
       1  state
       2  stateCounter

 
 1 098 bytes in segment CODE
     6 bytes in segment DATA16_AN
    65 bytes in segment DATA16_C
     5 bytes in segment DATA16_I
     5 bytes in segment DATA16_ID
    10 bytes in segment DATA16_Z
 
 1 098 bytes of CODE  memory
    70 bytes of CONST memory
    15 bytes of DATA  memory (+ 6 bytes shared)

Errors: none
Warnings: 2
