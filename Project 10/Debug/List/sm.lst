###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          14/Apr/2022  11:35:21
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 10\sm.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EW701F.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 10\sm.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj" --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -Ohz --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\List\sm.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj\sm.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 10\sm.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2
      2          #include "ports.h"
      3          #include "wheels.h"
      4          #include "sm.h"
      5          #include <string.h>
      6          #include "adc.h"
      7          #include "timers.h"
      8          #include "detectors.h"
      9          #include "pid.h"
     10          
     11          extern volatile unsigned int cycle_count;
     12          extern volatile unsigned int stopwatch_milliseconds;
     13          extern volatile unsigned int stopwatch_seconds;
     14          extern volatile unsigned char display_changed;
     15          extern char display_line[4][11];
     16          extern volatile unsigned int wheel_periods;

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     17          volatile char state = START;//CALIBRATE;
   \                     state:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for state>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile int stateCounter;
   \                     stateCounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     19          volatile char nextState = STRAIGHT;
   \                     nextState:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for nextState>`
     20          extern volatile unsigned int Time_Sequence;
     21          extern volatile unsigned int Last_Time_Sequence;
     22          extern volatile unsigned int time_change;

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     23          volatile unsigned int delayTime = 1;
   \                     delayTime:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for delayTime>`
     24          extern volatile unsigned int ADC_Left_Detect, ADC_Right_Detect;
     25          extern volatile unsigned int rightSwitchable, leftSwitchable;
     26          extern unsigned int temp;
     27          extern char movingDirection;

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     28          char enteringDirection = NOT_MOVING;
   \                     enteringDirection:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for enteringDirection>`
     29          extern int leftVals[VALUES_TO_HOLD];
     30          extern int rightVals[VALUES_TO_HOLD];
     31          extern volatile unsigned int calibrationMode;
     32          extern unsigned int LBDetect, LWDetect, RBDetect, RWDetect;
     33          extern PIDController rightFollowController, rightAdjustController;
     34          extern PIDController leftFollowController, leftAdjustController;
     35          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     36          int polarityRight, polarityLeft;
   \                     polarityRight:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     polarityLeft:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     37          unsigned int driveTime;
   \                     driveTime:
   \   000000                DS8 2
     38          
     39          

   \                                 In  segment CODE, align 2
     40          void Straight(char direction) {
   \                     Straight:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4E4C         MOV.B   R12, R14
     41            int rightTurn = direction?STRAIGHT_RIGHT:-STRAIGHT_RIGHT;
   \   000004   3C40204E     MOV.W   #0x4e20, R12
   \   000008   3D40803E     MOV.W   #0x3e80, R13
   \   00000C   4E93         CMP.B   #0x0, R14
   \   00000E   0420         JNE     ??Straight_18
   \   000010   3A40E0B1     MOV.W   #0xb1e0, R10
   \   000014   0F4D         MOV.W   R13, R15
   \   000016   033C         JMP     ??Straight_15
   \                     ??Straight_18:
   \   000018   0A4C         MOV.W   R12, R10
   \   00001A   3F4080C1     MOV.W   #0xc180, R15
   \                     ??Straight_15:
   \   00001E   1842....     MOV.W   &RWDetect, R8
   \   000022   38501400     ADD.W   #0x14, R8
   \   000026   1942....     MOV.W   &LWDetect, R9
   \   00002A   39501400     ADD.W   #0x14, R9
   \   00002E   0B4A         MOV.W   R10, R11
   \   000030   3BE3         XOR.W   #0xffff, R11
   \   000032   1B53         ADD.W   #0x1, R11
   \   000034   0E4F         MOV.W   R15, R14
   \   000036   3EE3         XOR.W   #0xffff, R14
   \   000038   1E53         ADD.W   #0x1, R14
   \   00003A   1642....     MOV.W   &stateCounter, R6
   \   00003E   0683         SUB.W   #0x0, R6
   \   000040   1924         JEQ     ??Straight_19
   \   000042   1683         SUB.W   #0x1, R6
   \   000044   1A24         JEQ     ??Straight_14
   \   000046   1683         SUB.W   #0x1, R6
   \   000048   3A24         JEQ     ??Straight_0
   \   00004A   1683         SUB.W   #0x1, R6
   \   00004C   1924         JEQ     ??Straight_8
   \   00004E   1683         SUB.W   #0x1, R6
   \   000050   1E24         JEQ     ??Straight_10
   \   000052   1683         SUB.W   #0x1, R6
   \   000054   1224         JEQ     ??Straight_14
   \   000056   1683         SUB.W   #0x1, R6
   \   000058   3224         JEQ     ??Straight_0
   \   00005A   1683         SUB.W   #0x1, R6
   \   00005C   1124         JEQ     ??Straight_8
   \   00005E   1683         SUB.W   #0x1, R6
   \   000060   1624         JEQ     ??Straight_10
   \   000062   1683         SUB.W   #0x1, R6
   \   000064   1724         JEQ     ??Straight_20
   \   000066   1683         SUB.W   #0x1, R6
   \   000068   1D24         JEQ     ??Straight_21
   \   00006A   1683         SUB.W   #0x1, R6
   \   00006C   2824         JEQ     ??Straight_0
   \   00006E   1683         SUB.W   #0x1, R6
   \   000070   2F24         JEQ     ??Straight_22
   \   000072   3A3C         JMP     ??Straight_16
     42            int leftTurn = direction?-STRAIGHT_LEFT:STRAIGHT_LEFT;
     43              switch(stateCounter) {
     44                  case 0:
     45                      EMITTER_ON;
   \                     ??Straight_19:
   \   000074   ........     CALLA   #?Subroutine1
     46                      stateCounter = 1;
     47                      strcpy(display_line[2], "          ");
     48                      display_changed = 1;
     49                      break;
   \                     ??CrossCallReturnLabel_9:
   \   000078   373C         JMP     ??Straight_16
     50          
     51                  case 1:
     52                      if(Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG1)) stateCounter++; // straight
     53                      break;
     54                      
     55                  case 2:
     56                      if(LockMotors(-1, -1)) stateCounter++;
     57                      break;
     58                      
     59                  case 3:
     60                    if(Drive_Path(rightTurn, leftTurn, TURN90)) stateCounter++;  // turn
     61                    break;
     62                  
     63                  case 4:
     64                      if(LockMotors(-rightTurn, -leftTurn)) stateCounter++;
     65                      break;
     66                      
     67                  case 5:
     68                      if(Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG2)) stateCounter++;// straight
   \                     ??Straight_14:
   \   00007A   3E40D007     MOV.W   #0x7d0, R14
   \   00007E   043C         JMP     ??Straight_9
     69                      break;
     70                      
     71                  case 6:
     72                      if(LockMotors(-1, -1)) stateCounter++;
     73                      break;
     74                      
     75                  case 7:
     76                      if(Drive_Path(rightTurn, leftTurn, TURN90)) stateCounter++; // turn
   \                     ??Straight_8:
   \   000080   3E402602     MOV.W   #0x226, R14
   \   000084   0D4F         MOV.W   R15, R13
   \   000086   0C4A         MOV.W   R10, R12
   \                     ??Straight_9:
   \   000088   ........     CALLA   #Drive_Path
   \   00008C   1C3C         JMP     ??Straight_2
     77                      break;
     78                  case 8:
     79                      if(LockMotors(-rightTurn, -leftTurn)) stateCounter++;
   \                     ??Straight_10:
   \   00008E   0D4E         MOV.W   R14, R13
   \   000090   0C4B         MOV.W   R11, R12
   \   000092   173C         JMP     ??Straight_1
     80                      break;
     81                      
     82                  case 9:
     83                      if ((ADC_Left_Detect > LEFT_WHITE_DETECT || ADC_Right_Detect > RIGHT_WHITE_DETECT)) {
   \                     ??Straight_20:
   \   000094   1992....     CMP.W   &ADC_Left_Detect, R9
   \   000098   0328         JNC     ??Straight_23
   \   00009A   1892....     CMP.W   &ADC_Right_Detect, R8
   \   00009E   152C         JC      ??Straight_3
     84                          Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 0);
   \                     ??Straight_23:
   \   0000A0   0E43         MOV.W   #0x0, R14
   \   0000A2   0A3C         JMP     ??Straight_17
     85                      }
     86                      else stateCounter++;
     87          
     88                      break;
     89                      
     90                  case 10:
     91                      if ((ADC_Left_Detect < LEFT_WHITE_DETECT || ADC_Right_Detect < RIGHT_WHITE_DETECT)) {
   \                     ??Straight_21:
   \   0000A4   8299....     CMP.W   R9, &ADC_Left_Detect
   \   0000A8   0328         JNC     ??Straight_24
   \   0000AA   8298....     CMP.W   R8, &ADC_Right_Detect
   \   0000AE   0D2C         JC      ??Straight_3
     92                          Drive_Path(RIGHT_MIN, RIGHT_MIN, 0);
   \                     ??Straight_24:
   \   0000B0   0E43         MOV.W   #0x0, R14
   \   0000B2   3D403421     MOV.W   #0x2134, R13
   \   0000B6   0C4D         MOV.W   R13, R12
   \                     ??Straight_17:
   \   0000B8   ........     CALLA   #Drive_Path
   \   0000BC   153C         JMP     ??Straight_16
     93                      }
     94                      else stateCounter++;
     95          
     96                      break;
     97          
     98                  case 11:
     99                      if(LockMotors(-1, -1)) stateCounter++;
   \                     ??Straight_0:
   \   0000BE   3D43         MOV.W   #0xffff, R13
   \   0000C0   3C43         MOV.W   #0xffff, R12
   \                     ??Straight_1:
   \   0000C2   ........     CALLA   #LockMotors
   \                     ??Straight_2:
   \   0000C6   0C93         CMP.W   #0x0, R12
   \   0000C8   0F24         JEQ     ??Straight_16
   \                     ??Straight_3:
   \   0000CA   9253....     ADD.W   #0x1, &stateCounter
   \   0000CE   0C3C         JMP     ??Straight_16
    100          
    101                      break;
    102          
    103                  case 12:
    104                      stateCounter = 0 ;
   \                     ??Straight_22:
   \   0000D0   ........     CALLA   #?Subroutine2
    105                      stopwatch_seconds = 0;
    106                      cycle_count = 0;
    107                      state = WAIT;
    108                      nextState = TURN;
   \                     ??CrossCallReturnLabel_0:
   \   0000D4   F2405400.... MOV.B   #0x54, &nextState
    109                      strcpy(display_line[2],"INTERCEPT ");
   \   0000DA   3D40....     MOV.W   #`?<Constant "INTERCEPT ">`, R13
   \   0000DE   ........     CALLA   #?Subroutine4
    110                      display_changed = 1;
    111                      EMITTER_OFF;
   \                     ??CrossCallReturnLabel_8:
   \   0000E2   F2C010004302 BIC.B   #0x10, &0x243
    112                      break;
    113              }
    114          }
   \                     ??Straight_16:
   \   0000E8   5617         POPM.W  #0x6, R11
   \   0000EA   1001         RETA
   \   0000EC                REQUIRE _A_PCOUT_L

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   F2D010004302 BIS.B   #0x10, &0x243
   \   000006   9243....     MOV.W   #0x1, &stateCounter
   \   00000A                REQUIRE ?Subroutine9
   \   00000A                REQUIRE ??Subroutine10_0
   \   00000A                // Fall through to label ??Subroutine10_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_6:
   \   000004                REQUIRE ?Subroutine9
   \   000004                // Fall through to label ?Subroutine9

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   D243....     MOV.B   #0x1, &display_changed
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_7:
   \   000004   ....         JMP     ?Subroutine9
   \   000006   0343         NOP

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   8243....     MOV.W   #0x0, &stateCounter
   \   000004   8243....     MOV.W   #0x0, &stopwatch_seconds
   \   000008   8243....     MOV.W   #0x0, &cycle_count
   \   00000C   F2405700.... MOV.B   #0x57, &state
   \   000012   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   3D40....     MOV.W   #`?<Constant "          ">`, R13
   \   000004                REQUIRE ?Subroutine8
   \   000004                // Fall through to label ?Subroutine8

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   3C40....     MOV.W   #display_line + 22, R12
   \   000004   ........     BRA     #strcpy
    115          

   \                                 In  segment CODE, align 2, keep-with-next
    116          void Turn(char direction) {
   \                     Turn:
    117              switch(stateCounter) {
   \   000000   1F42....     MOV.W   &stateCounter, R15
   \   000004   0F83         SUB.W   #0x0, R15
   \   000006   0724         JEQ     ??Turn_1
   \   000008   1F83         SUB.W   #0x1, R15
   \   00000A   0624         JEQ     ??Turn_2
   \   00000C   1F83         SUB.W   #0x1, R15
   \   00000E   1624         JEQ     ??Turn_3
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   3224         JEQ     ??Turn_4
   \   000014   1001         RETA
    118                  case 0:
    119                      EMITTER_ON;
   \                     ??Turn_1:
   \   000016   ....         JMP     ?Subroutine1
    120                      stateCounter = 1;
    121                      strcpy(display_line[2], "          ");
    122                      display_changed = 1;
    123                      break;
    124          
    125                  case 1: // gotta remove this
    126                    if(direction){
   \                     ??Turn_2:
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   3E406400     MOV.W   #0x64, R14
   \   00001E   0524         JEQ     ??Turn_5
    127                          if(Drive_Path(-RIGHT_MAX, LEFT_MAX, PRELIMINARY_TURN)) stateCounter++;
   \   000020   3D401027     MOV.W   #0x2710, R13
   \   000024   3C40F0D8     MOV.W   #0xd8f0, R12
   \   000028   043C         JMP     ??Turn_0
    128                    }else/* if(direction == MOVING_RIGHT)*/
    129                              if(Drive_Path(RIGHT_MAX, -LEFT_MAX, PRELIMINARY_TURN)) stateCounter++;
   \                     ??Turn_5:
   \   00002A   3D40F0D8     MOV.W   #0xd8f0, R13
   \   00002E   3C401027     MOV.W   #0x2710, R12
   \                     ??Turn_0:
   \   000032   ........     CALLA   #Drive_Path
   \   000036   0C93         CMP.W   #0x0, R12
   \   000038   2D24         JEQ     ??Turn_6
   \   00003A   ....         JMP     ?Subroutine0
    130          
    131                      break;
    132          
    133                  case 2:
    134                      if (((ADC_Left_Detect < LEFT_WHITE_DETECT || ADC_Right_Detect < RIGHT_WHITE_DETECT))) {
   \                     ??Turn_3:
   \   00003C   1F42....     MOV.W   &LWDetect, R15
   \   000040   3F501400     ADD.W   #0x14, R15
   \   000044   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000048   0728         JNC     ??Turn_7
   \   00004A   1F42....     MOV.W   &RWDetect, R15
   \   00004E   3F501400     ADD.W   #0x14, R15
   \   000052   829F....     CMP.W   R15, &ADC_Right_Detect
   \   000056   0F2C         JC      ??Turn_8
    135                          if(direction)Drive_Path(-RIGHT_MIN, LEFT_MIN, 0);
   \                     ??Turn_7:
   \   000058   4C93         CMP.B   #0x0, R12
   \   00005A   0E43         MOV.W   #0x0, R14
   \   00005C   0624         JEQ     ??Turn_9
   \   00005E   3D403421     MOV.W   #0x2134, R13
   \   000062   3C40CCDE     MOV.W   #0xdecc, R12
   \   000066   ........     BRA     #Drive_Path
    136          
    137                          else Drive_Path(RIGHT_MIN, -LEFT_MIN, 0);
   \                     ??Turn_9:
   \   00006A   3D40CCDE     MOV.W   #0xdecc, R13
   \   00006E   3C403421     MOV.W   #0x2134, R12
   \   000072   ........     BRA     #Drive_Path
    138                      } else stateCounter++;
   \                     ??Turn_8:
   \   000076   ....         JMP     ?Subroutine0
    139          
    140                      break;
    141          
    142                  case 3:
    143                      ShutoffMotors();
   \                     ??Turn_4:
   \   000078   ........     CALLA   #ShutoffMotors
    144                      stateCounter = 0 ;
   \   00007C   ........     CALLA   #?Subroutine2
    145                      stopwatch_seconds = 0;
    146                      cycle_count = 0;
    147                      state = WAIT;
    148                      nextState = LINEFOLLOW;
   \                     ??CrossCallReturnLabel_1:
   \   000080   F2404C00.... MOV.B   #0x4c, &nextState
    149                      EMITTER_OFF;
   \   000086   F2C010004302 BIC.B   #0x10, &0x243
    150                      strcpy(display_line[2],"   TURN   ");
   \   00008C   3D40....     MOV.W   #`?<Constant "   TURN   ">`, R13
   \   000090   ........     CALLA   #?Subroutine4
    151                      display_changed = 1;
    152                      break;
    153              }
    154          }
   \                     ??Turn_6:
   \   000094   1001         RETA
   \   000096                REQUIRE _A_PCOUT_L

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   9253....     ADD.W   #0x1, &stateCounter
   \   000004   1001         RETA
    155          

   \                                 In  segment CODE, align 2, keep-with-next
    156          void LineFollow() {
   \                     LineFollow:
   \   000000   3B15         PUSHM.W #0x4, R11
    157              //HEXtoBCD(ADC_Left_Detect, 1, 6);
    158              //HEXtoBCD(ADC_Right_Detect, 1, 0);
    159              
    160              int rFollowSpeed,lFollowSpeed;
    161          
    162              int leftPIDOut = GetOutput(&leftFollowController, LEFT_WHITE_DETECT, ADC_Left_Detect);
   \   000002   3A401400     MOV.W   #0x14, R10
   \   000006   1E42....     MOV.W   &ADC_Left_Detect, R14
   \   00000A   0D4A         MOV.W   R10, R13
   \   00000C   1D52....     ADD.W   &LWDetect, R13
   \   000010   3C40....     MOV.W   #leftFollowController, R12
   \   000014   ........     CALLA   #GetOutput
   \   000018   0B4C         MOV.W   R12, R11
   \   00001A   1E42....     MOV.W   &ADC_Right_Detect, R14
   \   00001E   0D4A         MOV.W   R10, R13
   \   000020   1D52....     ADD.W   &RWDetect, R13
   \   000024   3C40....     MOV.W   #rightFollowController, R12
    163              int rightPIDOut = GetOutput(&rightFollowController, RIGHT_WHITE_DETECT, ADC_Right_Detect);
   \   000028   ........     CALLA   #GetOutput
   \   00002C   084C         MOV.W   R12, R8
    164              rFollowSpeed = /*RIGHT_MIN>>1;//*/additionSafe(RIGHT_FORWARD_SPEED, RIGHT_MAX, RIGHT_MIN >> 1, leftPIDOut); // swapped b/c they are physically swapped
                                                    ^
Warning[Pe009]: nested comment is not allowed
   \   00002E   0F4B         MOV.W   R11, R15
   \   000030   3E409A10     MOV.W   #0x109a, R14
   \   000034   3D401027     MOV.W   #0x2710, R13
   \   000038   1C425404     MOV.W   &0x454, R12
   \   00003C   ........     CALLA   #additionSafe
   \   000040   0B4C         MOV.W   R12, R11
    165              lFollowSpeed = /*LEFT_MIN>>1;//*/additionSafe(LEFT_FORWARD_SPEED, LEFT_MAX, LEFT_MIN >> 1, rightPIDOut); // swapped b/c they are physically swapped
                                                   ^
Warning[Pe009]: nested comment is not allowed
   \   000042   0F48         MOV.W   R8, R15
   \   000044   3E409A10     MOV.W   #0x109a, R14
   \   000048   3D401027     MOV.W   #0x2710, R13
   \   00004C   1C425604     MOV.W   &0x456, R12
   \   000050   ........     CALLA   #additionSafe
   \   000054   084C         MOV.W   R12, R8
    166          
    167              switch(stateCounter) {
   \   000056   0F4A         MOV.W   R10, R15
   \   000058   1F52....     ADD.W   &LWDetect, R15
   \   00005C   1A52....     ADD.W   &RWDetect, R10
   \   000060   1E42....     MOV.W   &stateCounter, R14
   \   000064   0E83         SUB.W   #0x0, R14
   \   000066   0B24         JEQ     ??LineFollow_12
   \   000068   1E83         SUB.W   #0x1, R14
   \   00006A   1924         JEQ     ??LineFollow_13
   \   00006C   1E83         SUB.W   #0x1, R14
   \   00006E   4C24         JEQ     ??LineFollow_14
   \   000070   1E83         SUB.W   #0x1, R14
   \   000072   5724         JEQ     ??LineFollow_15
   \   000074   1E83         SUB.W   #0x1, R14
   \   000076   6924         JEQ     ??LineFollow_16
   \   000078   1E83         SUB.W   #0x1, R14
   \   00007A   8624         JEQ     ??LineFollow_17
   \   00007C   8C3C         JMP     ??LineFollow_1
    168                  case 0:
    169                      EMITTER_ON;
   \                     ??LineFollow_12:
   \   00007E   F2D010004302 BIS.B   #0x10, &0x243
    170                      stopwatch_seconds = 0;
   \   000084   ........     CALLA   #?Subroutine6
    171                      cycle_count = 0;
    172                      strcpy(display_line[2],"          ");
   \                     ??CrossCallReturnLabel_4:
   \   000088   ........     CALLA   #??Subroutine10_0
    173                      display_changed = 1;
    174                      if(rightSwitchable && leftSwitchable)stateCounter++;
   \                     ??CrossCallReturnLabel_10:
   \   00008C   8293....     CMP.W   #0x0, &rightSwitchable
   \   000090   8224         JEQ     ??LineFollow_1
   \   000092   8293....     CMP.W   #0x0, &leftSwitchable
   \   000096   7F24         JEQ     ??LineFollow_1
   \   000098   9253....     ADD.W   #0x1, &stateCounter
    175                      else return;
    176          
    177                      break;
   \   00009C   7C3C         JMP     ??LineFollow_1
    178          
    179                  case 1:
    180                      if(ADC_Left_Detect < (LEFT_WHITE_DETECT) ^ ADC_Right_Detect < (RIGHT_WHITE_DETECT)) stateCounter = 2;
                             ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \                     ??LineFollow_13:
   \   00009E   829F....     CMP.W   R15, &ADC_Left_Detect
   \   0000A2   4E7E         SUBC.B  R14, R14
   \   0000A4   5EF3         AND.B   #0x1, R14
   \   0000A6   829A....     CMP.W   R10, &ADC_Right_Detect
   \   0000AA   012C         JC      ??LineFollow_0
   \   0000AC   5EE3         XOR.B   #0x1, R14
   \                     ??LineFollow_0:
   \   0000AE   4E93         CMP.B   #0x0, R14
   \   0000B0   0324         JEQ     ??LineFollow_18
   \   0000B2   A243....     MOV.W   #0x2, &stateCounter
   \   0000B6   123C         JMP     ??LineFollow_11
    181                      else if (ADC_Left_Detect < (LEFT_WHITE_DETECT) && ADC_Right_Detect < (RIGHT_WHITE_DETECT)) {
   \                     ??LineFollow_18:
   \   0000B8   829F....     CMP.W   R15, &ADC_Left_Detect
   \   0000BC   072C         JC      ??LineFollow_19
   \   0000BE   829A....     CMP.W   R10, &ADC_Right_Detect
   \   0000C2   042C         JC      ??LineFollow_19
    182                          rFollowSpeed = -RIGHT_MIN;
   \   0000C4   3B40CCDE     MOV.W   #0xdecc, R11
    183                          lFollowSpeed = -LEFT_MIN;
   \   0000C8   084B         MOV.W   R11, R8
   \   0000CA   083C         JMP     ??LineFollow_11
    184                      } else {
    185                          ClearController(&rightFollowController);
   \                     ??LineFollow_19:
   \   0000CC   3C40....     MOV.W   #rightFollowController, R12
   \   0000D0   ........     CALLA   #ClearController
    186                          ClearController(&leftFollowController);
   \   0000D4   3C40....     MOV.W   #leftFollowController, R12
   \   0000D8   ........     CALLA   #ClearController
    187                      }
    188          
    189                      if(delay(CIRCLING_TIME, 0))  stateCounter = 5;
   \                     ??LineFollow_11:
   \   0000DC   0D43         MOV.W   #0x0, R13
   \   0000DE   3C404600     MOV.W   #0x46, R12
   \   0000E2   ........     CALLA   #delay
   \   0000E6   0C93         CMP.W   #0x0, R12
   \   0000E8   0324         JEQ     ??LineFollow_20
   \   0000EA   B2400500.... MOV.W   #0x5, &stateCounter
    190                      if(stopwatch_seconds>=TIME_TO_CIRCLE) strcpy(display_line[2]," CIRCLING ");
   \                     ??LineFollow_20:
   \   0000F0   B2900300.... CMP.W   #0x3, &stopwatch_seconds
   \   0000F6   0428         JNC     ??LineFollow_21
   \   0000F8   3D40....     MOV.W   #`?<Constant " CIRCLING ">`, R13
   \   0000FC   ........     CALLA   #?Subroutine8
    191          
    192                      Drive_Path(rFollowSpeed, lFollowSpeed,0);
   \                     ??LineFollow_21:
   \   000100   0E43         MOV.W   #0x0, R14
   \   000102   0D48         MOV.W   R8, R13
   \   000104   0C4B         MOV.W   R11, R12
   \   000106   293C         JMP     ??LineFollow_3
    193                      break;
    194          
    195          
    196                  case 2:
    197                      if(ADC_Left_Detect < LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 3;
   \                     ??LineFollow_14:
   \   000108   829F....     CMP.W   R15, &ADC_Left_Detect
   \   00010C   032C         JC      ??LineFollow_22
   \   00010E   829A....     CMP.W   R10, &ADC_Right_Detect
   \   000112   362C         JC      ??LineFollow_23
    198                      else if(ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect < RIGHT_WHITE_DETECT) stateCounter = 4;
   \                     ??LineFollow_22:
   \   000114   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000118   3028         JNC     ??LineFollow_24
   \   00011A   829A....     CMP.W   R10, &ADC_Right_Detect
   \   00011E   1028         JNC     ??LineFollow_9
   \   000120   283C         JMP     ??LineFollow_7
    199                      else stateCounter = 1;
    200          
    201                      break;
    202          
    203                  case 3:// turn left ()
    204                      if(ADC_Left_Detect < LEFT_WHITE_DETECT) Drive_Path((RIGHT_MIN - LF_TURN_DECREMENT), -(LEFT_MIN - LF_TURN_DECREMENT), 0);
   \                     ??LineFollow_15:
   \   000122   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000126   062C         JC      ??LineFollow_25
   \   000128   0E43         MOV.W   #0x0, R14
   \   00012A   3D4084EA     MOV.W   #0xea84, R13
   \   00012E   3C407C15     MOV.W   #0x157c, R12
   \   000132   133C         JMP     ??LineFollow_3
    205                      else if (ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 1;
   \                     ??LineFollow_25:
   \   000134   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000138   0528         JNC     ??LineFollow_26
   \   00013A   829A....     CMP.W   R10, &ADC_Right_Detect
   \   00013E   192C         JC      ??LineFollow_7
   \                     ??LineFollow_9:
   \   000140   2F42         MOV.W   #0x4, R15
   \   000142   183C         JMP     ??LineFollow_4
    206                      else stateCounter = 4;
   \                     ??LineFollow_26:
   \   000144   A242....     MOV.W   #0x4, &stateCounter
   \   000148   263C         JMP     ??LineFollow_1
    207          
    208                      break;
    209          
    210                  case 4:
    211                      if(ADC_Right_Detect < RIGHT_WHITE_DETECT) Drive_Path(-(RIGHT_MIN - LF_TURN_DECREMENT), (LEFT_MIN - LF_TURN_DECREMENT), 0);
   \                     ??LineFollow_16:
   \   00014A   829A....     CMP.W   R10, &ADC_Right_Detect
   \   00014E   082C         JC      ??LineFollow_27
   \   000150   0E43         MOV.W   #0x0, R14
   \   000152   3D407C15     MOV.W   #0x157c, R13
   \   000156   3C4084EA     MOV.W   #0xea84, R12
   \                     ??LineFollow_3:
   \   00015A   ........     CALLA   #Drive_Path
   \   00015E   1B3C         JMP     ??LineFollow_1
    212                      else if (ADC_Left_Detect >= LEFT_WHITE_DETECT && ADC_Right_Detect >= RIGHT_WHITE_DETECT) stateCounter = 1;
   \                     ??LineFollow_27:
   \   000160   829F....     CMP.W   R15, &ADC_Left_Detect
   \   000164   0D28         JNC     ??LineFollow_23
   \   000166   829A....     CMP.W   R10, &ADC_Right_Detect
   \   00016A   032C         JC      ??LineFollow_7
   \   00016C   3F400300     MOV.W   #0x3, R15
   \   000170   013C         JMP     ??LineFollow_4
   \                     ??LineFollow_7:
   \   000172   1F43         MOV.W   #0x1, R15
   \                     ??LineFollow_4:
   \   000174   824F....     MOV.W   R15, &stateCounter
   \   000178   0E3C         JMP     ??LineFollow_1
   \                     ??LineFollow_24:
   \   00017A   9243....     MOV.W   #0x1, &stateCounter
   \   00017E   0B3C         JMP     ??LineFollow_1
    213                      else stateCounter = 3;
   \                     ??LineFollow_23:
   \   000180   B2400300.... MOV.W   #0x3, &stateCounter
   \   000186   073C         JMP     ??LineFollow_1
    214          
    215                      break;
    216          
    217                  //case 10:
    218                  //    if(LockMotorsTime(-1, -1, 1)) stateCounter = 2;
    219                  //    break;
    220          
    221                  case 5:
    222                      ShutoffMotors();
   \                     ??LineFollow_17:
   \   000188   ........     CALLA   #?Subroutine3
    223                      stateCounter = 0 ;
    224                      state = START;
    225                      EMITTER_OFF;
   \                     ??CrossCallReturnLabel_2:
   \   00018C   F2C010004302 BIC.B   #0x10, &0x243
    226                      strcpy(display_line[2],"          ");
   \   000192   ........     CALLA   #?Subroutine7
    227                      break;
    228              }
    229          
    230          
    231          }
   \                     ??LineFollow_1:
   \   000196   3817         POPM.W  #0x4, R11
   \   000198   1001         RETA
   \   00019A                REQUIRE _A_TB3CCR1_L
   \   00019A                REQUIRE _A_TB3CCR2_L
   \   00019A                REQUIRE _A_PCOUT_L

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   ........     CALLA   #ShutoffMotors
   \   000004   8243....     MOV.W   #0x0, &stateCounter
   \   000008   F2405300.... MOV.B   #0x53, &state
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   8243....     MOV.W   #0x0, &stopwatch_seconds
   \   000004   8243....     MOV.W   #0x0, &cycle_count
   \   000008   1001         RETA
    232          

   \                                 In  segment CODE, align 2, keep-with-next
    233          void Exit(int direction) {
   \                     Exit:
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    234              if (stateCounter == 0) {
   \   000004   8293....     CMP.W   #0x0, &stateCounter
   \   000008   0820         JNE     ??Exit_7
    235                  if(rightSwitchable && leftSwitchable)stateCounter++;
   \   00000A   8293....     CMP.W   #0x0, &rightSwitchable
   \   00000E   0524         JEQ     ??Exit_7
   \   000010   8293....     CMP.W   #0x0, &leftSwitchable
   \   000014   0224         JEQ     ??Exit_7
   \   000016   9253....     ADD.W   #0x1, &stateCounter
    236              }
    237          
    238              if (stateCounter == 1) {
   \                     ??Exit_7:
   \   00001A   9293....     CMP.W   #0x1, &stateCounter
   \   00001E   0F20         JNE     ??Exit_0
    239                  if(direction) {
   \   000020   0C93         CMP.W   #0x0, R12
   \   000022   3E402602     MOV.W   #0x226, R14
   \   000026   0524         JEQ     ??Exit_8
    240                      if(Drive_Path(-STRAIGHT_RIGHT, STRAIGHT_LEFT, TURN90)) stateCounter++;
   \   000028   3D40803E     MOV.W   #0x3e80, R13
   \   00002C   3C40E0B1     MOV.W   #0xb1e0, R12
   \   000030   043C         JMP     ??Exit_4
    241                  } else {
    242                      if(Drive_Path(STRAIGHT_RIGHT, -STRAIGHT_LEFT, TURN90)) stateCounter++;
   \                     ??Exit_8:
   \   000032   3D4080C1     MOV.W   #0xc180, R13
   \   000036   3C40204E     MOV.W   #0x4e20, R12
    243                  }
    244              }
   \                     ??Exit_4:
   \   00003A   ........     CALLA   #?Subroutine5
    245          
    246              if (stateCounter == 2) {
   \                     ??Exit_0:
   \   00003E   A293....     CMP.W   #0x2, &stateCounter
   \   000042   0D20         JNE     ??Exit_9
    247                  if(direction) {
   \   000044   0A93         CMP.W   #0x0, R10
   \   000046   0324         JEQ     ??Exit_10
    248                    if(LockMotors(1, -1)) stateCounter++;  
   \   000048   3D43         MOV.W   #0xffff, R13
   \   00004A   1C43         MOV.W   #0x1, R12
   \   00004C   023C         JMP     ??Exit_5
    249                  } else {
    250                      if(LockMotors(-1, 1)) stateCounter++;
   \                     ??Exit_10:
   \   00004E   1D43         MOV.W   #0x1, R13
   \   000050   3C43         MOV.W   #0xffff, R12
   \                     ??Exit_5:
   \   000052   ........     CALLA   #LockMotors
   \   000056   0C93         CMP.W   #0x0, R12
   \   000058   0224         JEQ     ??Exit_9
   \   00005A   9253....     ADD.W   #0x1, &stateCounter
    251                  }
    252              }
    253          
    254              if (stateCounter == 3) {
   \                     ??Exit_9:
   \   00005E   B2900300.... CMP.W   #0x3, &stateCounter
   \   000064   0820         JNE     ??Exit_1
    255                  if(Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 5000)) stateCounter++;
   \   000066   3E408813     MOV.W   #0x1388, R14
   \   00006A   3D40803E     MOV.W   #0x3e80, R13
   \   00006E   3C40204E     MOV.W   #0x4e20, R12
   \   000072   ........     CALLA   #?Subroutine5
    256              }
    257          
    258              if (stateCounter == 4) {
   \                     ??Exit_1:
   \   000076   A292....     CMP.W   #0x4, &stateCounter
   \   00007A   0920         JNE     ??Exit_11
    259                  if(LockMotors(-1, -1)) stateCounter++;
   \   00007C   3D43         MOV.W   #0xffff, R13
   \   00007E   3C43         MOV.W   #0xffff, R12
   \   000080   ........     CALLA   #LockMotors
   \   000084   0C93         CMP.W   #0x0, R12
   \   000086   0B24         JEQ     ??Exit_6
   \   000088   9253....     ADD.W   #0x1, &stateCounter
   \   00008C   083C         JMP     ??Exit_6
    260              }
    261          
    262              else if (stateCounter == 5) {
   \                     ??Exit_11:
   \   00008E   B2900500.... CMP.W   #0x5, &stateCounter
   \   000094   0420         JNE     ??Exit_6
    263                  ShutoffMotors();
   \   000096   ........     CALLA   #?Subroutine3
    264                  stateCounter = 0 ;
    265                  state = START;
    266                  stopwatch_seconds = 0;
   \                     ??CrossCallReturnLabel_3:
   \   00009A   ........     CALLA   #?Subroutine6
    267                  cycle_count = 0;
    268              }
    269          }
   \                     ??Exit_6:
   \   00009E   3A41         POP.W   R10
   \   0000A0   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   ........     CALLA   #Drive_Path
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0224         JEQ     ??Exit_2
   \   000008   9253....     ADD.W   #0x1, &stateCounter
   \                     ??Exit_2:
   \   00000C   1001         RETA
    270          

   \                                 In  segment CODE, align 2, keep-with-next
    271          void Drive(int polR, int polL, unsigned int time) {
   \                     Drive:
    272              switch(stateCounter) {
   \   000000   1F42....     MOV.W   &stateCounter, R15
   \   000004   0F83         SUB.W   #0x0, R15
   \   000006   0724         JEQ     ??Drive_3
   \   000008   1F83         SUB.W   #0x1, R15
   \   00000A   0624         JEQ     ??Drive_4
   \   00000C   1F83         SUB.W   #0x1, R15
   \   00000E   1524         JEQ     ??Drive_5
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   1C24         JEQ     ??Drive_6
   \   000014   1001         RETA
    273          
    274                  case 0 :
    275                      stateCounter++;
   \                     ??Drive_3:
   \   000016   ....         JMP     ?Subroutine0
    276                      break;
    277          
    278                  case 1 :
    279                    if(Drive_Path(polR>0?STRAIGHT_RIGHT:-STRAIGHT_RIGHT, polL>0?STRAIGHT_LEFT:-STRAIGHT_LEFT, time))stateCounter++;
   \                     ??Drive_4:
   \   000018   1D93         CMP.W   #0x1, R13
   \   00001A   0334         JGE     ??Drive_7
   \   00001C   3D4080C1     MOV.W   #0xc180, R13
   \   000020   023C         JMP     ??Drive_0
   \                     ??Drive_7:
   \   000022   3D40803E     MOV.W   #0x3e80, R13
   \                     ??Drive_0:
   \   000026   1C93         CMP.W   #0x1, R12
   \   000028   0334         JGE     ??Drive_8
   \   00002A   3C40E0B1     MOV.W   #0xb1e0, R12
   \   00002E   023C         JMP     ??Drive_1
   \                     ??Drive_8:
   \   000030   3C40204E     MOV.W   #0x4e20, R12
   \                     ??Drive_1:
   \   000034   ........     CALLA   #Drive_Path
   \   000038   063C         JMP     ??Drive_2
    280          
    281                      break;
    282          
    283                  case 2 :
    284                      if(LockMotors(-polR, -polL)) stateCounter++;
   \                     ??Drive_5:
   \   00003A   3DE3         XOR.W   #0xffff, R13
   \   00003C   1D53         ADD.W   #0x1, R13
   \   00003E   3CE3         XOR.W   #0xffff, R12
   \   000040   1C53         ADD.W   #0x1, R12
   \   000042   ........     CALLA   #LockMotors
   \                     ??Drive_2:
   \   000046   0C93         CMP.W   #0x0, R12
   \   000048   0324         JEQ     ??Drive_9
   \   00004A   ....         JMP     ?Subroutine0
    285          
    286                      break;
    287          
    288                  case 3 :
    289                      ShutoffMotors();
   \                     ??Drive_6:
   \   00004C   ........     CALLA   #?Subroutine3
    290                      stateCounter = 0 ;
    291                      state = START;
    292                      break;
    293              }
    294          }
   \                     ??Drive_9:
   \   000050   1001         RETA
    295          
    296          
    297          
    298          // delays for a specified time make sure stopwatch_seconds and cycle_count are 0 before calling

   \                                 In  segment CODE, align 2
    299          int delay(int seconds, int cycles) {
   \                     delay:
    300              if(stopwatch_seconds == 0 && cycle_count <= 1) {
   \   000000   8293....     CMP.W   #0x0, &stopwatch_seconds
   \   000004   0520         JNE     ??delay_0
   \   000006   A293....     CMP.W   #0x2, &cycle_count
   \   00000A   022C         JC      ??delay_0
    301                  display_changed = 1;
   \   00000C   D243....     MOV.B   #0x1, &display_changed
    302              }
    303          
    304              if(stopwatch_seconds >= seconds && cycle_count >= cycles) {
   \                     ??delay_0:
   \   000010   829C....     CMP.W   R12, &stopwatch_seconds
   \   000014   0728         JNC     ??delay_1
   \   000016   829D....     CMP.W   R13, &cycle_count
   \   00001A   0428         JNC     ??delay_1
    305                  stopwatch_seconds = 0;
   \   00001C   ........     CALLA   #?Subroutine6
    306                  cycle_count = 0;
    307                  return 1;
   \                     ??CrossCallReturnLabel_5:
   \   000020   1C43         MOV.W   #0x1, R12
   \   000022   1001         RETA
    308              } else return 0;
   \                     ??delay_1:
   \   000024   0C43         MOV.W   #0x0, R12
   \   000026   1001         RETA
    309          }
    310          
    311          
    312          
    313          
    314          

   \                                 In  segment CODE, align 2
    315          void StateMachine(void) {
   \                     StateMachine:
    316            
    317              switch(state) {
   \   000000   1C42....     MOV.W   &polarityRight, R12
   \   000004   5E42....     MOV.B   &state, R14
   \   000008   7E804300     SUB.B   #0x43, R14
   \   00000C   1324         JEQ     ??StateMachine_0
   \   00000E   5E83         SUB.B   #0x1, R14
   \   000010   2724         JEQ     ??StateMachine_1
   \   000012   7E82         SUB.B   #0x8, R14
   \   000014   2124         JEQ     ??StateMachine_2
   \   000016   7E800700     SUB.B   #0x7, R14
   \   00001A   0E24         JEQ     ??StateMachine_3
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   1A24         JEQ     ??StateMachine_4
   \   000020   7E800300     SUB.B   #0x3, R14
   \   000024   0A24         JEQ     ??StateMachine_5
   \   000026   7E800E00     SUB.B   #0xe, R14
   \   00002A   1824         JEQ     ??StateMachine_6
   \   00002C   7E800E00     SUB.B   #0xe, R14
   \   000030   0F24         JEQ     ??StateMachine_7
   \   000032   1001         RETA
    318                  case (CALIBRATE):
    319                      calibrate();
   \                     ??StateMachine_0:
   \   000034   ........     BRA     #calibrate
    320          
    321                      /*if(calibrationMode >= 2) {
    322                          state = START;
    323                      }*/
    324          
    325                      break;
    326          
    327                  case (START):
    328                      stopwatch_seconds = 0;
   \                     ??StateMachine_3:
   \   000038   ....         JMP     ?Subroutine6
    329                      cycle_count = 0;
    330                      break;
    331          
    332                  case (WAIT):
    333                      //strcpy(display_line[0], "WAITING...");
    334          
    335                      if (delay(delayTime, 0)) state = nextState;
   \                     ??StateMachine_5:
   \   00003A   0D43         MOV.W   #0x0, R13
   \   00003C   1C42....     MOV.W   &delayTime, R12
   \   000040   ........     CALLA   #delay
   \   000044   0C93         CMP.W   #0x0, R12
   \   000046   1224         JEQ     ??StateMachine_8
   \   000048   D242........ MOV.B   &nextState, &state
   \   00004E   1001         RETA
    336          
    337                      break;
    338          
    339                  case (STRAIGHT):
    340                      Straight(polarityRight);
   \                     ??StateMachine_7:
   \   000050   ........     BRA     #Straight
    341                      break;
    342          
    343                  case (TURN):
    344                      Turn(polarityRight);
   \                     ??StateMachine_4:
   \   000054   ........     BRA     #Turn
    345                      break;
    346          
    347                  case (LINEFOLLOW):
    348                      LineFollow();
   \                     ??StateMachine_2:
   \   000058   ........     BRA     #LineFollow
    349                      break;
    350                      
    351                  case (EXIT):
    352                      Exit(polarityRight);
   \                     ??StateMachine_6:
   \   00005C   ........     BRA     #Exit
    353                      break;
    354                      
    355                  case (DRIVE):
    356                      Drive(polarityRight, polarityLeft, driveTime);
   \                     ??StateMachine_1:
   \   000060   1E42....     MOV.W   &driveTime, R14
   \   000064   1D42....     MOV.W   &polarityLeft, R13
   \   000068   ........     CALLA   #Drive
    357                      break;
    358          
    359                  default:
    360                      break;
    361              }
    362          }
   \                     ??StateMachine_8:
   \   00006C   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for state>`:
   \   000000   53           DC8 83

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for nextState>`:
   \   000000   73           DC8 115

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delayTime>`:
   \   000000   0100         DC16 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for enteringDirection>`:
   \   000000   4E           DC8 78

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "          ">`:
   \   000000   202020202020 DC8 "          "
   \            2020202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "INTERCEPT ">`:
   \   000000   494E54455243 DC8 "INTERCEPT "
   \            4550542000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "   TURN   ">`:
   \   000000   202020545552 DC8 "   TURN   "
   \            4E20202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " CIRCLING ">`:
   \   000000   20434952434C DC8 " CIRCLING "
   \            494E472000  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Drive
        4   -> Drive_Path
        4   -> LockMotors
        8   -> ShutoffMotors
      6   Exit
       10   -> Drive_Path
        6   -> LockMotors
       10   -> ShutoffMotors
     12   LineFollow
       12   -> ClearController
       12   -> Drive_Path
       12   -> GetOutput
       16   -> ShutoffMotors
       12   -> additionSafe
       12   -> delay
       12   -> strcpy
       16   -> strcpy
      4   StateMachine
        4   -> Drive
        0   -> Exit
        0   -> LineFollow
        0   -> Straight
        0   -> Turn
        0   -> calibrate
        4   -> delay
     16   Straight
       16   -> Drive_Path
       16   -> LockMotors
       20   -> strcpy
      4   Turn
        0   -> Drive_Path
        4   -> Drive_Path
        4   -> ShutoffMotors
        4   -> strcpy
        8   -> strcpy
      4   delay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "          ">
      11  ?<Constant "   TURN   ">
      11  ?<Constant " CIRCLING ">
      11  ?<Constant "INTERCEPT ">
       2  ?<Initializer for delayTime>
       1  ?<Initializer for enteringDirection>
       1  ?<Initializer for nextState>
       1  ?<Initializer for state>
       4  ??Subroutine10_0
       6  ?Subroutine0
      10  ?Subroutine1
      20  ?Subroutine2
      16  ?Subroutine3
       8  ?Subroutine4
      14  ?Subroutine5
      10  ?Subroutine6
       4  ?Subroutine7
       8  ?Subroutine8
       6  ?Subroutine9
      82  Drive
     162  Exit
     410  LineFollow
     110  StateMachine
     236  Straight
     150  Turn
       2  _A_PCOUT_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
      40  delay
       2  delayTime
       2  driveTime
       1  enteringDirection
       1  nextState
       2  polarityLeft
       2  polarityRight
       1  state
       2  stateCounter

 
 1 296 bytes in segment CODE
     6 bytes in segment DATA16_AN
    44 bytes in segment DATA16_C
     5 bytes in segment DATA16_I
     5 bytes in segment DATA16_ID
     8 bytes in segment DATA16_Z
 
 1 296 bytes of CODE  memory
    49 bytes of CONST memory
    13 bytes of DATA  memory (+ 6 bytes shared)

Errors: none
Warnings: 3
