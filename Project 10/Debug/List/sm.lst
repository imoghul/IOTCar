###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          25/Apr/2022  16:03:38
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\test\Project 10\sm.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWFCDD.tmp
#        ("C:\Users\saad\Documents\test\Project 10\sm.c" -lC
#        "C:\Users\saad\Documents\test\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\test\Project 10\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  C:\Users\saad\Documents\test\Project 10\Debug\List\sm.lst
#    Object file   =  C:\Users\saad\Documents\test\Project 10\Debug\Obj\sm.r43
#
###############################################################################

C:\Users\saad\Documents\test\Project 10\sm.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2
      2          #include "ports.h"
      3          #include "wheels.h"
      4          #include "sm.h"
      5          #include <string.h>
      6          #include "adc.h"
      7          #include "timers.h"
      8          #include "macros.h"
      9          #include "detectors.h"
     10          #include "pid.h"
     11          
     12          extern volatile unsigned int cycle_count;
     13          extern volatile unsigned int stopwatch_milliseconds;
     14          extern volatile unsigned int stopwatch_seconds;
     15          extern volatile unsigned char display_changed;
     16          extern char display_line[4][11];
     17          extern volatile unsigned int wheel_periods;

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     18          volatile char state = START;
   \                     state:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for state>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile int stateCounter, driveStateCounter;
   \                     stateCounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     driveStateCounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     20          volatile char nextState = STRAIGHT;
   \                     nextState:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for nextState>`
     21          extern volatile unsigned int Time_Sequence;
     22          extern volatile unsigned int Last_Time_Sequence;
     23          extern volatile unsigned int time_change;

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     24          volatile unsigned int delayTime = DELAY_BETWEEN_EVENTS;
   \                     delayTime:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for delayTime>`
     25          extern volatile unsigned int ADC_Left_Detect, ADC_Right_Detect;
     26          extern volatile unsigned int rightSwitchable, leftSwitchable;
     27          extern unsigned int temp;
     28          extern char movingDirection;

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     29          char enteringDirection = NOT_MOVING;
   \                     enteringDirection:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for enteringDirection>`
     30          extern int leftVals[VALUES_TO_HOLD];
     31          extern int rightVals[VALUES_TO_HOLD];
     32          extern volatile unsigned int calibrationMode;
     33          extern unsigned int LBDetect, LWDetect, RBDetect, RWDetect;
     34          extern PIDController rightFollowController, rightAdjustController;
     35          extern PIDController leftFollowController, leftAdjustController;
     36          
     37          extern short l_LessBlack, l_LessGray, l_LessWhite, r_LessBlack, r_LessGray, r_LessWhite, l_GreaterBlack, l_GreaterGray, l_GreaterWhite, r_GreaterBlack, r_GreaterGray, r_GreaterWhite, lessWhiteOr, lessWhiteAnd, greaterWhiteOr, greaterWhiteAnd, lessWhiteOr, lessWhiteAnd, greaterWhiteOr, greaterWhiteAnd, lessGrayOr, lessGrayAnd, greaterGrayOr, greaterGrayAnd, lessGrayOr, lessGrayAnd, greaterGrayOr, greaterGrayAnd, lessBlackOr, lessBlackAnd, greaterBlackOr, greaterBlackAnd, lessBlackOr, lessBlackAnd, greaterBlackOr, greaterBlackAnd;
     38          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     39          int speedRight, speedLeft;
   \                     speedRight:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     speedLeft:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     40          unsigned int driveTime;
   \                     driveTime:
   \   000000                DS8 2
     41          
     42          
     43          //===========================================================================
     44          // Function name: Straight
     45          //
     46          // Description: This function is used to increcept the black line as such:
     47          //
     48          //           --------------->|
     49          //           ^               |
     50          //           |               v
     51          //           |          black line
     52          //           |
     53          //
     54          // Passed : no variables passed
     55          // Locals: rightTurn,leftTurn
     56          // Returned: no values returned
     57          // Globals: stateCounter,display_line,display_changed,lessWhiteOr,
     58          // stopwatch_seconds,cycle_count,state,nextState
     59          //
     60          // Author: Ibrahim Moghul
     61          // Date: Apr 2022
     62          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     63          //===========================================================================
     64          

   \                                 In  segment CODE, align 2
     65          void Straight(char direction) {
   \                     Straight:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
     66              int rightTurn;// = direction ? STRAIGHT_RIGHT : -STRAIGHT_RIGHT;
     67              int leftTurn;// = direction ? -STRAIGHT_LEFT : STRAIGHT_LEFT;
     68              if(direction){
   \   000004   4A93         CMP.B   #0x0, R10
   \   000006   0524         JEQ     ??Straight_9
     69                rightTurn = STRAIGHT_RIGHT;
   \   000008   3B405046     MOV.W   #0x4650, R11
     70                leftTurn = -STRAIGHT_LEFT;
   \   00000C   3840E0B1     MOV.W   #0xb1e0, R8
   \   000010   043C         JMP     ??Straight_8
     71              }else {
     72                rightTurn = -STRAIGHT_RIGHT;
   \                     ??Straight_9:
   \   000012   3B40B0B9     MOV.W   #0xb9b0, R11
     73                leftTurn = STRAIGHT_LEFT;
   \   000016   3840204E     MOV.W   #0x4e20, R8
     74              }
     75          
     76              switch(stateCounter) {
   \                     ??Straight_8:
   \   00001A   1F42....     MOV.W   &stateCounter, R15
   \   00001E   0F83         SUB.W   #0x0, R15
   \   000020   1124         JEQ     ??Straight_10
   \   000022   1F83         SUB.W   #0x1, R15
   \   000024   1A24         JEQ     ??Straight_11
   \   000026   1F83         SUB.W   #0x1, R15
   \   000028   2524         JEQ     ??Straight_12
   \   00002A   1F83         SUB.W   #0x1, R15
   \   00002C   2E24         JEQ     ??Straight_13
   \   00002E   1F83         SUB.W   #0x1, R15
   \   000030   3924         JEQ     ??Straight_14
   \   000032   1F83         SUB.W   #0x1, R15
   \   000034   4224         JEQ     ??Straight_15
   \   000036   1F83         SUB.W   #0x1, R15
   \   000038   4D24         JEQ     ??Straight_16
   \   00003A   1F83         SUB.W   #0x1, R15
   \   00003C   5C24         JEQ     ??Straight_17
   \   00003E   1F83         SUB.W   #0x1, R15
   \   000040   6524         JEQ     ??Straight_18
   \   000042   7B3C         JMP     ??Straight_1
     77                  case 0:
     78                      stateCounter++;
   \                     ??Straight_10:
   \   000044   9253....     ADD.W   #0x1, &stateCounter
     79                      strcpy(LINE1, " BL START ");
   \   000048   3D40....     MOV.W   #`?<Constant " BL START ">`, R13
   \   00004C   3C40....     MOV.W   #display_line, R12
   \   000050   ........     CALLA   #strcpy
     80                      display_changed = true;
   \   000054   D243....     MOV.B   #0x1, &display_changed
     81                      break;
   \   000058   703C         JMP     ??Straight_1
     82          
     83                  case 1:
     84                      if(Drive(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG1))stateCounter++;
   \                     ??Straight_11:
   \   00005A   3E40C409     MOV.W   #0x9c4, R14
   \   00005E   3D40204E     MOV.W   #0x4e20, R13
   \   000062   3C405046     MOV.W   #0x4650, R12
   \   000066   ........     CALLA   #Drive
   \   00006A   0C93         CMP.W   #0x0, R12
   \   00006C   6624         JEQ     ??Straight_1
   \   00006E   9253....     ADD.W   #0x1, &stateCounter
     85          
     86                      break;
   \   000072   633C         JMP     ??Straight_1
     87          
     88                  case 2:
     89                      if(Drive(rightTurn, leftTurn, TURN90))stateCounter++;
   \                     ??Straight_12:
   \   000074   3E40CC01     MOV.W   #0x1cc, R14
   \   000078   0D48         MOV.W   R8, R13
   \   00007A   0C4B         MOV.W   R11, R12
   \   00007C   ........     CALLA   #Drive
   \   000080   0C93         CMP.W   #0x0, R12
   \   000082   5B24         JEQ     ??Straight_1
   \   000084   9253....     ADD.W   #0x1, &stateCounter
     90          
     91                      break;
   \   000088   583C         JMP     ??Straight_1
     92          
     93                  case 3:
     94                      if(Drive(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG2))stateCounter++;
   \                     ??Straight_13:
   \   00008A   3E408813     MOV.W   #0x1388, R14
   \   00008E   3D40204E     MOV.W   #0x4e20, R13
   \   000092   3C405046     MOV.W   #0x4650, R12
   \   000096   ........     CALLA   #Drive
   \   00009A   0C93         CMP.W   #0x0, R12
   \   00009C   4E24         JEQ     ??Straight_1
   \   00009E   9253....     ADD.W   #0x1, &stateCounter
     95          
     96                      break;
   \   0000A2   4B3C         JMP     ??Straight_1
     97          
     98                  case 4:
     99                      if(Drive(rightTurn, leftTurn, TURN90))stateCounter++;
   \                     ??Straight_14:
   \   0000A4   3E40CC01     MOV.W   #0x1cc, R14
   \   0000A8   0D48         MOV.W   R8, R13
   \   0000AA   0C4B         MOV.W   R11, R12
   \   0000AC   ........     CALLA   #Drive
   \   0000B0   0C93         CMP.W   #0x0, R12
   \   0000B2   4324         JEQ     ??Straight_1
   \   0000B4   9253....     ADD.W   #0x1, &stateCounter
    100          
    101                      break;
   \   0000B8   403C         JMP     ??Straight_1
    102          
    103                  /*case 5:
    104                  case 6:
    105                      if (greaterWhiteOr) {
    106                          Drive_Path(STRAIGHT_RIGHT, STRAIGHT_LEFT, 0);
    107                      } else stateCounter++;
    108          
    109                      break;*/
    110          
    111                  case 5:
    112                      if(Drive(STRAIGHT_RIGHT, STRAIGHT_LEFT, LEG3))stateCounter++;
   \                     ??Straight_15:
   \   0000BA   3E400807     MOV.W   #0x708, R14
   \   0000BE   3D40204E     MOV.W   #0x4e20, R13
   \   0000C2   3C405046     MOV.W   #0x4650, R12
   \   0000C6   ........     CALLA   #Drive
   \   0000CA   0C93         CMP.W   #0x0, R12
   \   0000CC   3624         JEQ     ??Straight_1
   \   0000CE   9253....     ADD.W   #0x1, &stateCounter
    113          
    114                      break;
   \   0000D2   333C         JMP     ??Straight_1
    115          
    116          
    117                  case 6:
    118                      EMITTER_ON;
   \                     ??Straight_16:
   \   0000D4   F2D010004302 BIS.B   #0x10, &0x243
    119          
    120                      if (lessWhiteOr) {
   \   0000DA   8293....     CMP.W   #0x0, &lessWhiteOr
   \   0000DE   0824         JEQ     ??Straight_19
    121                          Drive_Path(RIGHT_MID, RIGHT_MID, false);
   \   0000E0   0E43         MOV.W   #0x0, R14
   \   0000E2   3D403421     MOV.W   #0x2134, R13
   \   0000E6   3C403421     MOV.W   #0x2134, R12
   \   0000EA   ........     CALLA   #Drive_Path
   \   0000EE   253C         JMP     ??Straight_1
    122                      } else stateCounter++;
   \                     ??Straight_19:
   \   0000F0   9253....     ADD.W   #0x1, &stateCounter
    123          
    124                      break;
   \   0000F4   223C         JMP     ??Straight_1
    125          
    126          
    127                  case 7:
    128                      if(LockMotorsTime(-1, -1, LOCK_TIME)) stateCounter++;
   \                     ??Straight_17:
   \   0000F6   3E407D00     MOV.W   #0x7d, R14
   \   0000FA   3D43         MOV.W   #0xffff, R13
   \   0000FC   3C43         MOV.W   #0xffff, R12
   \   0000FE   ........     CALLA   #LockMotorsTime
   \   000102   0C93         CMP.W   #0x0, R12
   \   000104   1A24         JEQ     ??Straight_1
   \   000106   9253....     ADD.W   #0x1, &stateCounter
    129          
    130                      break;
   \   00010A   173C         JMP     ??Straight_1
    131          
    132                  case 8:
    133                      stateCounter = BEGINNING;
   \                     ??Straight_18:
   \   00010C   8243....     MOV.W   #0x0, &stateCounter
    134                      stopwatch_seconds = BEGINNING;
   \   000110   8243....     MOV.W   #0x0, &stopwatch_seconds
    135                      cycle_count = BEGINNING;
   \   000114   8243....     MOV.W   #0x0, &cycle_count
    136                      state = WAIT;
   \   000118   F2405700.... MOV.B   #0x57, &state
    137                      nextState = TURN;
   \   00011E   F2405400.... MOV.B   #0x54, &nextState
    138                      strcpy(LINE1, "INTERCEPT ");
   \   000124   3D40....     MOV.W   #`?<Constant "INTERCEPT ">`, R13
   \   000128   3C40....     MOV.W   #display_line, R12
   \   00012C   ........     CALLA   #strcpy
    139                      display_changed = true;
   \   000130   D243....     MOV.B   #0x1, &display_changed
    140                      EMITTER_OFF;
   \   000134   F2C010004302 BIC.B   #0x10, &0x243
    141                      break;
    142              }
    143          }
   \                     ??Straight_1:
   \   00013A   3817         POPM.W  #0x4, R11
   \   00013C   1001         RETA
   \   00013E                REQUIRE _A_PCOUT_L
    144          
    145          //===========================================================================
    146          // Function name: Turn
    147          //
    148          // Description: This function is used to turn onto the black line
    149          //
    150          // Passed : direction
    151          // Locals: no locals used
    152          // Returned: no values returned
    153          // Globals: stateCounter,display_line,display_changed,lessWhiteOr,
    154          // stopwatch_seconds,cycle_count,state,nextState
    155          //
    156          // Author: Ibrahim Moghul
    157          // Date: Apr 2022
    158          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    159          //===========================================================================
    160          

   \                                 In  segment CODE, align 2
    161          void Turn(char direction) {
   \                     Turn:
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    162              switch(stateCounter) {
   \   000004   1F42....     MOV.W   &stateCounter, R15
   \   000008   0F83         SUB.W   #0x0, R15
   \   00000A   0724         JEQ     ??Turn_3
   \   00000C   1F83         SUB.W   #0x1, R15
   \   00000E   1324         JEQ     ??Turn_4
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   2D24         JEQ     ??Turn_5
   \   000014   1F83         SUB.W   #0x1, R15
   \   000016   4324         JEQ     ??Turn_6
   \   000018   553C         JMP     ??Turn_1
    163                  case 0:
    164                      EMITTER_ON;
   \                     ??Turn_3:
   \   00001A   F2D010004302 BIS.B   #0x10, &0x243
    165                      stateCounter++;
   \   000020   9253....     ADD.W   #0x1, &stateCounter
    166                      strcpy(LINE1, " BL TURN ");
   \   000024   3D40....     MOV.W   #`?<Constant " BL TURN ">`, R13
   \   000028   3C40....     MOV.W   #display_line, R12
   \   00002C   ........     CALLA   #strcpy
    167                      display_changed = true;
   \   000030   D243....     MOV.B   #0x1, &display_changed
    168                      break;
   \   000034   473C         JMP     ??Turn_1
    169          
    170                  case 1: 
    171                      if(direction) {
   \                     ??Turn_4:
   \   000036   4A93         CMP.B   #0x0, R10
   \   000038   0D24         JEQ     ??Turn_7
    172                          if(Drive_Path(-RIGHT_MAX, LEFT_MAX, PRELIMINARY_TURN)) stateCounter++;
   \   00003A   3E406400     MOV.W   #0x64, R14
   \   00003E   3D40204E     MOV.W   #0x4e20, R13
   \   000042   3C40E0B1     MOV.W   #0xb1e0, R12
   \   000046   ........     CALLA   #Drive_Path
   \   00004A   0C93         CMP.W   #0x0, R12
   \   00004C   3B24         JEQ     ??Turn_1
   \   00004E   9253....     ADD.W   #0x1, &stateCounter
   \   000052   383C         JMP     ??Turn_1
    173                      } else if(Drive_Path(RIGHT_MAX, -LEFT_MAX, PRELIMINARY_TURN)) stateCounter++;
   \                     ??Turn_7:
   \   000054   3E406400     MOV.W   #0x64, R14
   \   000058   3D40E0B1     MOV.W   #0xb1e0, R13
   \   00005C   3C40204E     MOV.W   #0x4e20, R12
   \   000060   ........     CALLA   #Drive_Path
   \   000064   0C93         CMP.W   #0x0, R12
   \   000066   2E24         JEQ     ??Turn_1
   \   000068   9253....     ADD.W   #0x1, &stateCounter
    174          
    175                      break;
   \   00006C   2B3C         JMP     ??Turn_1
    176          
    177                  case 2:
    178                      if (lessWhiteOr) { 
   \                     ??Turn_5:
   \   00006E   8293....     CMP.W   #0x0, &lessWhiteOr
   \   000072   1224         JEQ     ??Turn_8
    179                          if(direction)Drive_Path(-RIGHT_MID, LEFT_MID, false);
   \   000074   4A93         CMP.B   #0x0, R10
   \   000076   0824         JEQ     ??Turn_9
   \   000078   0E43         MOV.W   #0x0, R14
   \   00007A   3D403421     MOV.W   #0x2134, R13
   \   00007E   3C40CCDE     MOV.W   #0xdecc, R12
   \   000082   ........     CALLA   #Drive_Path
   \   000086   1E3C         JMP     ??Turn_1
    180          
    181                          else Drive_Path(RIGHT_MID, -LEFT_MID, false);
   \                     ??Turn_9:
   \   000088   0E43         MOV.W   #0x0, R14
   \   00008A   3D40CCDE     MOV.W   #0xdecc, R13
   \   00008E   3C403421     MOV.W   #0x2134, R12
   \   000092   ........     CALLA   #Drive_Path
   \   000096   163C         JMP     ??Turn_1
    182                      } else stateCounter++;
   \                     ??Turn_8:
   \   000098   9253....     ADD.W   #0x1, &stateCounter
    183          
    184                      break;
   \   00009C   133C         JMP     ??Turn_1
    185          
    186                  case 3:
    187                      ShutoffMotors();
   \                     ??Turn_6:
   \   00009E   ........     CALLA   #ShutoffMotors
    188                      stateCounter = BEGINNING;
   \   0000A2   8243....     MOV.W   #0x0, &stateCounter
    189                      stopwatch_seconds = BEGINNING;
   \   0000A6   8243....     MOV.W   #0x0, &stopwatch_seconds
    190                      cycle_count = BEGINNING;
   \   0000AA   8243....     MOV.W   #0x0, &cycle_count
    191                      state = WAIT;
   \   0000AE   F2405700.... MOV.B   #0x57, &state
    192                      nextState = LINEFOLLOW;
   \   0000B4   F2404C00.... MOV.B   #0x4c, &nextState
    193                      EMITTER_OFF;
   \   0000BA   F2C010004302 BIC.B   #0x10, &0x243
    194                      display_changed = true;
   \   0000C0   D243....     MOV.B   #0x1, &display_changed
    195                      break;
    196              }
    197          }
   \                     ??Turn_1:
   \   0000C4   3A41         POP.W   R10
   \   0000C6   1001         RETA
   \   0000C8                REQUIRE _A_PCOUT_L
    198          
    199          //===========================================================================
    200          // Function name: LineFollow
    201          //
    202          // Description: This function is used to follow the black line
    203          //
    204          // Passed : direction
    205          // Locals: rFollowSpeed,lFollowSpeed,rAdjustSpeed,lAdjustSpeed
    206          // Returned: no values returned
    207          // Globals: stateCounter,display_line,display_changed,lessWhiteOr,
    208          // stopwatch_seconds,cycle_count,state,nextState, leftFollowController,
    209          // rightFollowControler, l_LesssWhite,r_LessWhite,lessWhiteAnd,
    210          // greaterWhiteAnd
    211          //
    212          // Author: Ibrahim Moghul
    213          // Date: Apr 2022
    214          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    215          //===========================================================================
    216          

   \                                 In  segment CODE, align 2
    217          void LineFollow(char direction) {
   \                     LineFollow:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4A4C         MOV.B   R12, R10
    218              int rFollowSpeed, lFollowSpeed, rAdjustSpeed, lAdjustSpeed;
    219          
    220              rFollowSpeed = additionSafe(RIGHT_FORWARD_SPEED, RIGHT_MAX, RIGHT_MIN, GetOutput(&leftFollowController, LEFT_BLACK_DETECT, ADC_Left_Detect)); // swapped b/c they are physically swapped
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   000004   1E42....     MOV.W   &ADC_Left_Detect, R14
   \   000008   3D401800     MOV.W   #0x18, R13
   \   00000C   3C40....     MOV.W   #leftFollowController, R12
   \   000010   ........     CALLA   #GetOutput
   \   000014   0F4C         MOV.W   R12, R15
   \   000016   3E409A10     MOV.W   #0x109a, R14
   \   00001A   3D40204E     MOV.W   #0x4e20, R13
   \   00001E   1C425404     MOV.W   &0x454, R12
   \   000022   ........     CALLA   #additionSafe
   \   000026   0B4C         MOV.W   R12, R11
    221              lFollowSpeed = additionSafe(LEFT_FORWARD_SPEED, LEFT_MAX, RIGHT_MIN, GetOutput(&rightFollowController, RIGHT_BLACK_DETECT, ADC_Right_Detect));// swapped b/c they are physically swapped
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   000028   1E42....     MOV.W   &ADC_Right_Detect, R14
   \   00002C   3D401600     MOV.W   #0x16, R13
   \   000030   3C40....     MOV.W   #rightFollowController, R12
   \   000034   ........     CALLA   #GetOutput
   \   000038   0F4C         MOV.W   R12, R15
   \   00003A   3E409A10     MOV.W   #0x109a, R14
   \   00003E   3D40204E     MOV.W   #0x4e20, R13
   \   000042   1C425604     MOV.W   &0x456, R12
   \   000046   ........     CALLA   #additionSafe
   \   00004A   084C         MOV.W   R12, R8
    222              rAdjustSpeed = (RIGHT_MID - LF_TURN_DECREMENT);
   \   00004C   39407017     MOV.W   #0x1770, R9
    223              lAdjustSpeed = (LEFT_MID - LF_TURN_DECREMENT);
   \   000050   36407017     MOV.W   #0x1770, R6
    224          
    225              switch(stateCounter) {
   \   000054   1F42....     MOV.W   &stateCounter, R15
   \   000058   0F83         SUB.W   #0x0, R15
   \   00005A   0E24         JEQ     ??LineFollow_6
   \   00005C   1F83         SUB.W   #0x1, R15
   \   00005E   1E24         JEQ     ??LineFollow_7
   \   000060   1F83         SUB.W   #0x1, R15
   \   000062   4724         JEQ     ??LineFollow_8
   \   000064   1F83         SUB.W   #0x1, R15
   \   000066   5B24         JEQ     ??LineFollow_9
   \   000068   1F83         SUB.W   #0x1, R15
   \   00006A   6D24         JEQ     ??LineFollow_10
   \   00006C   1F83         SUB.W   #0x1, R15
   \   00006E   8A24         JEQ     ??LineFollow_11
   \   000070   3F800500     SUB.W   #0x5, R15
   \   000074   7D24         JEQ     ??LineFollow_12
   \   000076   903C         JMP     ??LineFollow_1
    226                  case 0:
    227                      EMITTER_ON;
   \                     ??LineFollow_6:
   \   000078   F2D010004302 BIS.B   #0x10, &0x243
    228                      strcpy(LINE1, "BL TRAVEL ");
   \   00007E   3D40....     MOV.W   #`?<Constant "BL TRAVEL ">`, R13
   \   000082   3C40....     MOV.W   #display_line, R12
   \   000086   ........     CALLA   #strcpy
    229                      display_changed = true;
   \   00008A   D243....     MOV.B   #0x1, &display_changed
    230          
    231                      /*if(rightSwitchable && leftSwitchable)*/stateCounter++;
   \   00008E   9253....     ADD.W   #0x1, &stateCounter
    232                      //else return;
    233          
    234                      stopwatch_seconds = BEGINNING;
   \   000092   8243....     MOV.W   #0x0, &stopwatch_seconds
    235                      cycle_count = BEGINNING;
   \   000096   8243....     MOV.W   #0x0, &cycle_count
    236          
    237                      break;
   \   00009A   7E3C         JMP     ??LineFollow_1
    238          
    239                  case 1:
    240                      if(l_LessWhite ^ r_LessWhite) stateCounter = 10;
   \                     ??LineFollow_7:
   \   00009C   1F42....     MOV.W   &l_LessWhite, R15
   \   0000A0   1FE2....     XOR.W   &r_LessWhite, R15
   \   0000A4   0F93         CMP.W   #0x0, R15
   \   0000A6   0424         JEQ     ??LineFollow_13
   \   0000A8   B2400A00.... MOV.W   #0xa, &stateCounter
   \   0000AE   073C         JMP     ??LineFollow_5
    241                      else if (lessWhiteAnd) {
   \                     ??LineFollow_13:
   \   0000B0   8293....     CMP.W   #0x0, &lessWhiteAnd
   \   0000B4   0424         JEQ     ??LineFollow_5
    242                          rFollowSpeed = -RIGHT_MIN;
   \   0000B6   3B4066EF     MOV.W   #0xef66, R11
    243                          lFollowSpeed = -LEFT_MIN;
   \   0000BA   384066EF     MOV.W   #0xef66, R8
    244                      }
    245          
    246                      if(delay(CIRCLING_TIME, false))  stateCounter = 5;
   \                     ??LineFollow_5:
   \   0000BE   0D43         MOV.W   #0x0, R13
   \   0000C0   3C407800     MOV.W   #0x78, R12
   \   0000C4   ........     CALLA   #delay
   \   0000C8   0C93         CMP.W   #0x0, R12
   \   0000CA   0324         JEQ     ??LineFollow_14
   \   0000CC   B2400500.... MOV.W   #0x5, &stateCounter
    247          
    248                      if(stopwatch_seconds >= TIME_TO_CIRCLE) strcpy(LINE1, "BL CIRCLE ");
   \                     ??LineFollow_14:
   \   0000D2   B2900A00.... CMP.W   #0xa, &stopwatch_seconds
   \   0000D8   0628         JNC     ??LineFollow_15
   \   0000DA   3D40....     MOV.W   #`?<Constant "BL CIRCLE ">`, R13
   \   0000DE   3C40....     MOV.W   #display_line, R12
   \   0000E2   ........     CALLA   #strcpy
    249          
    250                      Drive_Path(rFollowSpeed, lFollowSpeed, false);
   \                     ??LineFollow_15:
   \   0000E6   0E43         MOV.W   #0x0, R14
   \   0000E8   0D48         MOV.W   R8, R13
   \   0000EA   0C4B         MOV.W   R11, R12
   \   0000EC   ........     CALLA   #Drive_Path
    251                      break;
   \   0000F0   533C         JMP     ??LineFollow_1
    252          
    253          
    254                  case 2:
    255                      if(l_LessWhite && r_GreaterWhite) stateCounter = 3;
   \                     ??LineFollow_8:
   \   0000F2   8293....     CMP.W   #0x0, &l_LessWhite
   \   0000F6   0724         JEQ     ??LineFollow_16
   \   0000F8   8293....     CMP.W   #0x0, &r_GreaterWhite
   \   0000FC   0424         JEQ     ??LineFollow_16
   \   0000FE   B2400300.... MOV.W   #0x3, &stateCounter
   \   000104   493C         JMP     ??LineFollow_1
    256                      else if(l_GreaterWhite && r_LessWhite) stateCounter = 4;
   \                     ??LineFollow_16:
   \   000106   8293....     CMP.W   #0x0, &l_GreaterWhite
   \   00010A   0624         JEQ     ??LineFollow_17
   \   00010C   8293....     CMP.W   #0x0, &r_LessWhite
   \   000110   0324         JEQ     ??LineFollow_17
   \   000112   A242....     MOV.W   #0x4, &stateCounter
   \   000116   403C         JMP     ??LineFollow_1
    257                      else stateCounter = 1;
   \                     ??LineFollow_17:
   \   000118   9243....     MOV.W   #0x1, &stateCounter
    258          
    259                      break;
   \   00011C   3D3C         JMP     ??LineFollow_1
    260          
    261                  case 3:// turn left ()
    262                      if(l_LessWhite) Drive_Path(rAdjustSpeed, -lAdjustSpeed, false);
   \                     ??LineFollow_9:
   \   00011E   8293....     CMP.W   #0x0, &l_LessWhite
   \   000122   0824         JEQ     ??LineFollow_18
   \   000124   0E43         MOV.W   #0x0, R14
   \   000126   0D46         MOV.W   R6, R13
   \   000128   3DE3         XOR.W   #0xffff, R13
   \   00012A   1D53         ADD.W   #0x1, R13
   \   00012C   0C49         MOV.W   R9, R12
   \   00012E   ........     CALLA   #Drive_Path
   \   000132   323C         JMP     ??LineFollow_1
    263                      else if (greaterWhiteAnd) stateCounter = 1;
   \                     ??LineFollow_18:
   \   000134   8293....     CMP.W   #0x0, &greaterWhiteAnd
   \   000138   0324         JEQ     ??LineFollow_19
   \   00013A   9243....     MOV.W   #0x1, &stateCounter
   \   00013E   2C3C         JMP     ??LineFollow_1
    264                      else stateCounter = 4;
   \                     ??LineFollow_19:
   \   000140   A242....     MOV.W   #0x4, &stateCounter
    265          
    266                      break;
   \   000144   293C         JMP     ??LineFollow_1
    267          
    268                  case 4:
    269                      if(r_LessWhite) Drive_Path(-rAdjustSpeed, lAdjustSpeed, false);
   \                     ??LineFollow_10:
   \   000146   8293....     CMP.W   #0x0, &r_LessWhite
   \   00014A   0824         JEQ     ??LineFollow_20
   \   00014C   0E43         MOV.W   #0x0, R14
   \   00014E   0D46         MOV.W   R6, R13
   \   000150   0C49         MOV.W   R9, R12
   \   000152   3CE3         XOR.W   #0xffff, R12
   \   000154   1C53         ADD.W   #0x1, R12
   \   000156   ........     CALLA   #Drive_Path
   \   00015A   1E3C         JMP     ??LineFollow_1
    270                      else if (greaterWhiteAnd) stateCounter = 1;
   \                     ??LineFollow_20:
   \   00015C   8293....     CMP.W   #0x0, &greaterWhiteAnd
   \   000160   0324         JEQ     ??LineFollow_21
   \   000162   9243....     MOV.W   #0x1, &stateCounter
   \   000166   183C         JMP     ??LineFollow_1
    271                      else stateCounter = 3;
   \                     ??LineFollow_21:
   \   000168   B2400300.... MOV.W   #0x3, &stateCounter
    272          
    273                      break;
   \   00016E   143C         JMP     ??LineFollow_1
    274          
    275                  case 10:
    276                      if(LockMotorsTime(-1, -1, LF_LOCK_TIME)) stateCounter = 2;
   \                     ??LineFollow_12:
   \   000170   1E43         MOV.W   #0x1, R14
   \   000172   3D43         MOV.W   #0xffff, R13
   \   000174   3C43         MOV.W   #0xffff, R12
   \   000176   ........     CALLA   #LockMotorsTime
   \   00017A   0C93         CMP.W   #0x0, R12
   \   00017C   0D24         JEQ     ??LineFollow_1
   \   00017E   A243....     MOV.W   #0x2, &stateCounter
    277          
    278                      break;
   \   000182   0A3C         JMP     ??LineFollow_1
    279          
    280                  case 5:
    281                      ShutoffMotors();
   \                     ??LineFollow_11:
   \   000184   ........     CALLA   #ShutoffMotors
    282                      stateCounter = BEGINNING;
   \   000188   8243....     MOV.W   #0x0, &stateCounter
    283                      state = START;
   \   00018C   F2405300.... MOV.B   #0x53, &state
    284                      EMITTER_OFF;
   \   000192   F2C010004302 BIC.B   #0x10, &0x243
    285                      break;
    286              }
    287          
    288          }
   \                     ??LineFollow_1:
   \   000198   5617         POPM.W  #0x6, R11
   \   00019A   1001         RETA
   \   00019C                REQUIRE _A_TB3CCR1_L
   \   00019C                REQUIRE _A_TB3CCR2_L
   \   00019C                REQUIRE _A_PCOUT_L
    289          
    290          //===========================================================================
    291          // Function name: Exit
    292          //
    293          // Description: This function is used to turn and exit the black line after 
    294          // finishing following it
    295          //
    296          // Passed : direction
    297          // Locals: no locals used
    298          // Returned: no values returned
    299          // Globals: stateCounter,display_line,display_changed, stopwatch_seconds,
    300          // cycle_count,state
    301          //
    302          // Author: Ibrahim Moghul
    303          // Date: Apr 2022
    304          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    305          //===========================================================================
    306          

   \                                 In  segment CODE, align 2
    307          void Exit(int direction) {
   \                     Exit:
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    308              switch(stateCounter) {
   \   000004   1F42....     MOV.W   &stateCounter, R15
   \   000008   0F83         SUB.W   #0x0, R15
   \   00000A   0724         JEQ     ??Exit_5
   \   00000C   1F83         SUB.W   #0x1, R15
   \   00000E   0E24         JEQ     ??Exit_6
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   2324         JEQ     ??Exit_7
   \   000014   1F83         SUB.W   #0x1, R15
   \   000016   2E24         JEQ     ??Exit_8
   \   000018   383C         JMP     ??Exit_1
    309                  case 0:
    310                      strcpy(LINE1, " BL STOP  ");
   \                     ??Exit_5:
   \   00001A   3D40....     MOV.W   #`?<Constant " BL STOP  ">`, R13
   \   00001E   3C40....     MOV.W   #display_line, R12
   \   000022   ........     CALLA   #strcpy
    311                      stateCounter++;
   \   000026   9253....     ADD.W   #0x1, &stateCounter
    312                      break;
   \   00002A   2F3C         JMP     ??Exit_1
    313          
    314                  case 1:
    315                      if (Drive(direction ? -STRAIGHT_RIGHT : STRAIGHT_RIGHT, direction ? STRAIGHT_LEFT : -STRAIGHT_LEFT, TURN90) )
   \                     ??Exit_6:
   \   00002C   0A93         CMP.W   #0x0, R10
   \   00002E   0324         JEQ     ??Exit_9
   \   000030   3D40204E     MOV.W   #0x4e20, R13
   \   000034   023C         JMP     ??Exit_3
   \                     ??Exit_9:
   \   000036   3D40E0B1     MOV.W   #0xb1e0, R13
   \                     ??Exit_3:
   \   00003A   0A93         CMP.W   #0x0, R10
   \   00003C   0324         JEQ     ??Exit_10
   \   00003E   3C40B0B9     MOV.W   #0xb9b0, R12
   \   000042   023C         JMP     ??Exit_4
   \                     ??Exit_10:
   \   000044   3C405046     MOV.W   #0x4650, R12
   \                     ??Exit_4:
   \   000048   3E40CC01     MOV.W   #0x1cc, R14
   \   00004C   ........     CALLA   #Drive
   \   000050   0C93         CMP.W   #0x0, R12
   \   000052   1B24         JEQ     ??Exit_1
    316                          stateCounter++;
   \   000054   9253....     ADD.W   #0x1, &stateCounter
    317          
    318                      break;
   \   000058   183C         JMP     ??Exit_1
    319          
    320                  case 2:
    321                      if(Drive(STRAIGHT_RIGHT, STRAIGHT_LEFT, EXITING_TIME)) stateCounter++;
   \                     ??Exit_7:
   \   00005A   3E40A00F     MOV.W   #0xfa0, R14
   \   00005E   3D40204E     MOV.W   #0x4e20, R13
   \   000062   3C405046     MOV.W   #0x4650, R12
   \   000066   ........     CALLA   #Drive
   \   00006A   0C93         CMP.W   #0x0, R12
   \   00006C   0E24         JEQ     ??Exit_1
   \   00006E   9253....     ADD.W   #0x1, &stateCounter
    322          
    323                      break;
   \   000072   0B3C         JMP     ??Exit_1
    324          
    325                  case 3:
    326                      ShutoffMotors();
   \                     ??Exit_8:
   \   000074   ........     CALLA   #ShutoffMotors
    327                      stateCounter = BEGINNING;
   \   000078   8243....     MOV.W   #0x0, &stateCounter
    328                      state = DONE;
   \   00007C   F2406400.... MOV.B   #0x64, &state
    329                      stopwatch_seconds = BEGINNING;
   \   000082   8243....     MOV.W   #0x0, &stopwatch_seconds
    330                      cycle_count = BEGINNING;
   \   000086   8243....     MOV.W   #0x0, &cycle_count
    331                      break;
    332              }
    333          }
   \                     ??Exit_1:
   \   00008A   3A41         POP.W   R10
   \   00008C   1001         RETA
    334          
    335          //===========================================================================
    336          // Function name: Drive
    337          //
    338          // Description: This function is used to drive a certain path and then 
    339          // electronically brake
    340          //
    341          // Passed : r, l, time
    342          // Locals: no locals used
    343          // Returned: completion
    344          // Globals: driveStateCounter
    345          //
    346          // Author: Ibrahim Moghul
    347          // Date: Apr 2022
    348          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    349          //===========================================================================
    350          

   \                                 In  segment CODE, align 2
    351          int Drive(int r, int l, unsigned int time) {
   \                     Drive:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   084E         MOV.W   R14, R8
    352              switch(driveStateCounter) {
   \   000008   1F42....     MOV.W   &driveStateCounter, R15
   \   00000C   0F83         SUB.W   #0x0, R15
   \   00000E   0724         JEQ     ??Drive_4
   \   000010   1F83         SUB.W   #0x1, R15
   \   000012   0824         JEQ     ??Drive_5
   \   000014   1F83         SUB.W   #0x1, R15
   \   000016   1024         JEQ     ??Drive_6
   \   000018   1F83         SUB.W   #0x1, R15
   \   00001A   1D24         JEQ     ??Drive_7
   \   00001C   223C         JMP     ??Drive_1
    353          
    354                  case 0 :
    355                      driveStateCounter++;
   \                     ??Drive_4:
   \   00001E   9253....     ADD.W   #0x1, &driveStateCounter
    356                      break;
   \   000022   1F3C         JMP     ??Drive_1
    357          
    358                  case 1 :
    359                      if(Drive_Path(r, l, time))driveStateCounter++;
   \                     ??Drive_5:
   \   000024   0E48         MOV.W   R8, R14
   \   000026   0D4B         MOV.W   R11, R13
   \   000028   0C4A         MOV.W   R10, R12
   \   00002A   ........     CALLA   #Drive_Path
   \   00002E   0C93         CMP.W   #0x0, R12
   \   000030   1824         JEQ     ??Drive_1
   \   000032   9253....     ADD.W   #0x1, &driveStateCounter
    360          
    361                      break;
   \   000036   153C         JMP     ??Drive_1
    362          
    363                  case 2 :
    364                      if(LockMotorsTime(-r, -l, LOCK_TIME)) driveStateCounter++;
   \                     ??Drive_6:
   \   000038   3E407D00     MOV.W   #0x7d, R14
   \   00003C   0D4B         MOV.W   R11, R13
   \   00003E   3DE3         XOR.W   #0xffff, R13
   \   000040   1D53         ADD.W   #0x1, R13
   \   000042   0C4A         MOV.W   R10, R12
   \   000044   3CE3         XOR.W   #0xffff, R12
   \   000046   1C53         ADD.W   #0x1, R12
   \   000048   ........     CALLA   #LockMotorsTime
   \   00004C   0C93         CMP.W   #0x0, R12
   \   00004E   0924         JEQ     ??Drive_1
   \   000050   9253....     ADD.W   #0x1, &driveStateCounter
    365          
    366                      break;
   \   000054   063C         JMP     ??Drive_1
    367          
    368                  case 3 :
    369                      ShutoffMotors();
   \                     ??Drive_7:
   \   000056   ........     CALLA   #ShutoffMotors
    370                      driveStateCounter = BEGINNING;
   \   00005A   8243....     MOV.W   #0x0, &driveStateCounter
    371                      //state = START;
    372                      return true;
   \   00005E   1C43         MOV.W   #0x1, R12
   \   000060   013C         JMP     ??Drive_3
    373                      break;
    374              }
    375          
    376              return false;
   \                     ??Drive_1:
   \   000062   0C43         MOV.W   #0x0, R12
   \                     ??Drive_3:
   \   000064   3817         POPM.W  #0x4, R11
   \   000066   1001         RETA
    377          }
    378          
    379          //===========================================================================
    380          // Function name: delay
    381          //
    382          // Description: This function is used as a customizable timer to choose 
    383          // how long to delay before returning true
    384          //
    385          // Passed : seconds, cycles
    386          // Locals: no locals used
    387          // Returned: no values returned
    388          // Globals: stopwatch_seconds,cycle_count, display_changed
    389          //
    390          // Author: Ibrahim Moghul
    391          // Date: Apr 2022
    392          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    393          //===========================================================================
    394          
    395          // delays for a specified time make sure stopwatch_seconds and cycle_count are 0 before calling

   \                                 In  segment CODE, align 2
    396          int delay(int seconds, int cycles) {
   \                     delay:
   \   000000   0F4C         MOV.W   R12, R15
    397              if(stopwatch_seconds == BEGINNING && cycle_count <= (BEGINNING + 1)) {
   \   000002   8293....     CMP.W   #0x0, &stopwatch_seconds
   \   000006   0520         JNE     ??delay_0
   \   000008   A293....     CMP.W   #0x2, &cycle_count
   \   00000C   022C         JC      ??delay_0
    398                  display_changed = true;
   \   00000E   D243....     MOV.B   #0x1, &display_changed
    399              }
    400          
    401              if(stopwatch_seconds >= seconds && cycle_count >= cycles) {
   \                     ??delay_0:
   \   000012   829F....     CMP.W   R15, &stopwatch_seconds
   \   000016   0928         JNC     ??delay_1
   \   000018   829D....     CMP.W   R13, &cycle_count
   \   00001C   0628         JNC     ??delay_1
    402                  stopwatch_seconds = BEGINNING;
   \   00001E   8243....     MOV.W   #0x0, &stopwatch_seconds
    403                  cycle_count = FALSE;
   \   000022   8243....     MOV.W   #0x0, &cycle_count
    404                  return true;
   \   000026   1C43         MOV.W   #0x1, R12
   \   000028   1001         RETA
    405              } else return false;
   \                     ??delay_1:
   \   00002A   0C43         MOV.W   #0x0, R12
   \   00002C   1001         RETA
    406          }
    407          
    408          
    409          
    410          //===========================================================================
    411          // Function name: StateMachine
    412          //
    413          // Description: This function is the main state machine for wheel processes
    414          //
    415          // Passed : no variables passed
    416          // Locals: no locals used
    417          // Returned: no values returned
    418          // Globals: stateCounter, stopwatch_seconds,cycle_count,state,nextState
    419          // delayTime, speedRight, speedLeft
    420          //
    421          // Author: Ibrahim Moghul
    422          // Date: Apr 2022
    423          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    424          //===========================================================================
    425          

   \                                 In  segment CODE, align 2
    426          void StateMachine(void) {
   \                     StateMachine:
    427              updateDetectors();
   \   000000   ........     CALLA   #updateDetectors
    428          
    429              switch(state) {
   \   000004   5E42....     MOV.B   &state, R14
   \   000008   7E804400     SUB.B   #0x44, R14
   \   00000C   3724         JEQ     ??StateMachine_3
   \   00000E   7E82         SUB.B   #0x8, R14
   \   000010   2B24         JEQ     ??StateMachine_4
   \   000012   7E800700     SUB.B   #0x7, R14
   \   000016   0E24         JEQ     ??StateMachine_5
   \   000018   5E83         SUB.B   #0x1, R14
   \   00001A   2124         JEQ     ??StateMachine_6
   \   00001C   7E800300     SUB.B   #0x3, R14
   \   000020   0E24         JEQ     ??StateMachine_7
   \   000022   7E800D00     SUB.B   #0xd, R14
   \   000026   3724         JEQ     ??StateMachine_2
   \   000028   5E83         SUB.B   #0x1, R14
   \   00002A   2324         JEQ     ??StateMachine_8
   \   00002C   7E800E00     SUB.B   #0xe, R14
   \   000030   1124         JEQ     ??StateMachine_9
   \   000032   1001         RETA
    430                  /*case (CALIBRATE):
    431                      calibrate();
    432          
    433                      if(calibrationMode >= 2) {
    434                          state = START;
    435                      }
    436          
    437                      break;*/
    438          
    439                  case (START):
    440                      stopwatch_seconds = BEGINNING;
   \                     ??StateMachine_5:
   \   000034   8243....     MOV.W   #0x0, &stopwatch_seconds
    441                      cycle_count = BEGINNING;
   \   000038   8243....     MOV.W   #0x0, &cycle_count
    442                      break;
   \   00003C   1001         RETA
    443          
    444                  case (WAIT):
    445          
    446                      if (delay(delayTime, false)) state = nextState;
   \                     ??StateMachine_7:
   \   00003E   0D43         MOV.W   #0x0, R13
   \   000040   1C42....     MOV.W   &delayTime, R12
   \   000044   ........     CALLA   #delay
   \   000048   0C93         CMP.W   #0x0, R12
   \   00004A   2524         JEQ     ??StateMachine_2
   \   00004C   D242........ MOV.B   &nextState, &state
    447          
    448                      break;
   \   000052   1001         RETA
    449          
    450                  case (STRAIGHT):
    451                      Straight(speedRight);
   \                     ??StateMachine_9:
   \   000054   5C42....     MOV.B   &speedRight, R12
   \   000058   ........     CALLA   #Straight
    452                      break;
   \   00005C   1001         RETA
    453          
    454                  case (TURN):
    455                      Turn(speedRight);
   \                     ??StateMachine_6:
   \   00005E   5C42....     MOV.B   &speedRight, R12
   \   000062   ........     CALLA   #Turn
    456                      break;
   \   000066   1001         RETA
    457          
    458                  case (LINEFOLLOW):
    459                      LineFollow(speedRight);
   \                     ??StateMachine_4:
   \   000068   5C42....     MOV.B   &speedRight, R12
   \   00006C   ........     CALLA   #LineFollow
    460                      break;
   \   000070   1001         RETA
    461          
    462                  case (EXIT):
    463                      Exit(speedRight);
   \                     ??StateMachine_8:
   \   000072   1C42....     MOV.W   &speedRight, R12
   \   000076   ........     CALLA   #Exit
    464                      break;
   \   00007A   1001         RETA
    465          
    466                  case (DRIVE):
    467                      if(Drive(speedRight, speedLeft, driveTime)) state = START;
   \                     ??StateMachine_3:
   \   00007C   1E42....     MOV.W   &driveTime, R14
   \   000080   1D42....     MOV.W   &speedLeft, R13
   \   000084   1C42....     MOV.W   &speedRight, R12
   \   000088   ........     CALLA   #Drive
   \   00008C   0C93         CMP.W   #0x0, R12
   \   00008E   0324         JEQ     ??StateMachine_2
   \   000090   F2405300.... MOV.B   #0x53, &state
    468          
    469                      break;
    470          
    471                  case (DONE):
    472                      break;
    473          
    474                  default:
    475                      break;
    476              }
    477          }
   \                     ??StateMachine_2:
   \   000096   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for state>`:
   \   000000   53           DC8 83

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for nextState>`:
   \   000000   73           DC8 115

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delayTime>`:
   \   000000   0500         DC16 5

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for enteringDirection>`:
   \   000000   4E           DC8 78

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " BL START ">`:
   \   000000   20424C205354 DC8 " BL START "
   \            4152542000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "INTERCEPT ">`:
   \   000000   494E54455243 DC8 "INTERCEPT "
   \            4550542000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " BL TURN ">`:
   \   000000   20424C205455 DC8 " BL TURN "
   \            524E2000    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BL TRAVEL ">`:
   \   000000   424C20545241 DC8 "BL TRAVEL "
   \            56454C2000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BL CIRCLE ">`:
   \   000000   424C20434952 DC8 "BL CIRCLE "
   \            434C452000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant " BL STOP  ">`:
   \   000000   20424C205354 DC8 " BL STOP  "
   \            4F50202000  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     12   Drive
       12   -> Drive_Path
       12   -> LockMotorsTime
       12   -> ShutoffMotors
      6   Exit
        6   -> Drive
        6   -> ShutoffMotors
        6   -> strcpy
     16   LineFollow
       16   -> Drive_Path
       16   -> GetOutput
       16   -> LockMotorsTime
       16   -> ShutoffMotors
       16   -> additionSafe
       16   -> delay
       16   -> strcpy
      4   StateMachine
        4   -> Drive
        4   -> Exit
        4   -> LineFollow
        4   -> Straight
        4   -> Turn
        4   -> delay
        4   -> updateDetectors
     12   Straight
       12   -> Drive
       12   -> Drive_Path
       12   -> LockMotorsTime
       12   -> strcpy
      6   Turn
        6   -> Drive_Path
        6   -> ShutoffMotors
        6   -> strcpy
      4   delay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant " BL START ">
      11  ?<Constant " BL STOP  ">
      10  ?<Constant " BL TURN ">
      11  ?<Constant "BL CIRCLE ">
      11  ?<Constant "BL TRAVEL ">
      11  ?<Constant "INTERCEPT ">
       2  ?<Initializer for delayTime>
       1  ?<Initializer for enteringDirection>
       1  ?<Initializer for nextState>
       1  ?<Initializer for state>
     104  Drive
     142  Exit
     412  LineFollow
     152  StateMachine
     318  Straight
     200  Turn
       2  _A_PCOUT_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
      46  delay
       2  delayTime
       2  driveStateCounter
       2  driveTime
       1  enteringDirection
       1  nextState
       2  speedLeft
       2  speedRight
       1  state
       2  stateCounter

 
 1 374 bytes in segment CODE
     6 bytes in segment DATA16_AN
    65 bytes in segment DATA16_C
     5 bytes in segment DATA16_I
     5 bytes in segment DATA16_ID
    10 bytes in segment DATA16_Z
 
 1 374 bytes of CODE  memory
    70 bytes of CONST memory
    15 bytes of DATA  memory (+ 6 bytes shared)

Errors: none
Warnings: 2
