###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          25/Apr/2022  16:03:39
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\test\Project 10\timers.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EW430.tmp
#        ("C:\Users\saad\Documents\test\Project 10\timers.c" -lC
#        "C:\Users\saad\Documents\test\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\test\Project 10\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\test\Project 10\Debug\List\timers.lst
#    Object file   =  
#        C:\Users\saad\Documents\test\Project 10\Debug\Obj\timers.r43
#
###############################################################################

C:\Users\saad\Documents\test\Project 10\timers.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x700
   \   union <unnamed> _A_ADCCTL0_L
   \                     _A_ADCCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x21a
   \   union <unnamed> _A_PAIE_L
   \                     _A_PAIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x222
   \   union <unnamed> _A_PBOUT_L
   \                     _A_PBOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23a
   \   union <unnamed> _A_PBIE_L
   \                     _A_PBIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x380
   \   union <unnamed> _A_TB0CTL_L
   \                     _A_TB0CTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x382
   \   union <unnamed> _A_TB0CCTL0_L
   \                     _A_TB0CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x384
   \   union <unnamed> _A_TB0CCTL1_L
   \                     _A_TB0CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x386
   \   union <unnamed> _A_TB0CCTL2_L
   \                     _A_TB0CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x392
   \   union <unnamed> _A_TB0CCR0_L
   \                     _A_TB0CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x394
   \   union <unnamed> _A_TB0CCR1_L
   \                     _A_TB0CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x396
   \   union <unnamed> _A_TB0CCR2_L
   \                     _A_TB0CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3a0
   \   union <unnamed> _A_TB0EX0_L
   \                     _A_TB0EX0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3ae
   \   union <unnamed> _A_TB0IV_L
   \                     _A_TB0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c0
   \   union <unnamed> _A_TB1CTL_L
   \                     _A_TB1CTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c2
   \   union <unnamed> _A_TB1CCTL0_L
   \                     _A_TB1CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c4
   \   union <unnamed> _A_TB1CCTL1_L
   \                     _A_TB1CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c6
   \   union <unnamed> _A_TB1CCTL2_L
   \                     _A_TB1CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d2
   \   union <unnamed> _A_TB1CCR0_L
   \                     _A_TB1CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3e0
   \   union <unnamed> _A_TB1EX0_L
   \                     _A_TB1EX0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3ee
   \   union <unnamed> _A_TB1IV_L
   \                     _A_TB1IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x440
   \   union <unnamed> _A_TB3CTL_L
   \                     _A_TB3CTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x444
   \   union <unnamed> _A_TB3CCTL1_L
   \                     _A_TB3CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x446
   \   union <unnamed> _A_TB3CCTL2_L
   \                     _A_TB3CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x448
   \   union <unnamed> _A_TB3CCTL3_L
   \                     _A_TB3CCTL3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x44a
   \   union <unnamed> _A_TB3CCTL4_L
   \                     _A_TB3CCTL4_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x452
   \   union <unnamed> _A_TB3CCR0_L
   \                     _A_TB3CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x458
   \   union <unnamed> _A_TB3CCR3_L
   \                     _A_TB3CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x45a
   \   union <unnamed> _A_TB3CCR4_L
   \                     _A_TB3CCR4_L:
   \   000000                DS8 2
      2          #include "timers.h"
      3          #include "ports.h"
      4          #include "macros.h"
      5          #include "wheels.h"
      6          #include "sm.h"
      7          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      8          volatile unsigned int Time_Sequence;
   \                     Time_Sequence:
   \   000000                DS8 2
      9          extern volatile unsigned char update_display;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     10          volatile unsigned long timer0Counter;
   \                     timer0Counter:
   \   000000                DS8 4

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     11          volatile unsigned int backliteCounter;
   \                     backliteCounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     12          unsigned int debounce_count1, debounce_count2;
   \                     debounce_count1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     debounce_count2:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     13          volatile unsigned int debouncing1, debouncing2;
   \                     debouncing1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     debouncing2:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     14          volatile unsigned int debounce_thresh1 = SWITCH_DEBOUNCE_THRESH, debounce_thresh2 = SWITCH_DEBOUNCE_THRESH;
   \                     debounce_thresh1:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for debounce_thresh1>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     debounce_thresh2:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for debounce_thresh2>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          volatile unsigned int checkAdc;
   \                     checkAdc:
   \   000000                DS8 2
     16          extern volatile char state;
     17          extern volatile unsigned int rightSwitchable, leftSwitchable;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile int timeElapsedSeconds, timeElapsedMilliseconds;
   \                     timeElapsedSeconds:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     timeElapsedMilliseconds:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile unsigned int stopwatchUpdated;
   \                     stopwatchUpdated:
   \   000000                DS8 2
     20          extern char receievedFromPC;
     21          extern char commandsReceieved;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          char pingCounter;
   \                     pingCounter:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          volatile char pingFlag;
   \                     pingFlag:
   \   000000                DS8 1
     24          
     25          //===========================================================================
     26          // Function name: Init_Timrs
     27          //
     28          // Description: This function is used to initialize all timers
     29          //
     30          // Passed : direction
     31          // Locals: no locals used
     32          // Returned: no values returned
     33          // Globals: no globals used
     34          //
     35          // Author: Ibrahim Moghul
     36          // Date: Apr 2022
     37          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     38          //===========================================================================
     39          

   \                                 In  segment CODE, align 2
     40          void Init_Timers(void) {
   \                     Init_Timers:
     41              Init_Timer_B0();
   \   000000   ........     CALLA   #Init_Timer_B0
     42              Init_Timer_B1();
   \   000004   ........     CALLA   #Init_Timer_B1
     43              Init_Timer_B3();
   \   000008   ........     CALLA   #Init_Timer_B3
     44          }
   \   00000C   1001         RETA
     45          
     46          //===========================================================================
     47          // Function name: Init_Timer_B0
     48          //
     49          // Description: This function is used to initialized timer B0
     50          //
     51          // Passed : direction
     52          // Locals: no locals used
     53          // Returned: no values returned
     54          // Globals: no globals used
     55          //
     56          // Author: Ibrahim Moghul
     57          // Date: Apr 2022
     58          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     59          //===========================================================================
     60          

   \                                 In  segment CODE, align 2
     61          void Init_Timer_B0(void) {
   \                     Init_Timer_B0:
     62              /*TB0CTL = TBSSEL__SMCLK; // SMCLK source
     63              TB0CTL |= TBCLR; // Resets TB0R, clock divider, count direction
     64              TB0CTL |= MC__CONTINOUS; // Continuous up
     65              TB0CTL |= ID__2; // Divide clock by 2*/
     66          
     67              TB0CTL = TBSSEL__SMCLK | TBCLR | MC__CONTINOUS | ID__2;
   \   000000   B24064028003 MOV.W   #0x264, &0x380
     68          
     69              TB0EX0 = TBIDEX__8; // Divide clock by an additional 8
   \   000006   B2400700A003 MOV.W   #0x7, &0x3a0
     70          
     71              TB0CCR0 = TB0CCR0_INTERVAL; // CCR0
   \   00000C   B240D0079203 MOV.W   #0x7d0, &0x392
     72              TB0CCTL0 |= CCIE; // CCR0 enable interrupt
   \   000012   B2D010008203 BIS.W   #0x10, &0x382
     73          
     74              TB0CCR1 = TB0CCR1_INTERVAL; // CCR1
   \   000018   B24050C39403 MOV.W   #0xc350, &0x394
     75              //TB0CCTL1 |= CCIE; // CCR1 enable interrupt
     76          
     77              TB0CCR2 = TB0CCR2_INTERVAL; // CCR2
   \   00001E   B24050C39603 MOV.W   #0xc350, &0x396
     78              //TB0CCTL2 |= CCIE; // CCR2 enable interrupt
     79          
     80              TB0CTL &= ~TBIE & ~TBIFG; // Disable Overflow Interrupt
   \   000024   B2F0FCFF8003 AND.W   #0xfffc, &0x380
     81              //TB0CTL &= ~TBIFG; // Clear Overflow Interrupt flag
     82          }
   \   00002A   1001         RETA
   \   00002C                REQUIRE _A_TB0CTL_L
   \   00002C                REQUIRE _A_TB0EX0_L
   \   00002C                REQUIRE _A_TB0CCR0_L
   \   00002C                REQUIRE _A_TB0CCTL0_L
   \   00002C                REQUIRE _A_TB0CCR1_L
   \   00002C                REQUIRE _A_TB0CCR2_L
     83          
     84          //===========================================================================
     85          // Function name: Init_Timer_B1
     86          //
     87          // Description: This function is used to initialized timer B1
     88          //
     89          // Passed : direction
     90          // Locals: no locals used
     91          // Returned: no values returned
     92          // Globals: no globals used
     93          //
     94          // Author: Ibrahim Moghul
     95          // Date: Apr 2022
     96          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     97          //===========================================================================
     98          

   \                                 In  segment CODE, align 2
     99          void Init_Timer_B1(void) {
   \                     Init_Timer_B1:
    100              /*TB1CTL = TBSSEL__SMCLK; // SMCLK source
    101              TB1CTL |= TBCLR; // Resets TB0R, clock divider, count direction
    102              TB1CTL |= MC__CONTINOUS; // Continuous up
    103              TB1CTL |= ID__4; // Divide clock by 4*/
    104          
    105              TB1CTL = TBSSEL__SMCLK | TBCLR | MC__CONTINOUS | ID__4;
   \   000000   B240A402C003 MOV.W   #0x2a4, &0x3c0
    106          
    107              TB1EX0 = TBIDEX__8; // Divide clock by an additional 8
   \   000006   B2400700E003 MOV.W   #0x7, &0x3e0
    108          
    109              TB1CCR0 = TB1CCR0_INTERVAL; // CCR0
   \   00000C   B24050C3D203 MOV.W   #0xc350, &0x3d2
    110              TB1CCTL0 |= CCIE; // CCR0 enable interrupt
   \   000012   B2D01000C203 BIS.W   #0x10, &0x3c2
    111          
    112              //TB1CCR1 = TB1CCR1_INTERVAL; // CCR1
    113              //TB1CCTL1 |= CCIE; // CCR1 enable interrupt
    114          
    115              //TB1CCR2 = TB1CCR2_INTERVAL; // CCR2
    116              //TB1CCTL2 |= CCIE; // CCR2 enable interrupt
    117          
    118              TB1CTL &= ~TBIE & ~TBIFG; // Disable Overflow Interrupt
   \   000018   B2F0FCFFC003 AND.W   #0xfffc, &0x3c0
    119              //TB1CTL &= ~TBIFG; // Clear Overflow Interrupt flag
    120          }
   \   00001E   1001         RETA
   \   000020                REQUIRE _A_TB1CTL_L
   \   000020                REQUIRE _A_TB1EX0_L
   \   000020                REQUIRE _A_TB1CCR0_L
   \   000020                REQUIRE _A_TB1CCTL0_L
    121          //===========================================================================
    122          // Function name: Init_Timer_B3
    123          //
    124          // Description: This function is used to initialized timer B3
    125          //
    126          // Passed : direction
    127          // Locals: no locals used
    128          // Returned: no values returned
    129          // Globals: no globals used
    130          //
    131          // Author: Ibrahim Moghul
    132          // Date: Apr 2022
    133          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    134          //===========================================================================
    135          

   \                                 In  segment CODE, align 2
    136          void Init_Timer_B3(void) {
   \                     Init_Timer_B3:
    137              /*TB3CTL = TBSSEL__SMCLK;
    138              TB3CTL |= MC__UP;
    139              TB3CTL |= TBCLR;*/
    140          
    141              TB3CTL = TBCLR | MC__UP | TBSSEL__SMCLK;
   \   000000   B24014024004 MOV.W   #0x214, &0x440
    142          
    143              TB3CCR0 = WHEEL_PERIOD;
   \   000006   B240204E5204 MOV.W   #0x4e20, &0x452
    144          
    145              TB3CCTL1 = OUTMOD_7;
   \   00000C   B240E0004404 MOV.W   #0xe0, &0x444
    146              RIGHT_FORWARD_SPEED = WHEEL_OFF;
   \   000012   82435404     MOV.W   #0x0, &0x454
    147          
    148              TB3CCTL2 = OUTMOD_7;
   \   000016   B240E0004604 MOV.W   #0xe0, &0x446
    149              LEFT_FORWARD_SPEED = WHEEL_OFF;
   \   00001C   82435604     MOV.W   #0x0, &0x456
    150          
    151              TB3CCTL3 = OUTMOD_7;
   \   000020   B240E0004804 MOV.W   #0xe0, &0x448
    152              RIGHT_REVERSE_SPEED = WHEEL_OFF;
   \   000026   82435804     MOV.W   #0x0, &0x458
    153          
    154              TB3CCTL4 = OUTMOD_7;
   \   00002A   B240E0004A04 MOV.W   #0xe0, &0x44a
    155              LEFT_REVERSE_SPEED = WHEEL_OFF;
   \   000030   82435A04     MOV.W   #0x0, &0x45a
    156          }
   \   000034   1001         RETA
   \   000036                REQUIRE _A_TB3CTL_L
   \   000036                REQUIRE _A_TB3CCR0_L
   \   000036                REQUIRE _A_TB3CCTL1_L
   \   000036                REQUIRE _A_TB3CCR1_L
   \   000036                REQUIRE _A_TB3CCTL2_L
   \   000036                REQUIRE _A_TB3CCR2_L
   \   000036                REQUIRE _A_TB3CCTL3_L
   \   000036                REQUIRE _A_TB3CCR3_L
   \   000036                REQUIRE _A_TB3CCTL4_L
   \   000036                REQUIRE _A_TB3CCR4_L
    157          
    158          
    159          //===========================================================================
    160          // Function name: Timer0_B0_ISR
    161          //
    162          // Description: Timer B0 isr, Increments Time_Sequence and enables adc preiodically
    163          //
    164          // Passed : no variables passed
    165          // Locals: no variables declared
    166          // Returned: no values returned
    167          // Globals: no global values
    168          //
    169          // Author: Ibrahim Moghul
    170          // Date: Feb 2022
    171          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    172          //===========================================================================
    173          #pragma vector = TIMER0_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    174          __interrupt void Timer0_B0_ISR(void) {
   \                     Timer0_B0_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
    175              //------------------------------------------------------------------------------
    176              // TimerB0 0 Interrupt handler
    177              //----------------------------------------------------------------------------
    178              if(Time_Sequence++ == TIME_SEQUENCE_MAX) Time_Sequence = BEGINNING;
   \   000002   1F42....     MOV.W   &Time_Sequence, R15
   \   000006   0E4F         MOV.W   R15, R14
   \   000008   1E53         ADD.W   #0x1, R14
   \   00000A   824E....     MOV.W   R14, &Time_Sequence
   \   00000E   3F90FA00     CMP.W   #0xfa, R15
   \   000012   0220         JNE     ??Timer0_B0_ISR_0
   \   000014   8243....     MOV.W   #0x0, &Time_Sequence
    179          
    180              if(++timer0Counter >= CHECK_ADC_TIMER_COUNT ) { // 56 ms
   \                     ??Timer0_B0_ISR_0:
   \   000018   1E42....     MOV.W   &timer0Counter, R14
   \   00001C   1F42....     MOV.W   &timer0Counter + 2, R15
   \   000020   1E53         ADD.W   #0x1, R14
   \   000022   0F63         ADDC.W  #0x0, R15
   \   000024   824E....     MOV.W   R14, &timer0Counter
   \   000028   824F....     MOV.W   R15, &timer0Counter + 2
   \   00002C   0F93         CMP.W   #0x0, R15
   \   00002E   0A28         JNC     ??Timer0_B0_ISR_1
   \   000030   0320         JNE     ??Timer0_B0_ISR_2
   \   000032   3E900E00     CMP.W   #0xe, R14
   \   000036   0628         JNC     ??Timer0_B0_ISR_1
    181                  timer0Counter = BEGINNING;
   \                     ??Timer0_B0_ISR_2:
   \   000038   8243....     MOV.W   #0x0, &timer0Counter
   \   00003C   8243....     MOV.W   #0x0, &timer0Counter + 2
    182                  ADCCTL0 |= ADCSC;
   \   000040   92D30007     BIS.W   #0x1, &0x700
    183              }
    184          
    185              TB0CCR0 += TB0CCR0_INTERVAL; // Add Offset to TBCCR0
   \                     ??Timer0_B0_ISR_1:
   \   000044   B250D0079203 ADD.W   #0x7d0, &0x392
    186              //----------------------------------------------------------------------------
    187          }
   \   00004A   1E17         POPM.W  #0x2, R15
   \   00004C   0013         RETI
   \   00004E                REQUIRE _A_ADCCTL0_L
   \   00004E                REQUIRE _A_TB0CCR0_L
    188          
    189          
    190          //===========================================================================
    191          // Function name: TIMER0_B1_ISR
    192          //
    193          // Description: Timer B0 isr, Timers 1 and 2 handles switch debounce
    194          //
    195          // Passed : no variables passed
    196          // Locals: no variables declared
    197          // Returned: no values returned
    198          // Globals: debouncing1, debouncing2, debounce_count1, debounce_count2, 
    199          // debounce_thresh1, debounce_thresh2
    200          //
    201          // Author: Ibrahim Moghul
    202          // Date: Feb 2022
    203          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    204          //===========================================================================
    205          #pragma vector=TIMER0_B1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    206          __interrupt void TIMER0_B1_ISR(void) {
   \                     TIMER0_B1_ISR:
   \   000000   0F12         PUSH.W  R15
    207              //----------------------------------------------------------------------------
    208              // TimerB0 1-2, Overflow Interrupt Vector (TBIV) handler
    209              //----------------------------------------------------------------------------
    210              switch(__even_in_range(TB0IV, 14)) {
   \   000002   1F42AE03     MOV.W   &0x3ae, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for TIMER0_B1_ISR>_0`:
   \   000008   323C         JMP     ??TIMER0_B1_ISR_1
   \   00000A   063C         JMP     ??TIMER0_B1_ISR_6
   \   00000C   1B3C         JMP     ??TIMER0_B1_ISR_7
   \   00000E   2F3C         JMP     ??TIMER0_B1_ISR_1
   \   000010   2E3C         JMP     ??TIMER0_B1_ISR_1
   \   000012   2D3C         JMP     ??TIMER0_B1_ISR_1
   \   000014   2C3C         JMP     ??TIMER0_B1_ISR_1
   \   000016   2B3C         JMP     ??TIMER0_B1_ISR_1
    211                  case 0:
    212                      break; // No interrupt
    213          
    214                  case 2: // CCR1 not used
    215                      if(debouncing1 == TRUE) debounce_count1++;
   \                     ??TIMER0_B1_ISR_6:
   \   000018   9293....     CMP.W   #0x1, &debouncing1
   \   00001C   0220         JNE     ??TIMER0_B1_ISR_2
   \   00001E   9253....     ADD.W   #0x1, &debounce_count1
    216          
    217                      if (debounce_count1 > debounce_thresh1) {
   \                     ??TIMER0_B1_ISR_2:
   \   000022   9292........ CMP.W   &debounce_count1, &debounce_thresh1
   \   000028   092C         JC      ??TIMER0_B1_ISR_3
    218                          debounce_count1 = BEGINNING;
   \   00002A   8243....     MOV.W   #0x0, &debounce_count1
    219                          debouncing1 = FALSE;
   \   00002E   8243....     MOV.W   #0x0, &debouncing1
    220                          P4IE |= SW1;
   \   000032   E2D33B02     BIS.B   #0x2, &0x23b
    221                          TB0CCTL1 &= ~CCIE;
   \   000036   B2C010008403 BIC.W   #0x10, &0x384
    222                      }
    223          
    224                      TB0CCR1 += TB0CCR1_INTERVAL; // Add Offset to TBCCR1
   \                     ??TIMER0_B1_ISR_3:
   \   00003C   B25050C39403 ADD.W   #0xc350, &0x394
    225          
    226                      break;
   \   000042   153C         JMP     ??TIMER0_B1_ISR_1
    227          
    228                  case 4: // CCR2 not used
    229                      if(debouncing2 == TRUE) debounce_count2++;
   \                     ??TIMER0_B1_ISR_7:
   \   000044   9293....     CMP.W   #0x1, &debouncing2
   \   000048   0220         JNE     ??TIMER0_B1_ISR_4
   \   00004A   9253....     ADD.W   #0x1, &debounce_count2
    230          
    231                      if (debounce_count2 > debounce_thresh2) {
   \                     ??TIMER0_B1_ISR_4:
   \   00004E   9292........ CMP.W   &debounce_count2, &debounce_thresh2
   \   000054   092C         JC      ??TIMER0_B1_ISR_5
    232                          debounce_count2 = BEGINNING;
   \   000056   8243....     MOV.W   #0x0, &debounce_count2
    233                          debouncing2 = FALSE;
   \   00005A   8243....     MOV.W   #0x0, &debouncing2
    234                          P2IE |= SW2;
   \   00005E   F2D21B02     BIS.B   #0x8, &0x21b
    235                          TB0CCTL2 &= ~CCIE;
   \   000062   B2C010008603 BIC.W   #0x10, &0x386
    236                      }
    237          
    238                      TB0CCR2 += TB0CCR2_INTERVAL; // Add Offset to TBCCR2
   \                     ??TIMER0_B1_ISR_5:
   \   000068   B25050C39603 ADD.W   #0xc350, &0x396
    239          
    240                      break;
    241          
    242                  case 14: // overflow
    243          
    244                      break;
    245          
    246                  default:
    247                      break;
    248              }
    249          
    250              //----------------------------------------------------------------------------
    251          }
   \                     ??TIMER0_B1_ISR_1:
   \   00006E   3F41         POP.W   R15
   \   000070   0013         RETI
   \   000072                REQUIRE _A_PBIE_L
   \   000072                REQUIRE _A_TB0CCTL1_L
   \   000072                REQUIRE _A_TB0CCR1_L
   \   000072                REQUIRE _A_PAIE_L
   \   000072                REQUIRE _A_TB0CCTL2_L
   \   000072                REQUIRE _A_TB0CCR2_L
   \   000072                REQUIRE _A_TB0IV_L
    252          
    253          //===========================================================================
    254          // Function name: TIMER1_B0_ISR
    255          //
    256          // Description: Timer B1 isr; enables IOT, updates stopwatch, updates ping
    257          // flag, sets update_display
    258          //
    259          // Passed : no variables passed
    260          // Locals: no variables declared
    261          // Returned: no values returned
    262          // Globals: commandReceieved, state, stopwatchUpdated, timeElapsedMilliseconds
    263          // pingCounter, pingFlag, update_display
    264          //
    265          // Author: Ibrahim Moghul
    266          // Date: Feb 2022
    267          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    268          //===========================================================================
    269          
    270          #pragma vector = TIMER1_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    271          __interrupt void Timer1_B0_ISR(void) {
   \                     Timer1_B0_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
    272              //------------------------------------------------------------------------------
    273              // TimerB0 0 Interrupt handler
    274              //----------------------------------------------------------------------------
    275              P3OUT |= IOT_EN_CPU;
   \   000002   F2D080002202 BIS.B   #0x80, &0x222
    276          
    277              if(commandsReceieved && state != DONE) {
   \   000008   C293....     CMP.B   #0x0, &commandsReceieved
   \   00000C   1024         JEQ     ??Timer1_B0_ISR_0
   \   00000E   F2906400.... CMP.B   #0x64, &state
   \   000014   0C24         JEQ     ??Timer1_B0_ISR_0
    278                  stopwatchUpdated = true;
   \   000016   9243....     MOV.W   #0x1, &stopwatchUpdated
    279                  timeElapsedMilliseconds += STOP_WATCH_INCREMENT;
   \   00001A   A253....     ADD.W   #0x2, &timeElapsedMilliseconds
    280          
    281                  if(timeElapsedMilliseconds >= MS_IN_SEC) {
   \   00001E   B2900A00.... CMP.W   #0xa, &timeElapsedMilliseconds
   \   000024   0438         JL      ??Timer1_B0_ISR_0
    282                      timeElapsedMilliseconds = BEGINNING;
   \   000026   8243....     MOV.W   #0x0, &timeElapsedMilliseconds
    283                      timeElapsedSeconds++;
   \   00002A   9253....     ADD.W   #0x1, &timeElapsedSeconds
    284                  }
    285              }
    286          
    287              if(pingCounter++ >= PING_COUNT_MAX) {
   \                     ??Timer1_B0_ISR_0:
   \   00002E   5E42....     MOV.B   &pingCounter, R14
   \   000032   4F4E         MOV.B   R14, R15
   \   000034   5F53         ADD.B   #0x1, R15
   \   000036   C24F....     MOV.B   R15, &pingCounter
   \   00003A   7E900A00     CMP.B   #0xa, R14
   \   00003E   0428         JNC     ??Timer1_B0_ISR_1
    288                  pingCounter = BEGINNING;
   \   000040   C243....     MOV.B   #0x0, &pingCounter
    289                  pingFlag = true;
   \   000044   D243....     MOV.B   #0x1, &pingFlag
    290              }
    291          
    292              update_display = true;
   \                     ??Timer1_B0_ISR_1:
   \   000048   D243....     MOV.B   #0x1, &update_display
    293              TB1CCR0 += TB1CCR0_INTERVAL;
   \   00004C   B25050C3D203 ADD.W   #0xc350, &0x3d2
    294              //----------------------------------------------------------------------------
    295          }
   \   000052   1E17         POPM.W  #0x2, R15
   \   000054   0013         RETI
   \   000056                REQUIRE _A_PBOUT_L
   \   000056                REQUIRE _A_TB1CCR0_L
    296          
    297          //===========================================================================
    298          // Function name: TIMER1_B1_ISR
    299          //
    300          // Description: Timer B0 isr, eanbles motor switching after delay
    301          //
    302          // Passed : no variables passed
    303          // Locals: no variables declared
    304          // Returned: no values returned
    305          // Globals: leftSwitchable, rightSwitchable
    306          //
    307          // Author: Ibrahim Moghul
    308          // Date: Feb 2022
    309          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    310          //===========================================================================
    311          
    312          #pragma vector=TIMER1_B1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    313          __interrupt void TIMER1_B1_ISR(void) {
   \                     TIMER1_B1_ISR:
   \   000000   0F12         PUSH.W  R15
    314              //----------------------------------------------------------------------------
    315              // TimerB0 1-2, Overflow Interrupt Vector (TBIV) handler
    316              //----------------------------------------------------------------------------
    317              switch(__even_in_range(TB1IV, 14)) {
   \   000002   1F42EE03     MOV.W   &0x3ee, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for TIMER1_B1_ISR>_0`:
   \   000008   123C         JMP     ??TIMER1_B1_ISR_1
   \   00000A   063C         JMP     ??TIMER1_B1_ISR_2
   \   00000C   0B3C         JMP     ??TIMER1_B1_ISR_3
   \   00000E   0F3C         JMP     ??TIMER1_B1_ISR_1
   \   000010   0E3C         JMP     ??TIMER1_B1_ISR_1
   \   000012   0D3C         JMP     ??TIMER1_B1_ISR_1
   \   000014   0C3C         JMP     ??TIMER1_B1_ISR_1
   \   000016   0B3C         JMP     ??TIMER1_B1_ISR_1
    318                  case 0:
    319                      break; // No interrupt
    320          
    321                  case 2: // Left Motor
    322                      leftSwitchable = true;
   \                     ??TIMER1_B1_ISR_2:
   \   000018   9243....     MOV.W   #0x1, &leftSwitchable
    323                      TB1CCTL1 &= ~CCIE;
   \   00001C   B2C01000C403 BIC.W   #0x10, &0x3c4
    324          
    325                      break;
   \   000022   053C         JMP     ??TIMER1_B1_ISR_1
    326          
    327                  case 4: // Right Motor
    328          
    329                      rightSwitchable = true;
   \                     ??TIMER1_B1_ISR_3:
   \   000024   9243....     MOV.W   #0x1, &rightSwitchable
    330                      TB1CCTL2 &= ~CCIE;
   \   000028   B2C01000C603 BIC.W   #0x10, &0x3c6
    331          
    332                      break;
    333          
    334                  case 14: // overflow
    335          
    336                      break;
    337          
    338                  default:
    339                      break;
    340              }
    341          
    342              //----------------------------------------------------------------------------
    343          }
   \                     ??TIMER1_B1_ISR_1:
   \   00002E   3F41         POP.W   R15
   \   000030   0013         RETI
   \   000032                REQUIRE _A_TB1CCTL1_L
   \   000032                REQUIRE _A_TB1CCTL2_L
   \   000032                REQUIRE _A_TB1IV_L

   \                                 In  segment INTVEC, offset 0x50, root
   \                     `??TIMER1_B1_ISR::??INTVEC 80`:
   \   000050   ....         DC16    TIMER1_B1_ISR

   \                                 In  segment INTVEC, offset 0x52, root
   \                     `??Timer1_B0_ISR::??INTVEC 82`:
   \   000052   ....         DC16    Timer1_B0_ISR

   \                                 In  segment INTVEC, offset 0x54, root
   \                     `??TIMER0_B1_ISR::??INTVEC 84`:
   \   000054   ....         DC16    TIMER0_B1_ISR

   \                                 In  segment INTVEC, offset 0x56, root
   \                     `??Timer0_B0_ISR::??INTVEC 86`:
   \   000056   ....         DC16    Timer0_B0_ISR

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for debounce_thresh1>`:
   \   000000   0A00         DC16 10

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for debounce_thresh2>`:
   \   000000   0A00         DC16 10

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Init_Timer_B0
      4   Init_Timer_B1
      4   Init_Timer_B3
      4   Init_Timers
        4   -> Init_Timer_B0
        4   -> Init_Timer_B1
        4   -> Init_Timer_B3
      6   TIMER0_B1_ISR
      6   TIMER1_B1_ISR
      8   Timer0_B0_ISR
      8   Timer1_B0_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for debounce_thresh1>
       2  ?<Initializer for debounce_thresh2>
      44  Init_Timer_B0
      32  Init_Timer_B1
      54  Init_Timer_B3
      14  Init_Timers
     114  TIMER0_B1_ISR
       2  TIMER0_B1_ISR::??INTVEC 84
      50  TIMER1_B1_ISR
       2  TIMER1_B1_ISR::??INTVEC 80
       2  Time_Sequence
      78  Timer0_B0_ISR
       2  Timer0_B0_ISR::??INTVEC 86
      86  Timer1_B0_ISR
       2  Timer1_B0_ISR::??INTVEC 82
       2  _A_ADCCTL0_L
       2  _A_PAIE_L
       2  _A_PBIE_L
       2  _A_PBOUT_L
       2  _A_TB0CCR0_L
       2  _A_TB0CCR1_L
       2  _A_TB0CCR2_L
       2  _A_TB0CCTL0_L
       2  _A_TB0CCTL1_L
       2  _A_TB0CCTL2_L
       2  _A_TB0CTL_L
       2  _A_TB0EX0_L
       2  _A_TB0IV_L
       2  _A_TB1CCR0_L
       2  _A_TB1CCTL0_L
       2  _A_TB1CCTL1_L
       2  _A_TB1CCTL2_L
       2  _A_TB1CTL_L
       2  _A_TB1EX0_L
       2  _A_TB1IV_L
       2  _A_TB3CCR0_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
       2  _A_TB3CCR3_L
       2  _A_TB3CCR4_L
       2  _A_TB3CCTL1_L
       2  _A_TB3CCTL2_L
       2  _A_TB3CCTL3_L
       2  _A_TB3CCTL4_L
       2  _A_TB3CTL_L
       2  backliteCounter
       2  checkAdc
       2  debounce_count1
       2  debounce_count2
       2  debounce_thresh1
       2  debounce_thresh2
       2  debouncing1
       2  debouncing2
       1  pingCounter
       1  pingFlag
       2  stopwatchUpdated
       2  timeElapsedMilliseconds
       2  timeElapsedSeconds
       4  timer0Counter

 
 144 bytes in segment CODE
  60 bytes in segment DATA16_AN
   4 bytes in segment DATA16_I
   4 bytes in segment DATA16_ID
  26 bytes in segment DATA16_Z
   8 bytes in segment INTVEC
 328 bytes in segment ISR_CODE
 
 472 bytes of CODE  memory
   4 bytes of CONST memory (+  8 bytes shared)
  30 bytes of DATA  memory (+ 60 bytes shared)

Errors: none
Warnings: none
