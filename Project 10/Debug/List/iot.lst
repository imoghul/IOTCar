###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          25/Apr/2022  16:03:34
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\test\Project 10\iot.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWEFEC.tmp
#        ("C:\Users\saad\Documents\test\Project 10\iot.c" -lC
#        "C:\Users\saad\Documents\test\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\test\Project 10\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\test\Project 10\Debug\List\iot.lst
#    Object file   =  C:\Users\saad\Documents\test\Project 10\Debug\Obj\iot.r43
#
###############################################################################

C:\Users\saad\Documents\test\Project 10\iot.c
      1          #include "iot.h"
      2          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2
      3          #include "utils.h"
      4          #include "menu.h"
      5          #include <string.h>
      6          #include "wheels.h"
      7          #include "utils.h"
      8          #include "serial.h"
      9          #include "macros.h"
     10          #include "ports.h"
     11          #include "sm.h"
     12          

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     13          char iot_setup_state = BOOT_UP;
   \                     iot_setup_state:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for iot_setup_state>`
     14          extern volatile char USB0_Char_Tx[];
     15          extern unsigned volatile int pb0_buffered;
     16          extern volatile char USB0_Char_Rx_Process[];
     17          extern volatile char receievedFromPC;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          char SSID[SSID_LEN + 1];
   \                     SSID:
   \   000000                DS8 11

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          char IP[IP_LEN + 1];
   \                     IP:
   \   000000                DS8 14
     20          extern volatile unsigned char display_changed;
     21          extern char display_line[4][11];

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          char dotFound;
   \                     dotFound:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          int midIndex;
   \                     midIndex:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          command CommandBuffer[COMMAND_BUFFER_LEN];
   \                     CommandBuffer:
   \   000000                DS8 20

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          char cb_index;
   \                     cb_index:
   \   000000                DS8 1
     26          extern volatile int stateCounter;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          char commandsReceieved;
   \                     commandsReceieved:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     28          char currentStation;
   \                     currentStation:
   \   000000                DS8 1
     29          extern int commandDisplayCounter;
     30          extern volatile unsigned int cycle_count;
     31          extern volatile unsigned int stopwatch_milliseconds;
     32          extern volatile unsigned int stopwatch_seconds;
     33          
     34          extern volatile char state;
     35          extern volatile int stateCounter, driveStateCounter;
     36          extern volatile char nextState;
     37          
     38          extern int speedRight, speedLeft;
     39          extern unsigned int driveTime;
     40          
     41          extern volatile char pingFlag;
     42          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     43          command emptyCommand = {0, 0};
   \                     emptyCommand:
   \   000000                DS8 4

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     44          command currCommand;
   \                     currCommand:
   \   000000                DS8 4
     45          
     46          
     47          //===========================================================================
     48          // Function name: Init_IOT
     49          //
     50          // Description: This function initializes the IOT, and gets it connected to
     51          // the local network, and ready to communicate with other devices, it also
     52          // ensures it stays connected with periodic pings
     53          //
     54          // Passed : no variables passed
     55          // Locals: isTransmitting
     56          // Returned: whether the iot module is available or not
     57          // Globals: iot_setup_state, pingFlag,pb0_buffered
     58          //
     59          // Author: Ibrahim Moghul
     60          // Date: Apr 2022
     61          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     62          //===========================================================================
     63          

   \                                 In  segment CODE, align 2
     64          int Init_IOT(void) {
   \                     Init_IOT:
   \   000000   0A12         PUSH.W  R10
     65              int isTransmitting = UCA0IE & UCTXIE;
   \   000002   1A421A05     MOV.W   &0x51a, R10
   \   000006   2AF3         AND.W   #0x2, R10
     66          
     67              switch(iot_setup_state) {
   \   000008   5E42....     MOV.B   &iot_setup_state, R14
   \   00000C   7E804200     SUB.B   #0x42, R14
   \   000010   1524         JEQ     ??Init_IOT_9
   \   000012   7E800700     SUB.B   #0x7, R14
   \   000016   4524         JEQ     ??Init_IOT_10
   \   000018   6E82         SUB.B   #0x4, R14
   \   00001A   1324         JEQ     ??Init_IOT_11
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   3524         JEQ     ??Init_IOT_12
   \   000020   7E800500     SUB.B   #0x5, R14
   \   000024   2024         JEQ     ??Init_IOT_13
   \   000026   7E801600     SUB.B   #0x16, R14
   \   00002A   4224         JEQ     ??Init_IOT_14
   \   00002C   6E82         SUB.B   #0x4, R14
   \   00002E   1024         JEQ     ??Init_IOT_15
   \   000030   5E83         SUB.B   #0x1, R14
   \   000032   3224         JEQ     ??Init_IOT_16
   \   000034   7E800500     SUB.B   #0x5, R14
   \   000038   1D24         JEQ     ??Init_IOT_17
   \   00003A   413C         JMP     ??Init_IOT_7
     68                  case (BOOT_UP):
     69                      waitForReady();
   \                     ??Init_IOT_9:
   \   00003C   ........     CALLA   #waitForReady
     70                      break;
   \   000040   4B3C         JMP     ??Init_IOT_1
     71          
     72                  case CIPMUX_Tx:
     73                      SendIOTCommand(ALLOW_MULTIPLE_CONNECTIONS, CIPMUX_Rx);
   \                     ??Init_IOT_11:
   \   000042   7D406D00     MOV.B   #0x6d, R13
   \   000046   3C40....     MOV.W   #`?<Constant "AT+CIPMUX=1\\r\\n">`, R12
   \   00004A   ........     CALLA   #SendIOTCommand
     74                      break;
   \   00004E   443C         JMP     ??Init_IOT_1
     75          
     76                  case CIPMUX_Rx:
     77                      if(isTransmitting) break; // wait for the Tx to completely transmit
   \                     ??Init_IOT_15:
   \   000050   0A93         CMP.W   #0x0, R10
   \   000052   4220         JNE     ??Init_IOT_1
     78          
     79                      if(pb0_buffered) { // wait for pb to finish buffering
   \   000054   8293....     CMP.W   #0x0, &pb0_buffered
   \   000058   3F24         JEQ     ??Init_IOT_1
     80                          iot_setup_state = CIPSERVER_Tx;
   \   00005A   F2405300.... MOV.B   #0x53, &iot_setup_state
     81                          clearProcessBuff_0();
   \   000060   ........     CALLA   #clearProcessBuff_0
     82                      }
     83          
     84                      break;
   \   000064   393C         JMP     ??Init_IOT_1
     85          
     86                  case CIPSERVER_Tx:
     87                      SendIOTCommand(START_SERVER, CIPSERVER_Rx);
   \                     ??Init_IOT_13:
   \   000066   7D407300     MOV.B   #0x73, R13
   \   00006A   3C40....     MOV.W   #`?<Constant "AT+CIPSERVER=1,4764\\r\\n">`, R12
   \   00006E   ........     CALLA   #SendIOTCommand
     88                      break;
   \   000072   323C         JMP     ??Init_IOT_1
     89          
     90                  case CIPSERVER_Rx:
     91                      if(isTransmitting) break;
   \                     ??Init_IOT_17:
   \   000074   0A93         CMP.W   #0x0, R10
   \   000076   3020         JNE     ??Init_IOT_1
     92          
     93                      if(pb0_buffered) {
   \   000078   8293....     CMP.W   #0x0, &pb0_buffered
   \   00007C   2D24         JEQ     ??Init_IOT_1
     94                          iot_setup_state = GET_SSID_Tx;
   \   00007E   F2404E00.... MOV.B   #0x4e, &iot_setup_state
     95                          clearProcessBuff_0();
   \   000084   ........     CALLA   #clearProcessBuff_0
     96                      }
     97          
     98                      break;
   \   000088   273C         JMP     ??Init_IOT_1
     99          
    100                  case GET_SSID_Tx:
    101                      SendIOTCommand(SSID_COMMAND, GET_SSID_Rx);
   \                     ??Init_IOT_12:
   \   00008A   7D406E00     MOV.B   #0x6e, R13
   \   00008E   3C40....     MOV.W   #`?<Constant "AT+CWJAP?\\r\\n">`, R12
   \   000092   ........     CALLA   #SendIOTCommand
    102                      break;
   \   000096   203C         JMP     ??Init_IOT_1
    103          
    104                  case GET_SSID_Rx:
    105                      if(isTransmitting) break;
   \                     ??Init_IOT_16:
   \   000098   0A93         CMP.W   #0x0, R10
   \   00009A   1E20         JNE     ??Init_IOT_1
    106          
    107                      getSSID();
   \   00009C   ........     CALLA   #getSSID
    108          
    109                      break;
   \   0000A0   1B3C         JMP     ??Init_IOT_1
    110          
    111                  case GET_IP_Tx:
    112                      SendIOTCommand(IP_COMMAND, GET_IP_Rx);
   \                     ??Init_IOT_10:
   \   0000A2   7D406900     MOV.B   #0x69, R13
   \   0000A6   3C40....     MOV.W   #`?<Constant "AT+CIFSR\\r\\n">`, R12
   \   0000AA   ........     CALLA   #SendIOTCommand
    113                      break;
   \   0000AE   143C         JMP     ??Init_IOT_1
    114          
    115                  case GET_IP_Rx:
    116                      if(isTransmitting) break;
   \                     ??Init_IOT_14:
   \   0000B0   0A93         CMP.W   #0x0, R10
   \   0000B2   1220         JNE     ??Init_IOT_1
    117          
    118                      getIP();
   \   0000B4   ........     CALLA   #getIP
    119                      displayNetworkInfo();
   \   0000B8   ........     CALLA   #displayNetworkInfo
    120          
    121                      break;
   \   0000BC   0D3C         JMP     ??Init_IOT_1
    122          
    123                  default:
    124                      if(pingFlag) {
   \                     ??Init_IOT_7:
   \   0000BE   C293....     CMP.B   #0x0, &pingFlag
   \   0000C2   0824         JEQ     ??Init_IOT_18
    125                          pingFlag = 0;
   \   0000C4   C243....     MOV.B   #0x0, &pingFlag
    126                          SendIOTCommand(PING_COMMAND, IOT_SETUP_FINISHED);
   \   0000C8   7D404600     MOV.B   #0x46, R13
   \   0000CC   3C40....     MOV.W   #`?<Constant "AT+PING=\\"www.google.c...">`, R12
   \   0000D0   ........     CALLA   #SendIOTCommand
    127                      }
    128          
    129                      return 1;
   \                     ??Init_IOT_18:
   \   0000D4   1C43         MOV.W   #0x1, R12
   \   0000D6   013C         JMP     ??Init_IOT_8
    130                      break;
    131              }
    132          
    133              return 0;
   \                     ??Init_IOT_1:
   \   0000D8   0C43         MOV.W   #0x0, R12
   \                     ??Init_IOT_8:
   \   0000DA   3A41         POP.W   R10
   \   0000DC   1001         RETA
   \   0000DE                REQUIRE _A_UCA0IE_L
    134          }
    135          
    136          //===========================================================================
    137          // Function name: waitForRead
    138          //
    139          // Description: This function waits for the final boot up output from the iot
    140          // before moving on in the initialization process for the iot
    141          //
    142          // Passed : no variables passed
    143          // Locals: no variables declared
    144          // Returned: no values returned
    145          // Globals: pb0_buffered, USB0_Char_Rx_Process, iot_setup_state
    146          //
    147          // Author: Ibrahim Moghul
    148          // Date: Apr 2022
    149          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    150          //===========================================================================

   \                                 In  segment CODE, align 2
    151          void waitForReady(void) {
   \                     waitForReady:
    152              if(pb0_buffered) {
   \   000000   8293....     CMP.W   #0x0, &pb0_buffered
   \   000004   0D24         JEQ     ??waitForReady_0
    153                  if(!strcmp((char*)USB0_Char_Rx_Process, BOOT_RESPONSE)) iot_setup_state = CIPMUX_Tx;
   \   000006   3D40....     MOV.W   #`?<Constant "WIFI GOT IP\\r\\n">`, R13
   \   00000A   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   00000E   ........     CALLA   #strcmp
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   0320         JNE     ??waitForReady_1
   \   000016   F2404D00.... MOV.B   #0x4d, &iot_setup_state
    154          
    155                  clearProcessBuff_0();
   \                     ??waitForReady_1:
   \   00001C   ........     CALLA   #clearProcessBuff_0
    156              }
    157          }
   \                     ??waitForReady_0:
   \   000020   1001         RETA
    158          
    159          //===========================================================================
    160          // Function name: SendIOTCommand
    161          //
    162          // Description: This function loads a command to transmit to the IOT
    163          // into the tx buffer, and enables the interrupt to begin the transmition
    164          // it then transitions to the next state in the setup process
    165          //
    166          // Passed : command, nextState
    167          // Locals: no variables declared
    168          // Returned: no values returned
    169          // Globals: iot_setup_state
    170          //
    171          // Author: Ibrahim Moghul
    172          // Date: Apr 2022
    173          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    174          //===========================================================================
    175          

   \                                 In  segment CODE, align 2
    176          void SendIOTCommand(char* command, char nextState) {
   \                     SendIOTCommand:
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   4A4D         MOV.B   R13, R10
    177              strcpy((char*)USB0_Char_Tx, command);
   \   000006   0D4B         MOV.W   R11, R13
   \   000008   3C40....     MOV.W   #USB0_Char_Tx, R12
   \   00000C   ........     CALLA   #strcpy
    178              USCI_A0_transmit();
   \   000010   ........     CALLA   #USCI_A0_transmit
    179              iot_setup_state = nextState;
   \   000014   C24A....     MOV.B   R10, &iot_setup_state
    180          }
   \   000018   1A17         POPM.W  #0x2, R11
   \   00001A   1001         RETA
    181          
    182          //===========================================================================
    183          // Function name: getSSID
    184          //
    185          // Description: This function waits for and parses the SSID
    186          //
    187          // Passed : no variables passed
    188          // Locals: no variables declared
    189          // Returned: no values returned
    190          // Globals: SSID, USB0_Char_Rx_Process,iot_setup_state
    191          //
    192          // Author: Ibrahim Moghul
    193          // Date: Apr 2022
    194          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    195          //===========================================================================
    196          

   \                                 In  segment CODE, align 2
    197          void getSSID(void) {
   \                     getSSID:
    198              if(pb0_buffered) {
   \   000000   8293....     CMP.W   #0x0, &pb0_buffered
   \   000004   2224         JEQ     ??getSSID_2
    199                  if(subStringPos((char*)USB0_Char_Rx_Process, SSID_RESPONSE)) {
   \   000006   3D40....     MOV.W   #`?<Constant "+CWJAP:">`, R13
   \   00000A   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   00000E   ........     CALLA   #subStringPos
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   1524         JEQ     ??getSSID_3
    200                      int i;
    201          
    202                      for(i = 0; i <= SSID_LEN && USB0_Char_Rx_Process[i + SSID_RESPONSE_LEN + 1] != '\"'; ++i) SSID[i] = USB0_Char_Rx_Process[i + SSID_RESPONSE_LEN + 1];
   \   000016   0F43         MOV.W   #0x0, R15
   \                     ??getSSID_0:
   \   000018   3F900B00     CMP.W   #0xb, R15
   \   00001C   0934         JGE     ??getSSID_4
   \   00001E   FF902200.... CMP.B   #0x22, LWRD(USB0_Char_Rx_Process + 8)(R15)
   \   000024   0524         JEQ     ??getSSID_4
   \   000026   DF4F........ MOV.B   LWRD(USB0_Char_Rx_Process + 8)(R15), SSID(R15)
   \   00002C   1F53         ADD.W   #0x1, R15
   \   00002E   F43F         JMP     ??getSSID_0
    203          
    204                      SSID[i + SSID_RESPONSE_LEN + 2] = '\0'; // set the end of the SSID to null
   \                     ??getSSID_4:
   \   000030   CF43....     MOV.B   #0x0, SSID + 9(R15)
    205                      SSID[SSID_LEN] = '\0'; //  set end of the array to null
   \   000034   C243....     MOV.B   #0x0, &SSID + 10
    206          
    207                      iot_setup_state = GET_IP_Tx;
   \   000038   F2404900.... MOV.B   #0x49, &iot_setup_state
   \   00003E   033C         JMP     ??getSSID_1
    208                  } else iot_setup_state = GET_SSID_Tx;
   \                     ??getSSID_3:
   \   000040   F2404E00.... MOV.B   #0x4e, &iot_setup_state
    209          
    210                  clearProcessBuff_0();
   \                     ??getSSID_1:
   \   000046   ........     CALLA   #clearProcessBuff_0
    211              }
    212          }
   \                     ??getSSID_2:
   \   00004A   1001         RETA
    213          
    214          //===========================================================================
    215          // Function name: getIP
    216          //
    217          // Description: This function waits for and parses the IP address
    218          //
    219          // Passed : no variables passed
    220          // Locals: no variables declared
    221          // Returned: no values returned
    222          // Globals: IP, USB0_Char_Rx_Process,iot_setup_state, midIndex
    223          //
    224          // Author: Ibrahim Moghul
    225          // Date: Apr 2022
    226          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    227          //===========================================================================
    228          

   \                                 In  segment CODE, align 2
    229          void getIP(void) {
   \                     getIP:
    230              if(pb0_buffered) {
   \   000000   8293....     CMP.W   #0x0, &pb0_buffered
   \   000004   3124         JEQ     ??getIP_2
    231                  if(subStringPos((char*)USB0_Char_Rx_Process, IP_RESPONSE)) {
   \   000006   3D40....     MOV.W   #`?<Constant "+CIFSR:STAIP,">`, R13
   \   00000A   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   00000E   ........     CALLA   #subStringPos
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   2424         JEQ     ??getIP_3
    232                      int i;
    233          
    234                      for(i = 0; i <= IP_LEN && USB0_Char_Rx_Process[i + IP_RESPONSE_LEN + 1] != '"'; ++i) {
   \   000016   0F43         MOV.W   #0x0, R15
   \                     ??getIP_0:
   \   000018   3F900E00     CMP.W   #0xe, R15
   \   00001C   1434         JGE     ??getIP_4
   \   00001E   FF902200.... CMP.B   #0x22, LWRD(USB0_Char_Rx_Process + 14)(R15)
   \   000024   1024         JEQ     ??getIP_4
    235                          IP[i] = USB0_Char_Rx_Process[i + IP_RESPONSE_LEN + 1];
   \   000026   DF4F........ MOV.B   LWRD(USB0_Char_Rx_Process + 14)(R15), IP(R15)
    236          
    237                          if(IP[i] == '.') {
   \   00002C   FF902E00.... CMP.B   #0x2e, IP(R15)
   \   000032   0720         JNE     ??getIP_5
    238                              if(++dotFound == MID_DOT) midIndex = i;
   \   000034   D253....     ADD.B   #0x1, &dotFound
   \   000038   E293....     CMP.B   #0x2, &dotFound
   \   00003C   0220         JNE     ??getIP_5
   \   00003E   824F....     MOV.W   R15, &midIndex
    239                          }
    240                      }
   \                     ??getIP_5:
   \   000042   1F53         ADD.W   #0x1, R15
   \   000044   E93F         JMP     ??getIP_0
    241          
    242                      IP[i + IP_RESPONSE_LEN + 2] = '\0'; // set end of IP to null
   \                     ??getIP_4:
   \   000046   CF43....     MOV.B   #0x0, LWRD(IP + 15)(R15)
    243                      IP[IP_LEN] = '\0'; // set end of array to null
   \   00004A   C243....     MOV.B   #0x0, &IP + 13
    244                      IP[midIndex] = '\0'; // set mid of I to null
   \   00004E   1E42....     MOV.W   &midIndex, R14
   \   000052   CE43....     MOV.B   #0x0, IP(R14)
    245          
    246                      iot_setup_state = IOT_SETUP_FINISHED;
   \   000056   F2404600.... MOV.B   #0x46, &iot_setup_state
   \   00005C   033C         JMP     ??getIP_1
    247                  } else iot_setup_state = GET_IP_Tx;
   \                     ??getIP_3:
   \   00005E   F2404900.... MOV.B   #0x49, &iot_setup_state
    248          
    249                  clearProcessBuff_0();
   \                     ??getIP_1:
   \   000064   ........     CALLA   #clearProcessBuff_0
    250              }
    251          }
   \                     ??getIP_2:
   \   000068   1001         RETA
    252          
    253          //===========================================================================
    254          // Function name: displayNetworkInfo
    255          //
    256          // Description: This function displays the network information
    257          //
    258          // Passed : no variables passed
    259          // Locals: no variables declared
    260          // Returned: no values returned
    261          // Globals: display_changed, SSID
    262          //
    263          // Author: Ibrahim Moghul
    264          // Date: Apr 2022
    265          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    266          //===========================================================================
    267          

   \                                 In  segment CODE, align 2
    268          void displayNetworkInfo(void) {
   \                     displayNetworkInfo:
    269              centerStringToDisplay(0, SSID);
   \   000000   3D40....     MOV.W   #SSID, R13
   \   000004   0C43         MOV.W   #0x0, R12
   \   000006   ........     CALLA   #centerStringToDisplay
    270              displayIP(1);
   \   00000A   1C43         MOV.W   #0x1, R12
   \   00000C   ........     CALLA   #displayIP
    271              display_changed = 1;
   \   000010   D243....     MOV.B   #0x1, &display_changed
    272          }
   \   000014   1001         RETA
    273          
    274          //===========================================================================
    275          // Function name: displayIP
    276          //
    277          // Description: This function displays the IP address centered, starting at a
    278          // desired line
    279          //
    280          // Passed : pos
    281          // Locals: no variables declared
    282          // Returned: no values returned
    283          // Globals: display_line, IP, midIndex
    284          //
    285          // Author: Ibrahim Moghul
    286          // Date: Apr 2022
    287          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    288          //===========================================================================
    289          

   \                                 In  segment CODE, align 2
    290          void displayIP(int pos) {
   \                     displayIP:
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    291              strcpy(display_line[pos], BLANK_LINE);
   \   000004   3D40....     MOV.W   #`?<Constant "          ">`, R13
   \   000008   0C4A         MOV.W   R10, R12
   \   00000A                RPT     #0xa
   \   00000A   49180C5A     ADDX.W  R10, R12
   \   00000E   3C50....     ADD.W   #display_line, R12
   \   000012   ........     CALLA   #strcpy
    292              strcpy(display_line[pos + 1], BLANK_LINE);
   \   000016   3D40....     MOV.W   #`?<Constant "          ">`, R13
   \   00001A   0C4A         MOV.W   R10, R12
   \   00001C                RPT     #0xa
   \   00001C   49180C5A     ADDX.W  R10, R12
   \   000020   3C50....     ADD.W   #display_line + 11, R12
   \   000024   ........     CALLA   #strcpy
    293              centerStringToDisplay(pos, IP);
   \   000028   3D40....     MOV.W   #IP, R13
   \   00002C   0C4A         MOV.W   R10, R12
   \   00002E   ........     CALLA   #centerStringToDisplay
    294              centerStringToDisplay(pos + 1, IP + midIndex + 1);
   \   000032   3D40....     MOV.W   #IP + 1, R13
   \   000036   1D52....     ADD.W   &midIndex, R13
   \   00003A   0C4A         MOV.W   R10, R12
   \   00003C   1C53         ADD.W   #0x1, R12
   \   00003E   ........     CALLA   #centerStringToDisplay
    295          }
   \   000042   3A41         POP.W   R10
   \   000044   1001         RETA
    296          
    297          
    298          //===========================================================================
    299          // Function name: IOTBufferCommands
    300          //
    301          // Description: This function reads the serial input from the IOT and 
    302          // converts them into "commands" that the rest of the program can understand
    303          // and then pushes it onto CommandBuffer, until there are no more recognzied
    304          // command, it also checks whether the iot has disconnected and restarts the
    305          // initialization process if so
    306          //
    307          // Passed : no variables passed
    308          // Locals: pos,end_caret,end_null,end,time,c,comm
    309          // Returned: no values returned
    310          // Globals: USB0_Char_Rx_Process,iot_setup_state,pb0_buffered
    311          //
    312          // Author: Ibrahim Moghul
    313          // Date: Apr 2022
    314          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    315          //===========================================================================
    316          

   \                                 In  segment CODE, align 2
    317          void IOTBufferCommands(void) {
   \                     IOTBufferCommands:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   B1000400     SUBA    #0x4, SP
    318              if(pb0_buffered) {
   \   000006   8293....     CMP.W   #0x0, &pb0_buffered
   \   00000A   4424         JEQ     ??IOTBufferCommands_2
    319                  if(subStringPos((char*)USB0_Char_Rx_Process, DISCONNECTED_RESPONSE))
   \   00000C   3D40....     MOV.W   #`?<Constant "DISCONNECT">`, R13
   \   000010   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   000014   ........     CALLA   #subStringPos
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   0324         JEQ     ??IOTBufferCommands_3
    320                      iot_setup_state = CIPSERVER_Tx;
   \   00001C   F2405300.... MOV.B   #0x53, &iot_setup_state
    321          
    322                  char * pos = subStringPos((char*)USB0_Char_Rx_Process, CARET_SECURITY_CODE);
   \                     ??IOTBufferCommands_3:
   \   000022   3D40....     MOV.W   #`?<Constant "^9A73">`, R13
   \   000026   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   00002A   ........     CALLA   #subStringPos
   \   00002E   0A4C         MOV.W   R12, R10
    323          
    324                  while(pos) {
   \                     ??IOTBufferCommands_0:
   \   000030   0A93         CMP.W   #0x0, R10
   \   000032   2E24         JEQ     ??IOTBufferCommands_4
    325                      pos += CARET_SECURITY_CODE_LEN; // now should be on where the command actually is
   \   000034   3A500500     ADD.W   #0x5, R10
    326                      char comm = *pos;
   \   000038   6B4A         MOV.B   @R10, R11
    327                      pos++;
   \   00003A   1A53         ADD.W   #0x1, R10
    328                      char * end_caret = charInString(pos, CARET);
   \   00003C   7D405E00     MOV.B   #0x5e, R13
   \   000040   0C4A         MOV.W   R10, R12
   \   000042   ........     CALLA   #charInString
   \   000046   084C         MOV.W   R12, R8
    329                      char * end_null = charInString(pos, CR);
   \   000048   7D400D00     MOV.B   #0xd, R13
   \   00004C   0C4A         MOV.W   R10, R12
   \   00004E   ........     CALLA   #charInString
   \   000052   094C         MOV.W   R12, R9
    330                      char * end = end_caret ? end_caret : end_null;
   \   000054   0893         CMP.W   #0x0, R8
   \   000056   0224         JEQ     ??IOTBufferCommands_5
   \   000058   0648         MOV.W   R8, R6
   \   00005A   013C         JMP     ??IOTBufferCommands_1
   \                     ??IOTBufferCommands_5:
   \   00005C   0649         MOV.W   R9, R6
    331                      int time = stoi(pos, end - pos);
   \                     ??IOTBufferCommands_1:
   \   00005E   0D46         MOV.W   R6, R13
   \   000060   0D8A         SUB.W   R10, R13
   \   000062   0C4A         MOV.W   R10, R12
   \   000064   ........     CALLA   #stoi
   \   000068   074C         MOV.W   R12, R7
    332                      command c = {
    333                          .comm = comm,
    334                          .duration = time
    335                      };
   \   00006A   C14B0000     MOV.B   R11, 0(SP)
   \   00006E   81470200     MOV.W   R7, 0x2(SP)
    336                      pushCB(c);
   \   000072   11120400     PUSH.W  0x4(SP)
   \   000076   11120400     PUSH.W  0x4(SP)
   \   00007A   ........     CALLA   #pushCB
    337                      pos = subStringPos(pos, CARET_SECURITY_CODE);
   \   00007E   3D40....     MOV.W   #`?<Constant "^9A73">`, R13
   \   000082   0C4A         MOV.W   R10, R12
   \   000084   ........     CALLA   #subStringPos
   \   000088   0A4C         MOV.W   R12, R10
   \   00008A   A1000400     ADDA    #0x4, SP
   \   00008E   D03F         JMP     ??IOTBufferCommands_0
    338                  }
    339          
    340                  clearProcessBuff_0();
   \                     ??IOTBufferCommands_4:
   \   000090   ........     CALLA   #clearProcessBuff_0
    341              }
    342          
    343          }
   \                     ??IOTBufferCommands_2:
   \   000094   A1000400     ADDA    #0x4, SP
   \   000098   5617         POPM.W  #0x6, R11
   \   00009A   1001         RETA
    344          
    345          //===========================================================================
    346          // Function name: popCB
    347          //
    348          // Description: This function pops the oldest command for processing, then
    349          // shifts the rest to be popped later
    350          //
    351          // Passed : no variables passed
    352          // Locals: ret
    353          // Returned: oldest command
    354          // Globals: CommandBuffer,emptyCommand
    355          //
    356          // Author: Ibrahim Moghul
    357          // Date: Apr 2022
    358          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    359          //===========================================================================
    360          

   \                                 In  segment CODE, align 2
    361          command popCB(void) {
   \                     popCB:
   \   000000   0A12         PUSH.W  R10
   \   000002   B1000400     SUBA    #0x4, SP
    362              command ret = CommandBuffer[0];
   \   000006   9142....0000 MOV.W   &CommandBuffer, 0(SP)
   \   00000C   9142....0200 MOV.W   &CommandBuffer + 2, 0x2(SP)
    363          
    364              for(int i = 0; i < COMMAND_BUFFER_LEN - 1; ++i) CommandBuffer[i] = CommandBuffer[i + 1];
   \   000012   0E43         MOV.W   #0x0, R14
   \                     ??popCB_0:
   \   000014   2E92         CMP.W   #0x4, R14
   \   000016   0C34         JGE     ??popCB_1
   \   000018   0D4E         MOV.W   R14, R13
   \   00001A   5D06         RLAM.W  #0x2, R13
   \   00001C   0F4E         MOV.W   R14, R15
   \   00001E   5F06         RLAM.W  #0x2, R15
   \   000020   9D4F........ MOV.W   CommandBuffer + 4(R15), CommandBuffer(R13)
   \   000026   9D4F........ MOV.W   CommandBuffer + 6(R15), CommandBuffer + 2(R13)
   \   00002C   1E53         ADD.W   #0x1, R14
   \   00002E   F23F         JMP     ??popCB_0
    365          
    366              CommandBuffer[COMMAND_BUFFER_LEN - 1] = emptyCommand;
   \                     ??popCB_1:
   \   000030   9242........ MOV.W   &emptyCommand, &CommandBuffer + 16
   \   000036   9242........ MOV.W   &emptyCommand + 2, &CommandBuffer + 18
   \   00003C   AC410000     MOV.W   @SP, 0(R12)
   \   000040   9C4102000200 MOV.W   0x2(SP), 0x2(R12)
   \   000046   A1000400     ADDA    #0x4, SP
   \   00004A   3A41         POP.W   R10
   \   00004C   1001         RETA
    367              return ret;
    368          }
    369          
    370          //===========================================================================
    371          // Function name: pushCB
    372          //
    373          // Description: This function pushes a command onto the end of the
    374          // CommandBuffer
    375          //
    376          // Passed : c
    377          // Locals: no variables declared
    378          // Returned: no values returned
    379          // Globals: CommandBuffer
    380          //
    381          // Author: Ibrahim Moghul
    382          // Date: Apr 2022
    383          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    384          //===========================================================================
    385          

   \                                 In  segment CODE, align 2
    386          void pushCB(command c) {
   \                     pushCB:
    387              int i;
    388          
    389              for(i = 0; i < COMMAND_BUFFER_LEN; ++i)
   \   000000   0F43         MOV.W   #0x0, R15
   \                     ??pushCB_0:
   \   000002   3F900500     CMP.W   #0x5, R15
   \   000006   0C34         JGE     ??pushCB_2
    390                  if(CommandBuffer[i].comm == false && CommandBuffer[i].duration == false) break;
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   5E06         RLAM.W  #0x2, R14
   \   00000C   CE93....     CMP.B   #0x0, CommandBuffer(R14)
   \   000010   0520         JNE     ??pushCB_1
   \   000012   0E4F         MOV.W   R15, R14
   \   000014   5E06         RLAM.W  #0x2, R14
   \   000016   8E93....     CMP.W   #0x0, CommandBuffer + 2(R14)
   \   00001A   0224         JEQ     ??pushCB_2
   \                     ??pushCB_1:
   \   00001C   1F53         ADD.W   #0x1, R15
   \   00001E   F13F         JMP     ??pushCB_0
    391          
    392              if(i == COMMAND_BUFFER_LEN) {
   \                     ??pushCB_2:
   \   000020   3F900500     CMP.W   #0x5, R15
   \   000024   0824         JEQ     ??pushCB_4
    393                  return;
    394              }
    395          
    396              CommandBuffer[i] = c;
   \   000026   0E4F         MOV.W   R15, R14
   \   000028   5E06         RLAM.W  #0x2, R14
   \   00002A   9E410400.... MOV.W   0x4(SP), CommandBuffer(R14)
   \   000030   9E410600.... MOV.W   0x6(SP), CommandBuffer + 2(R14)
    397          }
   \                     ??pushCB_4:
   \   000036   1001         RETA
    398          
    399          //===========================================================================
    400          // Function name: ProcessCommands
    401          //
    402          // Description: This function processes the oldest command and implements it
    403          //
    404          // Passed : no variables passed
    405          // Locals: no variables declared
    406          // Returned: no values returned
    407          // Globals: state,currCommand,stopwatch_milliseconds,stateCounter
    408          // driveStateCounter,cycle_count,speedRight,speedLeft,driveTime,nextState,
    409          // commandDisplayCounter
    410          //
    411          // Author: Ibrahim Moghul
    412          // Date: Apr 2022
    413          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    414          //===========================================================================
    415          

   \                                 In  segment CODE, align 2
    416          void ProcessCommands(void) {
   \                     ProcessCommands:
   \   000000   B1000400     SUBA    #0x4, SP
    417              if (CommandBuffer[BEGINNING].comm == EXIT_COMMAND || CommandBuffer[BEGINNING].comm == STOP_COMMAND) {
   \   000004   F2906500.... CMP.B   #0x65, &CommandBuffer
   \   00000A   0424         JEQ     ??ProcessCommands_2
   \   00000C   F2907300.... CMP.B   #0x73, &CommandBuffer
   \   000012   0B20         JNE     ??ProcessCommands_3
    418                  state = START;
   \                     ??ProcessCommands_2:
   \   000014   F2405300.... MOV.B   #0x53, &state
    419                  stopwatch_milliseconds = BEGINNING;
   \   00001A   8243....     MOV.W   #0x0, &stopwatch_milliseconds
    420                  stateCounter = BEGINNING;
   \   00001E   8243....     MOV.W   #0x0, &stateCounter
    421                  driveStateCounter = BEGINNING;
   \   000022   8243....     MOV.W   #0x0, &driveStateCounter
    422                  ShutoffMotors();
   \   000026   ........     CALLA   #ShutoffMotors
    423              }
    424          
    425              if(state == START) {
   \                     ??ProcessCommands_3:
   \   00002A   F2905300.... CMP.B   #0x53, &state
   \   000030   7520         JNE     ??ProcessCommands_0
    426                  currCommand = popCB();
   \   000032   0C41         MOV.W   SP, R12
   \   000034   ........     CALLA   #popCB
   \   000038   A241....     MOV.W   @SP, &currCommand
   \   00003C   92410200.... MOV.W   0x2(SP), &currCommand + 2
    427          
    428                  if(currCommand.comm == false && currCommand.duration == false)return;
   \   000042   C293....     CMP.B   #0x0, &currCommand
   \   000046   0320         JNE     ??ProcessCommands_1
   \   000048   8293....     CMP.W   #0x0, &currCommand + 2
   \   00004C   6724         JEQ     ??ProcessCommands_0
    429          
    430                  commandsReceieved = true;
   \                     ??ProcessCommands_1:
   \   00004E   D243....     MOV.B   #0x1, &commandsReceieved
    431                  stopwatch_seconds = BEGINNING;
   \   000052   8243....     MOV.W   #0x0, &stopwatch_seconds
    432                  cycle_count = BEGINNING;
   \   000056   8243....     MOV.W   #0x0, &cycle_count
    433          
    434                  //driveTime = (int)(currCommand.duration * (currCommand.comm == RIGHT_COMMAND || currCommand.comm == LEFT_COMMAND ? TURN_CONSTANT : 1));
    435                  int turnTime = currCommand.duration << TURN_CONSTANT;
   \   00005A   1F42....     MOV.W   &currCommand + 2, R15
   \   00005E   5F0A         RLAM.W  #0x3, R15
    436                  switch(currCommand.comm) {
   \   000060   5E42....     MOV.B   &currCommand, R14
   \   000064   7E806200     SUB.B   #0x62, R14
   \   000068   1D24         JEQ     ??ProcessCommands_4
   \   00006A   6E83         SUB.B   #0x2, R14
   \   00006C   4724         JEQ     ??ProcessCommands_5
   \   00006E   5E83         SUB.B   #0x1, R14
   \   000070   4C24         JEQ     ??ProcessCommands_6
   \   000072   5E83         SUB.B   #0x1, R14
   \   000074   0A24         JEQ     ??ProcessCommands_7
   \   000076   7E800600     SUB.B   #0x6, R14
   \   00007A   2D24         JEQ     ??ProcessCommands_8
   \   00007C   7E800300     SUB.B   #0x3, R14
   \   000080   3624         JEQ     ??ProcessCommands_9
   \   000082   7E800300     SUB.B   #0x3, R14
   \   000086   1B24         JEQ     ??ProcessCommands_10
   \   000088   493C         JMP     ??ProcessCommands_0
    437                      case (FORWARD_COMMAND):
    438                          speedRight = STRAIGHT_RIGHT;
   \                     ??ProcessCommands_7:
   \   00008A   B2405046.... MOV.W   #0x4650, &speedRight
    439                          speedLeft = STRAIGHT_LEFT;
   \   000090   B240204E.... MOV.W   #0x4e20, &speedLeft
    440                          state = DRIVE;
   \   000096   F2404400.... MOV.B   #0x44, &state
    441                          driveTime = currCommand.duration;
   \   00009C   9242........ MOV.W   &currCommand + 2, &driveTime
    442                          break;
   \   0000A2   3C3C         JMP     ??ProcessCommands_0
    443          
    444                      case (REVERSE_COMMAND):
    445                          speedRight = -STRAIGHT_RIGHT;
   \                     ??ProcessCommands_4:
   \   0000A4   B240B0B9.... MOV.W   #0xb9b0, &speedRight
    446                          speedLeft = -STRAIGHT_LEFT;
   \   0000AA   B240E0B1.... MOV.W   #0xb1e0, &speedLeft
    447                          state = DRIVE;
   \   0000B0   F2404400.... MOV.B   #0x44, &state
    448                          driveTime = currCommand.duration;
   \   0000B6   9242........ MOV.W   &currCommand + 2, &driveTime
    449                          break;
   \   0000BC   2F3C         JMP     ??ProcessCommands_0
    450          
    451                      case (RIGHT_COMMAND):
    452                          speedRight = RIGHT_MID;
   \                     ??ProcessCommands_10:
   \   0000BE   B2403421.... MOV.W   #0x2134, &speedRight
    453                          speedLeft = -(LEFT_MID);
   \   0000C4   B240CCDE.... MOV.W   #0xdecc, &speedLeft
    454                          state = DRIVE;
   \   0000CA   F2404400.... MOV.B   #0x44, &state
    455                          driveTime = turnTime;//currCommand.duration << TURN_CONSTANT;
   \   0000D0   824F....     MOV.W   R15, &driveTime
    456                          break;
   \   0000D4   233C         JMP     ??ProcessCommands_0
    457          
    458                      case (LEFT_COMMAND):
    459                          speedRight = -(RIGHT_MID);
   \                     ??ProcessCommands_8:
   \   0000D6   B240CCDE.... MOV.W   #0xdecc, &speedRight
    460                          speedLeft = LEFT_MID;
   \   0000DC   B2403421.... MOV.W   #0x2134, &speedLeft
    461                          state = DRIVE;
   \   0000E2   F2404400.... MOV.B   #0x44, &state
    462                          driveTime = turnTime;//currCommand.duration << TURN_CONSTANT;
   \   0000E8   824F....     MOV.W   R15, &driveTime
    463                          break;
   \   0000EC   173C         JMP     ??ProcessCommands_0
    464          
    465                      case (LINEFOLLOW_COMMAND):
    466                          state = STRAIGHT;
   \                     ??ProcessCommands_9:
   \   0000EE   F2407300.... MOV.B   #0x73, &state
    467                          speedRight = currCommand.duration;
   \   0000F4   9242........ MOV.W   &currCommand + 2, &speedRight
    468                          break;
   \   0000FA   103C         JMP     ??ProcessCommands_0
    469          
    470                      case (DISPLAY_NUMBER_COMMAND):
    471                          commandDisplayCounter = DISPLAY_ARRIVAL_STATE;
   \                     ??ProcessCommands_5:
   \   0000FC   B240F401.... MOV.W   #0x1f4, &commandDisplayCounter
    472                          currentStation = currCommand.duration;
   \   000102   D242........ MOV.B   &currCommand + 2, &currentStation
    473                          break;
   \   000108   093C         JMP     ??ProcessCommands_0
    474          
    475                      case (EXIT_COMMAND):
    476                          state = WAIT;
   \                     ??ProcessCommands_6:
   \   00010A   F2405700.... MOV.B   #0x57, &state
    477                          nextState = EXIT;
   \   000110   F2406500.... MOV.B   #0x65, &nextState
    478                          speedRight = currCommand.duration;
   \   000116   9242........ MOV.W   &currCommand + 2, &speedRight
    479                          break;
    480                  }
    481              }
    482          
    483          }
   \                     ??ProcessCommands_0:
   \   00011C   A1000400     ADDA    #0x4, SP
   \   000120   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for iot_setup_state>`:
   \   000000   42           DC8 66

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CIPMUX=1\\r\\n">`:
   \   000000   41542B434950 DC8 "AT+CIPMUX=1\015\012"
   \            4D55583D310D
   \            0A00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CIPSERVER=1,4764\\r\\n">`:
   \   000000   41542B434950 DC8 "AT+CIPSERVER=1,4764\015\012"
   \            534552564552
   \            3D312C343736
   \            340D0A00    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CWJAP?\\r\\n">`:
   \   000000   41542B43574A DC8 "AT+CWJAP?\015\012"
   \            41503F0D0A00

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+CIFSR\\r\\n">`:
   \   000000   41542B434946 DC8 "AT+CIFSR\015\012"
   \            53520D0A00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+PING=\\"www.google.c...">`:
   \   000000   41542B50494E DC8 "AT+PING=\"www.google.com\"\015\012"
   \            473D22777777
   \            2E676F6F676C
   \            652E636F6D22
   \            0D0A00      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "WIFI GOT IP\\r\\n">`:
   \   000000   574946492047 DC8 "WIFI GOT IP\015\012"
   \            4F542049500D
   \            0A00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "+CWJAP:">`:
   \   000000   2B43574A4150 DC8 "+CWJAP:"
   \            3A00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "+CIFSR:STAIP,">`:
   \   000000   2B4349465352 DC8 "+CIFSR:STAIP,"
   \            3A5354414950
   \            2C00        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "          ">`:
   \   000000   202020202020 DC8 "          "
   \            2020202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "DISCONNECT">`:
   \   000000   444953434F4E DC8 "DISCONNECT"
   \            4E45435400  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "^9A73">`:
   \   000000   5E3941373300 DC8 "^9A73"

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     24   IOTBufferCommands
       20   -> charInString
       20   -> clearProcessBuff_0
       24   -> pushCB
       20   -> stoi
       20   -> subStringPos
       24   -> subStringPos
      6   Init_IOT
        6   -> SendIOTCommand
        6   -> clearProcessBuff_0
        6   -> displayNetworkInfo
        6   -> getIP
        6   -> getSSID
        6   -> waitForReady
      8   ProcessCommands
        8   -> ShutoffMotors
        8   -> popCB
      8   SendIOTCommand
        8   -> USCI_A0_transmit
        8   -> strcpy
      6   displayIP
        6   -> centerStringToDisplay
        6   -> strcpy
      4   displayNetworkInfo
        4   -> centerStringToDisplay
        4   -> displayIP
      4   getIP
        4   -> clearProcessBuff_0
        4   -> subStringPos
      4   getSSID
        4   -> clearProcessBuff_0
        4   -> subStringPos
     10   popCB
      4   pushCB
      4   waitForReady
        4   -> clearProcessBuff_0
        4   -> strcmp


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "          ">
      14  ?<Constant "+CIFSR:STAIP,">
       8  ?<Constant "+CWJAP:">
      11  ?<Constant "AT+CIFSR\r\n">
      14  ?<Constant "AT+CIPMUX=1\r\n">
      22  ?<Constant "AT+CIPSERVER=1,4764\r\n">
      12  ?<Constant "AT+CWJAP?\r\n">
      27  ?<Constant "AT+PING=\"www.google.c...">
      11  ?<Constant "DISCONNECT">
      14  ?<Constant "WIFI GOT IP\r\n">
       6  ?<Constant "^9A73">
       1  ?<Initializer for iot_setup_state>
      20  CommandBuffer
     156  IOTBufferCommands
      14  IP
     222  Init_IOT
     290  ProcessCommands
      11  SSID
      28  SendIOTCommand
       2  _A_UCA0IE_L
       1  cb_index
       1  commandsReceieved
       4  currCommand
       1  currentStation
      70  displayIP
      22  displayNetworkInfo
       1  dotFound
       4  emptyCommand
     106  getIP
      76  getSSID
       1  iot_setup_state
       2  midIndex
      78  popCB
      56  pushCB
      34  waitForReady

 
 1 138 bytes in segment CODE
     2 bytes in segment DATA16_AN
   150 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    59 bytes in segment DATA16_Z
 
 1 138 bytes of CODE  memory
   151 bytes of CONST memory
    60 bytes of DATA  memory (+ 2 bytes shared)

Errors: none
Warnings: none
