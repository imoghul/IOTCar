###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          25/Apr/2022  16:03:37
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\test\Project 10\serial.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWFB18.tmp
#        ("C:\Users\saad\Documents\test\Project 10\serial.c" -lC
#        "C:\Users\saad\Documents\test\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\test\Project 10\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\test\Project 10\Debug\List\serial.lst
#    Object file   =  
#        C:\Users\saad\Documents\test\Project 10\Debug\Obj\serial.r43
#
###############################################################################

C:\Users\saad\Documents\test\Project 10\serial.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains the Serial Routine - Serial Processes
      4          //
      5          //
      6          //  Ibrahim Moghul
      7          //  Mar 2022
      8          //  Built with IAR Embedded Workbench Version: (7.21.1)
      9          //------------------------------------------------------------------------------
     10          #include "serial.h"
     11          #include "macros.h"
     12          #include <string.h>
     13          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x500
   \   union <unnamed> _A_UCA0CTLW0_L
   \                     _A_UCA0CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x506
   \   union <unnamed> _A_UCA0BRW_L
   \                     _A_UCA0BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x508
   \   union <unnamed> _A_UCA0MCTLW_L
   \                     _A_UCA0MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50c
   \   union <unnamed> _A_UCA0RXBUF_L
   \                     _A_UCA0RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50e
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51e
   \   union <unnamed> _A_UCA0IV_L
   \                     _A_UCA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x580
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x586
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x588
   \   union <unnamed> _A_UCA1MCTLW_L
   \                     _A_UCA1MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58c
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58e
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59a
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59e
   \   union <unnamed> _A_UCA1IV_L
   \                     _A_UCA1IV_L:
   \   000000                DS8 2
     14          
     15          // global variables

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          volatile unsigned int usb0_rx_wr, usb1_rx_wr;
   \                     usb0_rx_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          unsigned int usb0_rx_rd, usb1_rx_rd;
   \                     usb0_rx_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile char USB0_Char_Rx_Ring[SMALL_RING_SIZE], USB0_Char_Rx_Process[LARGE_RING_SIZE];
   \                     USB0_Char_Rx_Ring:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB0_Char_Rx_Process:
   \   000000                DS8 100

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile char USB1_Char_Rx_Ring[SMALL_RING_SIZE], USB1_Char_Rx_Process[LARGE_RING_SIZE];
   \                     USB1_Char_Rx_Ring:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Rx_Process:
   \   000000                DS8 100

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          volatile char USB0_Char_Tx[LARGE_RING_SIZE], USB1_Char_Tx[LARGE_RING_SIZE];
   \                     USB0_Char_Tx:
   \   000000                DS8 100

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Tx:
   \   000000                DS8 100

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          unsigned volatile int pb0_index, pb1_index;
   \                     pb0_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     pb1_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          unsigned volatile int tx0_index, tx1_index;
   \                     tx0_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     tx1_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          unsigned volatile int pb0_buffered, pb1_buffered;
   \                     pb0_buffered:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     pb1_buffered:
   \   000000                DS8 2
     24          extern volatile unsigned char display_changed;
     25          extern char display_line[4][11];

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          unsigned volatile int serialState;
   \                     serialState:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          volatile char receievedFromPC = OFF;
   \                     receievedFromPC:
   \   000000                DS8 1
     28          
     29          //===========================================================================
     30          // Function name: Init_Serial_UCA
     31          //
     32          // Description: This function initializes the serial ports of the FRAM board
     33          //
     34          // Passed : no variables passed
     35          // Locals: no variables declared
     36          // Returned: no values returned
     37          // Globals: usb0_rx_wr, usb0_rx_rd, usb1_rx_wr, usb1_rx_rd, USB0_Char_Rx_Ring
     38          // , USB1_Char_Rx_ring, USB0_Char_Tx, USB1_Char_Tx
     39          //
     40          // Author: Ibrahim Moghul
     41          // Date: Apr 2022
     42          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     43          //===========================================================================

   \                                 In  segment CODE, align 2
     44          void Init_Serial_UCA(void) {
   \                     Init_Serial_UCA:
     45              int i;
     46          
     47              for(i = 0; i < SMALL_RING_SIZE; i++) {
   \   000000   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_0:
   \   000002   3F901000     CMP.W   #0x10, R15
   \   000006   0634         JGE     ??Init_Serial_UCA_2
     48                  USB0_Char_Rx_Ring[i] = 0x00;
   \   000008   CF43....     MOV.B   #0x0, USB0_Char_Rx_Ring(R15)
     49                  USB1_Char_Rx_Ring[i] = 0x00;
   \   00000C   CF43....     MOV.B   #0x0, USB1_Char_Rx_Ring(R15)
     50              }
   \   000010   1F53         ADD.W   #0x1, R15
   \   000012   F73F         JMP     ??Init_Serial_UCA_0
     51          
     52              usb0_rx_wr = BEGINNING;
   \                     ??Init_Serial_UCA_2:
   \   000014   8243....     MOV.W   #0x0, &usb0_rx_wr
     53              usb0_rx_rd = BEGINNING;
   \   000018   8243....     MOV.W   #0x0, &usb0_rx_rd
     54              usb1_rx_wr = BEGINNING;
   \   00001C   8243....     MOV.W   #0x0, &usb1_rx_wr
     55              usb1_rx_rd = BEGINNING;
   \   000020   8243....     MOV.W   #0x0, &usb1_rx_rd
     56          
     57              for(i = 0; i < LARGE_RING_SIZE; i++) {
   \   000024   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_1:
   \   000026   3F906400     CMP.W   #0x64, R15
   \   00002A   0634         JGE     ??Init_Serial_UCA_3
     58                  USB0_Char_Tx[i] = 0x00;
   \   00002C   CF43....     MOV.B   #0x0, USB0_Char_Tx(R15)
     59                  USB1_Char_Tx[i] = 0x00;
   \   000030   CF43....     MOV.B   #0x0, USB1_Char_Tx(R15)
     60              }
   \   000034   1F53         ADD.W   #0x1, R15
   \   000036   F73F         JMP     ??Init_Serial_UCA_1
     61          
     62              // Configure UART 0
     63              UCA0CTLW0 = 0;
   \                     ??Init_Serial_UCA_3:
   \   000038   82430005     MOV.W   #0x0, &0x500
     64              UCA0CTLW0 |= UCSWRST;
   \   00003C   92D30005     BIS.W   #0x1, &0x500
     65              UCA0CTLW0 |= UCSSEL__SMCLK;
   \   000040   B2D080000005 BIS.W   #0x80, &0x500
     66              // UCA0BRW = 4;
     67              // UCA0MCTLW = 0x5551;
     68              SET_UCA_115200;
   \   000046   A2420605     MOV.W   #0x4, &0x506
   \   00004A   B24051550805 MOV.W   #0x5551, &0x508
   \   000050   A2428605     MOV.W   #0x4, &0x586
   \   000054   B24051558805 MOV.W   #0x5551, &0x588
     69              UCA0CTLW0 &= ~UCSWRST;
   \   00005A   92C30005     BIC.W   #0x1, &0x500
     70              UCA0IE |= UCRXIE;
   \   00005E   92D31A05     BIS.W   #0x1, &0x51a
     71              
     72              // Configure UART 1
     73              /*UCA1CTLW0 = 0;
     74              UCA1CTLW0 |= UCSWRST;
     75              UCA1CTLW0 |= UCSSEL__SMCLK;
     76              // UCA1BRW = 4;
     77              // UCA1MCTLW = 0x5551;
     78              UCA1CTLW0 &= ~UCSWRST;
     79              UCA1IE |= UCRXIE;*/
     80              UCA1CTLW0 = UCA0CTLW0;
   \   000062   924200058005 MOV.W   &0x500, &0x580
     81              UCA1IE |= UCRXIE;
   \   000068   92D39A05     BIS.W   #0x1, &0x59a
     82          }
   \   00006C   1001         RETA
   \   00006E                REQUIRE _A_UCA0CTLW0_L
   \   00006E                REQUIRE _A_UCA0BRW_L
   \   00006E                REQUIRE _A_UCA0MCTLW_L
   \   00006E                REQUIRE _A_UCA1BRW_L
   \   00006E                REQUIRE _A_UCA1MCTLW_L
   \   00006E                REQUIRE _A_UCA0IE_L
   \   00006E                REQUIRE _A_UCA1CTLW0_L
   \   00006E                REQUIRE _A_UCA1IE_L
     83          //===========================================================================
     84          // Function name: eUSCI_A0_ISR
     85          //
     86          // Description: This is the isr for USC0, it puts all retreivals into the
     87          // ring buffer, and outputs what's in the tx buffer
     88          //
     89          // Passed : no variables passed
     90          // Locals: temp
     91          // Returned: no values returned
     92          // Globals: USB0_Char_Rx,Ring,usb0_rx_wr,recievedFromPC,tx0_index
     93          // USB0_Char_Tx
     94          //
     95          // Author: Ibrahim Moghul
     96          // Date: Apr 2022
     97          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     98          //===========================================================================
     99          #pragma vector=EUSCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    100          __interrupt void eUSCI_A0_ISR(void) {
   \                     eUSCI_A0_ISR:
   \   000000   2F15         PUSHM.W #0x3, R15
    101              unsigned int temp;
    102          
    103              switch(__even_in_range(UCA0IV, 0x08)) {
   \   000002   1F421E05     MOV.W   &0x51e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A0_ISR>_0`:
   \   000008   343C         JMP     ??eUSCI_A0_ISR_2
   \   00000A   033C         JMP     ??eUSCI_A0_ISR_4
   \   00000C   1C3C         JMP     ??eUSCI_A0_ISR_5
   \   00000E   313C         JMP     ??eUSCI_A0_ISR_2
   \   000010   303C         JMP     ??eUSCI_A0_ISR_2
    104                  case 0:
    105                      break;
    106          
    107                  case 2: // RXIFG
    108                      temp = usb0_rx_wr++;
   \                     ??eUSCI_A0_ISR_4:
   \   000012   1F42....     MOV.W   &usb0_rx_wr, R15
   \   000016   0E4F         MOV.W   R15, R14
   \   000018   1E53         ADD.W   #0x1, R14
   \   00001A   824E....     MOV.W   R14, &usb0_rx_wr
   \   00001E   0D4F         MOV.W   R15, R13
    109                      USB0_Char_Rx_Ring[temp] = UCA0RXBUF;
   \   000020   1E420C05     MOV.W   &0x50c, R14
   \   000024   CD4E....     MOV.B   R14, USB0_Char_Rx_Ring(R13)
    110          
    111                      if (usb0_rx_wr >= (SMALL_RING_SIZE)) {
   \   000028   B2901000.... CMP.W   #0x10, &usb0_rx_wr
   \   00002E   0228         JNC     ??eUSCI_A0_ISR_3
    112                          usb0_rx_wr = BEGINNING;
   \   000030   8243....     MOV.W   #0x0, &usb0_rx_wr
    113                      }
    114          
    115                      if(receievedFromPC) UCA1TXBUF = USB0_Char_Rx_Ring[temp];
   \                     ??eUSCI_A0_ISR_3:
   \   000034   C293....     CMP.B   #0x0, &receievedFromPC
   \   000038   1C24         JEQ     ??eUSCI_A0_ISR_2
   \   00003A   5F4D....     MOV.B   USB0_Char_Rx_Ring(R13), R15
   \   00003E   4F4F         MOV.B   R15, R15
   \   000040   824F8E05     MOV.W   R15, &0x58e
    116          
    117                      break;
   \   000044   163C         JMP     ??eUSCI_A0_ISR_2
    118          
    119                  case 4: // TXIFG
    120                      //if(receievedFromPC==OFF) {
    121                      //  UCA0IE &= ~UCTXIE;
    122                      //  return;
    123                      //}
    124                      UCA0TXBUF = USB0_Char_Tx[tx0_index];
   \                     ??eUSCI_A0_ISR_5:
   \   000046   1F42....     MOV.W   &tx0_index, R15
   \   00004A   5F4F....     MOV.B   USB0_Char_Tx(R15), R15
   \   00004E   4F4F         MOV.B   R15, R15
   \   000050   824F0E05     MOV.W   R15, &0x50e
    125                      USB0_Char_Tx[tx0_index++] = '\0';
   \   000054   1F42....     MOV.W   &tx0_index, R15
   \   000058   0E4F         MOV.W   R15, R14
   \   00005A   1E53         ADD.W   #0x1, R14
   \   00005C   824E....     MOV.W   R14, &tx0_index
   \   000060   CF43....     MOV.B   #0x0, USB0_Char_Tx(R15)
    126          
    127                      if(USB0_Char_Tx[tx0_index] == false) {
   \   000064   1F42....     MOV.W   &tx0_index, R15
   \   000068   CF93....     CMP.B   #0x0, USB0_Char_Tx(R15)
   \   00006C   0220         JNE     ??eUSCI_A0_ISR_2
    128                          UCA0IE &= ~UCTXIE;
   \   00006E   A2C31A05     BIC.W   #0x2, &0x51a
    129                      }
    130          
    131                      break;
    132          
    133                  default:
    134                      break;
    135              }
    136          }
   \                     ??eUSCI_A0_ISR_2:
   \   000072   2D17         POPM.W  #0x3, R15
   \   000074   0013         RETI
   \   000076                REQUIRE _A_UCA0RXBUF_L
   \   000076                REQUIRE _A_UCA1TXBUF_L
   \   000076                REQUIRE _A_UCA0TXBUF_L
   \   000076                REQUIRE _A_UCA0IE_L
   \   000076                REQUIRE _A_UCA0IV_L
    137          //===========================================================================
    138          // Function name: eUSCI_A1_ISR
    139          //
    140          // Description: This is the isr for USC1, it puts all retreivals into the
    141          // ring buffer, and outputs what's in the tx buffer
    142          //
    143          // Passed : no variables passed
    144          // Locals: temp
    145          // Returned: no values returned
    146          // Globals: USB1_Char_Rx,Ring,usb1_rx_wr,recievedFromPC,tx1_index
    147          // USB1_Char_Tx
    148          //
    149          // Author: Ibrahim Moghul
    150          // Date: Apr 2022
    151          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    152          //===========================================================================
    153          #pragma vector=EUSCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    154          __interrupt void eUSCI_A1_ISR(void) {
   \                     eUSCI_A1_ISR:
   \   000000   2F15         PUSHM.W #0x3, R15
    155              unsigned int temp;
    156          
    157              switch(__even_in_range(UCA1IV, 0x08)) {
   \   000002   1F429E05     MOV.W   &0x59e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A1_ISR>_0`:
   \   000008   3F3C         JMP     ??eUSCI_A1_ISR_2
   \   00000A   033C         JMP     ??eUSCI_A1_ISR_6
   \   00000C   213C         JMP     ??eUSCI_A1_ISR_7
   \   00000E   3C3C         JMP     ??eUSCI_A1_ISR_2
   \   000010   3B3C         JMP     ??eUSCI_A1_ISR_2
    158                  case 0:
    159                      break;
    160          
    161                  case 2: // RXIFG
    162                      if (!receievedFromPC)// && recieved=='\n')
   \                     ??eUSCI_A1_ISR_6:
   \   000012   C293....     CMP.B   #0x0, &receievedFromPC
   \   000016   0220         JNE     ??eUSCI_A1_ISR_3
    163                          receievedFromPC = ON;
   \   000018   D243....     MOV.B   #0x1, &receievedFromPC
    164          
    165                      temp = usb1_rx_wr++;
   \                     ??eUSCI_A1_ISR_3:
   \   00001C   1F42....     MOV.W   &usb1_rx_wr, R15
   \   000020   0E4F         MOV.W   R15, R14
   \   000022   1E53         ADD.W   #0x1, R14
   \   000024   824E....     MOV.W   R14, &usb1_rx_wr
   \   000028   0D4F         MOV.W   R15, R13
    166                      USB1_Char_Rx_Ring[temp] = UCA1RXBUF;
   \   00002A   1E428C05     MOV.W   &0x58c, R14
   \   00002E   CD4E....     MOV.B   R14, USB1_Char_Rx_Ring(R13)
    167          
    168                      if(receievedFromPC)UCA0TXBUF = USB1_Char_Rx_Ring[temp];
   \   000032   C293....     CMP.B   #0x0, &receievedFromPC
   \   000036   0524         JEQ     ??eUSCI_A1_ISR_4
   \   000038   5F4D....     MOV.B   USB1_Char_Rx_Ring(R13), R15
   \   00003C   4F4F         MOV.B   R15, R15
   \   00003E   824F0E05     MOV.W   R15, &0x50e
    169          
    170                      if (usb1_rx_wr >= (SMALL_RING_SIZE)) {
   \                     ??eUSCI_A1_ISR_4:
   \   000042   B2901000.... CMP.W   #0x10, &usb1_rx_wr
   \   000048   1F28         JNC     ??eUSCI_A1_ISR_2
    171                          usb1_rx_wr = BEGINNING;
   \   00004A   8243....     MOV.W   #0x0, &usb1_rx_wr
    172                      }
    173          
    174                      break;
   \   00004E   1C3C         JMP     ??eUSCI_A1_ISR_2
    175          
    176                  case 4: // TXIFG
    177                      if(receievedFromPC == OFF) {
   \                     ??eUSCI_A1_ISR_7:
   \   000050   C293....     CMP.B   #0x0, &receievedFromPC
   \   000054   0320         JNE     ??eUSCI_A1_ISR_5
    178                          UCA1IE &= ~UCTXIE;
   \   000056   A2C39A05     BIC.W   #0x2, &0x59a
    179                          return;
   \   00005A   163C         JMP     ??eUSCI_A1_ISR_2
    180                      }
    181          
    182                      UCA1TXBUF = USB1_Char_Tx[tx1_index];
   \                     ??eUSCI_A1_ISR_5:
   \   00005C   1F42....     MOV.W   &tx1_index, R15
   \   000060   5F4F....     MOV.B   USB1_Char_Tx(R15), R15
   \   000064   4F4F         MOV.B   R15, R15
   \   000066   824F8E05     MOV.W   R15, &0x58e
    183                      USB1_Char_Tx[tx1_index++] = '\0';
   \   00006A   1F42....     MOV.W   &tx1_index, R15
   \   00006E   0E4F         MOV.W   R15, R14
   \   000070   1E53         ADD.W   #0x1, R14
   \   000072   824E....     MOV.W   R14, &tx1_index
   \   000076   CF43....     MOV.B   #0x0, USB1_Char_Tx(R15)
    184          
    185                      if(USB1_Char_Tx[tx1_index] == false) {
   \   00007A   1F42....     MOV.W   &tx1_index, R15
   \   00007E   CF93....     CMP.B   #0x0, USB1_Char_Tx(R15)
   \   000082   0220         JNE     ??eUSCI_A1_ISR_2
    186                          UCA1IE &= ~UCTXIE;
   \   000084   A2C39A05     BIC.W   #0x2, &0x59a
    187                      }
    188          
    189                      break;
    190          
    191                  default:
    192                      break;
    193              }
    194          }
   \                     ??eUSCI_A1_ISR_2:
   \   000088   2D17         POPM.W  #0x3, R15
   \   00008A   0013         RETI
   \   00008C                REQUIRE _A_UCA1RXBUF_L
   \   00008C                REQUIRE _A_UCA0TXBUF_L
   \   00008C                REQUIRE _A_UCA1IE_L
   \   00008C                REQUIRE _A_UCA1TXBUF_L
   \   00008C                REQUIRE _A_UCA1IV_L
    195          
    196          //===========================================================================
    197          // Function name: clearProcessBuff
    198          //
    199          // Description: generic function to clear a process buffer
    200          //
    201          // Passed : pb, pb_Index, pb_buffered
    202          // Locals: no variables declared
    203          // Returned: no values returned
    204          // Globals: no globals used
    205          //
    206          // Author: Ibrahim Moghul
    207          // Date: Apr 2022
    208          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    209          //===========================================================================
    210          

   \                                 In  segment CODE, align 2
    211          void clearProcessBuff(volatile char* pb, volatile unsigned int* pb_index, volatile unsigned int* pb_buffered) {
   \                     clearProcessBuff:
   \   000000   0A12         PUSH.W  R10
    212              for(int i = 0; i < LARGE_RING_SIZE; ++i)pb[i] = '\0';
   \   000002   0A43         MOV.W   #0x0, R10
   \                     ??clearProcessBuff_0:
   \   000004   3A906400     CMP.W   #0x64, R10
   \   000008   0634         JGE     ??clearProcessBuff_1
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0F5A         ADD.W   R10, R15
   \   00000E   CF430000     MOV.B   #0x0, 0(R15)
   \   000012   1A53         ADD.W   #0x1, R10
   \   000014   F73F         JMP     ??clearProcessBuff_0
    213          
    214              *pb_index = BEGINNING;
   \                     ??clearProcessBuff_1:
   \   000016   8D430000     MOV.W   #0x0, 0(R13)
    215              *pb_buffered = false;
   \   00001A   8E430000     MOV.W   #0x0, 0(R14)
    216          }
   \   00001E   3A41         POP.W   R10
   \   000020   1001         RETA
    217          
    218          //===========================================================================
    219          // Function name: clearProcessBuff_0
    220          //
    221          // Description: This function is used to clear the process buffer for USC0
    222          //
    223          // Passed : pb, pb_Index, pb_buffered
    224          // Locals: no variables declared
    225          // Returned: no values returned
    226          // Globals: no globals used
    227          //
    228          // Author: Ibrahim Moghul
    229          // Date: Apr 2022
    230          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    231          //===========================================================================
    232          

   \                                 In  segment CODE, align 2
    233          void clearProcessBuff_0(void) {
   \                     clearProcessBuff_0:
    234              clearProcessBuff(USB0_Char_Rx_Process, &pb0_index, &pb0_buffered);
   \   000000   3E40....     MOV.W   #pb0_buffered, R14
   \   000004   3D40....     MOV.W   #pb0_index, R13
   \   000008   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   00000C   ........     CALLA   #clearProcessBuff
    235          }
   \   000010   1001         RETA
    236          
    237          //===========================================================================
    238          // Function name: clearProcessBuff_1
    239          //
    240          // Description: This function is used to clear the process buffer for USC1
    241          //
    242          // Passed : pb, pb_Index, pb_buffered
    243          // Locals: no variables declared
    244          // Returned: no values returned
    245          // Globals: no globals used
    246          //
    247          // Author: Ibrahim Moghul
    248          // Date: Apr 2022
    249          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    250          //===========================================================================

   \                                 In  segment CODE, align 2
    251          void clearProcessBuff_1(void) {
   \                     clearProcessBuff_1:
    252              clearProcessBuff(USB1_Char_Rx_Process, &pb1_index, &pb1_buffered);
   \   000000   3E40....     MOV.W   #pb1_buffered, R14
   \   000004   3D40....     MOV.W   #pb1_index, R13
   \   000008   3C40....     MOV.W   #USB1_Char_Rx_Process, R12
   \   00000C   ........     CALLA   #clearProcessBuff
    253          }
   \   000010   1001         RETA
    254          
    255          /*void out_character(char character) {
    256              //------------------------------------------------------------------------------
    257              // The while loop will stall as long as the Flag is not set [port is busy]
    258              while (!(UCA0IFG & UCTXIFG)); // USCI_A0 TX buffer ready?
    259          
    260              UCA0TXBUF = character;
    261              //------------------------------------------------------------------------------
    262          }*/
    263          
    264          //===========================================================================
    265          // Function name: USCI_A0_transmit
    266          //
    267          // Description: This function is used to transmit from USC0
    268          //
    269          // Passed : no variables passed
    270          // Locals: no variables declared
    271          // Returned: no values returned
    272          // Globals: tx0_index
    273          //
    274          // Author: Ibrahim Moghul
    275          // Date: Apr 2022
    276          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    277          //===========================================================================
    278          

   \                                 In  segment CODE, align 2
    279          void USCI_A0_transmit(void) {
   \                     USCI_A0_transmit:
    280              tx0_index = BEGINNING;
   \   000000   8243....     MOV.W   #0x0, &tx0_index
    281              UCA0IE |= UCTXIE;
   \   000004   A2D31A05     BIS.W   #0x2, &0x51a
    282          }
   \   000008   1001         RETA
   \   00000A                REQUIRE _A_UCA0IE_L
    283          
    284          //===========================================================================
    285          // Function name: USCI_A1_transmit
    286          //
    287          // Description: This function is used to transmit from USC1
    288          //
    289          // Passed : no variables passed
    290          // Locals: no variables declared
    291          // Returned: no values returned
    292          // Globals: tx1_index
    293          //
    294          // Author: Ibrahim Moghul
    295          // Date: Apr 2022
    296          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    297          //===========================================================================
    298          

   \                                 In  segment CODE, align 2
    299          void USCI_A1_transmit(void) {
   \                     USCI_A1_transmit:
    300              tx1_index = BEGINNING;
   \   000000   8243....     MOV.W   #0x0, &tx1_index
    301              UCA1IE |= UCTXIE;
   \   000004   A2D39A05     BIS.W   #0x2, &0x59a
    302          }
   \   000008   1001         RETA
   \   00000A                REQUIRE _A_UCA1IE_L
    303          
    304          //===========================================================================
    305          // Function name: loadRingtoPB
    306          //
    307          // Description: generic function to load from ring to process buffer
    308          //
    309          // Passed : rx_wr,rx_rd,Rx_Process,Rx_Ring,pb_index,pb_buffered
    310          // Locals: no variables declared
    311          // Returned: no values returned
    312          // Globals: no globals used
    313          //
    314          // Author: Ibrahim Moghul
    315          // Date: Apr 2022
    316          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    317          //===========================================================================
    318          

   \                                 In  segment CODE, align 2
    319          void loadRingtoPB(volatile unsigned int* rx_wr, unsigned int* rx_rd, volatile char* Rx_Process, volatile char* Rx_Ring, volatile unsigned int* pb_index, volatile unsigned int* pb_buffered) {
   \                     loadRingtoPB:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   1B411000     MOV.W   0x10(SP), R11
   \   000006   18411200     MOV.W   0x12(SP), R8
    320              if(*pb_buffered) return;
   \   00000A   88930000     CMP.W   #0x0, 0(R8)
   \   00000E   2D20         JNE     ??loadRingtoPB_0
    321          
    322              if(*rx_wr != *rx_rd) {
   \   000010   AC9D0000     CMP.W   @R13, 0(R12)
   \   000014   1824         JEQ     ??loadRingtoPB_2
    323                  Rx_Process[*pb_index] = Rx_Ring[*rx_rd];
                         ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   000016   294B         MOV.W   @R11, R9
   \   000018   064F         MOV.W   R15, R6
   \   00001A   265D         ADD.W   @R13, R6
   \   00001C   0A4E         MOV.W   R14, R10
   \   00001E   0A59         ADD.W   R9, R10
   \   000020   EA460000     MOV.B   @R6, 0(R10)
    324          
    325                  if(++(*rx_rd) > SMALL_RING_SIZE - 1) *rx_rd = BEGINNING;
   \   000024   9D530000     ADD.W   #0x1, 0(R13)
   \   000028   BD9010000000 CMP.W   #0x10, 0(R13)
   \   00002E   0228         JNC     ??loadRingtoPB_3
   \   000030   8D430000     MOV.W   #0x0, 0(R13)
    326          
    327                  if(++(*pb_index) > LARGE_RING_SIZE - 1) *pb_index = BEGINNING;
   \                     ??loadRingtoPB_3:
   \   000034   2A4B         MOV.W   @R11, R10
   \   000036   1A53         ADD.W   #0x1, R10
   \   000038   8B4A0000     MOV.W   R10, 0(R11)
   \   00003C   3A906400     CMP.W   #0x64, R10
   \   000040   0228         JNC     ??loadRingtoPB_2
   \   000042   8B430000     MOV.W   #0x0, 0(R11)
    328              }
    329          
    330              if(/**pb_index >= 2 && */Rx_Process[(*pb_index) - 1] == '\n' && Rx_Process[(*pb_index) - 2] == '\r') {
   \                     ??loadRingtoPB_2:
   \   000046   2A4B         MOV.W   @R11, R10
   \   000048   094E         MOV.W   R14, R9
   \   00004A   095A         ADD.W   R10, R9
   \   00004C   F9900A00FFFF CMP.B   #0xa, 0xffff(R9)
   \   000052   0B20         JNE     ??loadRingtoPB_0
   \   000054   2A4B         MOV.W   @R11, R10
   \   000056   094E         MOV.W   R14, R9
   \   000058   095A         ADD.W   R10, R9
   \   00005A   F9900D00FEFF CMP.B   #0xd, 0xfffe(R9)
   \   000060   0420         JNE     ??loadRingtoPB_0
    331                  *pb_buffered = true;
   \   000062   98430000     MOV.W   #0x1, 0(R8)
    332                  *pb_index = BEGINNING;
   \   000066   8B430000     MOV.W   #0x0, 0(R11)
    333              }
    334          }
   \                     ??loadRingtoPB_0:
   \   00006A   5617         POPM.W  #0x6, R11
   \   00006C   1001         RETA
    335          
    336          //===========================================================================
    337          // Function name: loadRingtoPB_0
    338          //
    339          // Description: This function is used to load from ring to process for USC0
    340          //
    341          // Passed : no variables passed
    342          // Locals: no variables declared
    343          // Returned: no values returned
    344          // Globals: usb0_rx_rw,usb0_rx_rd,USB0_Char_Rx_Process, USB0_Rx_Ring, 
    345          // pb0_index, pb0_buffered
    346          //
    347          // Author: Ibrahim Moghul
    348          // Date: Apr 2022
    349          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    350          //===========================================================================
    351          

   \                                 In  segment CODE, align 2
    352          void loadRingtoPB_0(void) {
   \                     loadRingtoPB_0:
    353              loadRingtoPB(&usb0_rx_wr, &usb0_rx_rd, USB0_Char_Rx_Process, USB0_Char_Rx_Ring, &pb0_index, &pb0_buffered);
   \   000000   3012....     PUSH.W  #pb0_buffered
   \   000004   3012....     PUSH.W  #pb0_index
   \   000008   3F40....     MOV.W   #USB0_Char_Rx_Ring, R15
   \   00000C   3E40....     MOV.W   #USB0_Char_Rx_Process, R14
   \   000010   3D40....     MOV.W   #usb0_rx_rd, R13
   \   000014   3C40....     MOV.W   #usb0_rx_wr, R12
   \   000018   ........     CALLA   #loadRingtoPB
    354          }
   \   00001C   A1000400     ADDA    #0x4, SP
   \   000020   1001         RETA
    355          
    356          //===========================================================================
    357          // Function name: loadRingtoPB_1
    358          //
    359          // Description: This function is used to load from ring to process for USC1
    360          //
    361          // Passed : no variables passed
    362          // Locals: no variables declared
    363          // Returned: no values returned
    364          // Globals: usb1_rx_rw,usb1_rx_rd,USB1_Char_Rx_Process, USB1_Rx_Ring, 
    365          // pb1_index, pb1_buffered
    366          //
    367          // Author: Ibrahim Moghul
    368          // Date: Apr 2022
    369          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    370          //===========================================================================
    371          

   \                                 In  segment CODE, align 2
    372          void loadRingtoPB_1(void) {
   \                     loadRingtoPB_1:
    373              loadRingtoPB(&usb1_rx_wr, &usb1_rx_rd, USB1_Char_Rx_Process, USB1_Char_Rx_Ring, &pb1_index, &pb1_buffered);
   \   000000   3012....     PUSH.W  #pb1_buffered
   \   000004   3012....     PUSH.W  #pb1_index
   \   000008   3F40....     MOV.W   #USB1_Char_Rx_Ring, R15
   \   00000C   3E40....     MOV.W   #USB1_Char_Rx_Process, R14
   \   000010   3D40....     MOV.W   #usb1_rx_rd, R13
   \   000014   3C40....     MOV.W   #usb1_rx_wr, R12
   \   000018   ........     CALLA   #loadRingtoPB
    374          }
   \   00001C   A1000400     ADDA    #0x4, SP
   \   000020   1001         RETA
    375          
    376          //===========================================================================
    377          // Function name: SerialProcess
    378          //
    379          // Description: This function runs all the processes necessarity for 
    380          // serial communications
    381          //
    382          // Passed : no variables passed
    383          // Locals: no variables declared
    384          // Returned: no values returned
    385          // Globals: no globals used
    386          //
    387          // Author: Ibrahim Moghul
    388          // Date: Apr 2022
    389          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    390          //===========================================================================
    391          
    392          

   \                                 In  segment CODE, align 2
    393          void SerialProcess(void) {
   \                     SerialProcess:
    394              /*if(!pb0_buffered)*/loadRingtoPB_0();
   \   000000   ........     CALLA   #loadRingtoPB_0
    395          
    396              /*if(!pb1_buffered)*/loadRingtoPB_1();
   \   000004   ........     CALLA   #loadRingtoPB_1
    397          
    398          }
   \   000008   1001         RETA

   \                                 In  segment INTVEC, offset 0x40, root
   \                     `??eUSCI_A1_ISR::??INTVEC 64`:
   \   000040   ....         DC16    eUSCI_A1_ISR

   \                                 In  segment INTVEC, offset 0x42, root
   \                     `??eUSCI_A0_ISR::??INTVEC 66`:
   \   000042   ....         DC16    eUSCI_A0_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Init_Serial_UCA
      4   SerialProcess
        4   -> loadRingtoPB_0
        4   -> loadRingtoPB_1
      4   USCI_A0_transmit
      4   USCI_A1_transmit
      6   clearProcessBuff
      4   clearProcessBuff_0
        4   -> clearProcessBuff
      4   clearProcessBuff_1
        4   -> clearProcessBuff
     10   eUSCI_A0_ISR
     10   eUSCI_A1_ISR
     16   loadRingtoPB
      8   loadRingtoPB_0
        8   -> loadRingtoPB
      8   loadRingtoPB_1
        8   -> loadRingtoPB


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     110  Init_Serial_UCA
      10  SerialProcess
     100  USB0_Char_Rx_Process
      16  USB0_Char_Rx_Ring
     100  USB0_Char_Tx
     100  USB1_Char_Rx_Process
      16  USB1_Char_Rx_Ring
     100  USB1_Char_Tx
      10  USCI_A0_transmit
      10  USCI_A1_transmit
       2  _A_UCA0BRW_L
       2  _A_UCA0CTLW0_L
       2  _A_UCA0IE_L
       2  _A_UCA0IV_L
       2  _A_UCA0MCTLW_L
       2  _A_UCA0RXBUF_L
       2  _A_UCA0TXBUF_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1IE_L
       2  _A_UCA1IV_L
       2  _A_UCA1MCTLW_L
       2  _A_UCA1RXBUF_L
       2  _A_UCA1TXBUF_L
      34  clearProcessBuff
      18  clearProcessBuff_0
      18  clearProcessBuff_1
     118  eUSCI_A0_ISR
       2  eUSCI_A0_ISR::??INTVEC 66
     140  eUSCI_A1_ISR
       2  eUSCI_A1_ISR::??INTVEC 64
     110  loadRingtoPB
      34  loadRingtoPB_0
      34  loadRingtoPB_1
       2  pb0_buffered
       2  pb0_index
       2  pb1_buffered
       2  pb1_index
       1  receievedFromPC
       2  serialState
       2  tx0_index
       2  tx1_index
       2  usb0_rx_rd
       2  usb0_rx_wr
       2  usb1_rx_rd
       2  usb1_rx_wr

 
 388 bytes in segment CODE
  28 bytes in segment DATA16_AN
 455 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 258 bytes in segment ISR_CODE
 
 646 bytes of CODE  memory
   0 bytes of CONST memory (+  4 bytes shared)
 455 bytes of DATA  memory (+ 28 bytes shared)

Errors: none
Warnings: 1
