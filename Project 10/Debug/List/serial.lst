###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          25/Apr/2022  16:26:31
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\test\Project 10\serial.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWEB59.tmp
#        ("C:\Users\saad\Documents\test\Project 10\serial.c" -lC
#        "C:\Users\saad\Documents\test\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\test\Project 10\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\test\Project 10\Debug\List\serial.lst
#    Object file   =  
#        C:\Users\saad\Documents\test\Project 10\Debug\Obj\serial.r43
#
###############################################################################

C:\Users\saad\Documents\test\Project 10\serial.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains the Serial Routine - Serial Processes
      4          //
      5          //
      6          //  Ibrahim Moghul
      7          //  Mar 2022
      8          //  Built with IAR Embedded Workbench Version: (7.21.1)
      9          //------------------------------------------------------------------------------
     10          #include "serial.h"
     11          #include "macros.h"
     12          #include <string.h>
     13          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x500
   \   union <unnamed> _A_UCA0CTLW0_L
   \                     _A_UCA0CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x506
   \   union <unnamed> _A_UCA0BRW_L
   \                     _A_UCA0BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x508
   \   union <unnamed> _A_UCA0MCTLW_L
   \                     _A_UCA0MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x580
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x586
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x588
   \   union <unnamed> _A_UCA1MCTLW_L
   \                     _A_UCA1MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59a
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2
     14          
     15          // global variables

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          volatile unsigned int usb0_rx_wr, usb1_rx_wr;
   \                     usb0_rx_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          unsigned int usb0_rx_rd, usb1_rx_rd;
   \                     usb0_rx_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          volatile char USB0_Char_Rx_Ring[SMALL_RING_SIZE], USB0_Char_Rx_Process[LARGE_RING_SIZE];
   \                     USB0_Char_Rx_Ring:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB0_Char_Rx_Process:
   \   000000                DS8 100

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          volatile char USB1_Char_Rx_Ring[SMALL_RING_SIZE], USB1_Char_Rx_Process[LARGE_RING_SIZE];
   \                     USB1_Char_Rx_Ring:
   \   000000                DS8 16

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Rx_Process:
   \   000000                DS8 100

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     20          volatile char USB0_Char_Tx[LARGE_RING_SIZE], USB1_Char_Tx[LARGE_RING_SIZE];
   \                     USB0_Char_Tx:
   \   000000                DS8 100

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Tx:
   \   000000                DS8 100

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          unsigned volatile int pb0_index, pb1_index;
   \                     pb0_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     pb1_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          unsigned volatile int tx0_index, tx1_index;
   \                     tx0_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     tx1_index:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          unsigned volatile int pb0_buffered, pb1_buffered;
   \                     pb0_buffered:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     pb1_buffered:
   \   000000                DS8 2
     24          extern volatile unsigned char display_changed;
     25          extern char display_line[4][11];

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          unsigned volatile int serialState;
   \                     serialState:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          volatile char receievedFromPC;
   \                     receievedFromPC:
   \   000000                DS8 1
     28          
     29          //===========================================================================
     30          // Function name: Init_Serial_UCA
     31          //
     32          // Description: This function initializes the serial ports of the FRAM board
     33          //
     34          // Passed : no variables passed
     35          // Locals: no variables declared
     36          // Returned: no values returned
     37          // Globals: usb0_rx_wr, usb0_rx_rd, usb1_rx_wr, usb1_rx_rd, USB0_Char_Rx_Ring
     38          // , USB1_Char_Rx_ring, USB0_Char_Tx, USB1_Char_Tx
     39          //
     40          // Author: Ibrahim Moghul
     41          // Date: Apr 2022
     42          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     43          //===========================================================================

   \                                 In  segment CODE, align 2
     44          void Init_Serial_UCA(void) {
   \                     Init_Serial_UCA:
     45              int i;
     46          
     47              for(i = 0; i < SMALL_RING_SIZE; i++) {
   \   000000   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_0:
   \   000002   3F901000     CMP.W   #0x10, R15
   \   000006   0634         JGE     ??Init_Serial_UCA_2
     48                  USB0_Char_Rx_Ring[i] = 0x00;
   \   000008   CF43....     MOV.B   #0x0, USB0_Char_Rx_Ring(R15)
     49                  USB1_Char_Rx_Ring[i] = 0x00;
   \   00000C   CF43....     MOV.B   #0x0, USB1_Char_Rx_Ring(R15)
     50              }
   \   000010   1F53         ADD.W   #0x1, R15
   \   000012   F73F         JMP     ??Init_Serial_UCA_0
     51          
     52              usb0_rx_wr = BEGINNING;
   \                     ??Init_Serial_UCA_2:
   \   000014   8243....     MOV.W   #0x0, &usb0_rx_wr
     53              usb0_rx_rd = BEGINNING;
   \   000018   8243....     MOV.W   #0x0, &usb0_rx_rd
     54              usb1_rx_wr = BEGINNING;
   \   00001C   8243....     MOV.W   #0x0, &usb1_rx_wr
     55              usb1_rx_rd = BEGINNING;
   \   000020   8243....     MOV.W   #0x0, &usb1_rx_rd
     56          
     57              for(i = 0; i < LARGE_RING_SIZE; i++) {
   \   000024   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_1:
   \   000026   3F906400     CMP.W   #0x64, R15
   \   00002A   0634         JGE     ??Init_Serial_UCA_3
     58                  USB0_Char_Tx[i] = 0x00;
   \   00002C   CF43....     MOV.B   #0x0, USB0_Char_Tx(R15)
     59                  USB1_Char_Tx[i] = 0x00;
   \   000030   CF43....     MOV.B   #0x0, USB1_Char_Tx(R15)
     60              }
   \   000034   1F53         ADD.W   #0x1, R15
   \   000036   F73F         JMP     ??Init_Serial_UCA_1
     61          
     62              // Configure UART 0
     63              UCA0CTLW0 = 0;
   \                     ??Init_Serial_UCA_3:
   \   000038   82430005     MOV.W   #0x0, &0x500
     64              UCA0CTLW0 |= UCSWRST;
   \   00003C   92D30005     BIS.W   #0x1, &0x500
     65              UCA0CTLW0 |= UCSSEL__SMCLK;
   \   000040   B2D080000005 BIS.W   #0x80, &0x500
     66              // UCA0BRW = 4;
     67              // UCA0MCTLW = 0x5551;
     68              SET_UCA_115200;
   \   000046   A2420605     MOV.W   #0x4, &0x506
   \   00004A   B24051550805 MOV.W   #0x5551, &0x508
   \   000050   A2428605     MOV.W   #0x4, &0x586
   \   000054   B24051558805 MOV.W   #0x5551, &0x588
     69              UCA0CTLW0 &= ~UCSWRST;
   \   00005A   92C30005     BIC.W   #0x1, &0x500
     70              UCA0IE |= UCRXIE;
   \   00005E   92D31A05     BIS.W   #0x1, &0x51a
     71              
     72              // Configure UART 1
     73              /*UCA1CTLW0 = 0;
     74              UCA1CTLW0 |= UCSWRST;
     75              UCA1CTLW0 |= UCSSEL__SMCLK;
     76              // UCA1BRW = 4;
     77              // UCA1MCTLW = 0x5551;
     78              UCA1CTLW0 &= ~UCSWRST;
     79              UCA1IE |= UCRXIE;*/
     80              UCA1CTLW0 = UCA0CTLW0;
   \   000062   924200058005 MOV.W   &0x500, &0x580
     81              UCA1IE |= UCRXIE;
   \   000068   92D39A05     BIS.W   #0x1, &0x59a
     82          }
   \   00006C   1001         RETA
   \   00006E                REQUIRE _A_UCA0CTLW0_L
   \   00006E                REQUIRE _A_UCA0BRW_L
   \   00006E                REQUIRE _A_UCA0MCTLW_L
   \   00006E                REQUIRE _A_UCA1BRW_L
   \   00006E                REQUIRE _A_UCA1MCTLW_L
   \   00006E                REQUIRE _A_UCA0IE_L
   \   00006E                REQUIRE _A_UCA1CTLW0_L
   \   00006E                REQUIRE _A_UCA1IE_L
     83          
     84          
     85          //===========================================================================
     86          // Function name: clearProcessBuff
     87          //
     88          // Description: generic function to clear a process buffer
     89          //
     90          // Passed : pb, pb_Index, pb_buffered
     91          // Locals: no variables declared
     92          // Returned: no values returned
     93          // Globals: no globals used
     94          //
     95          // Author: Ibrahim Moghul
     96          // Date: Apr 2022
     97          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
     98          //===========================================================================
     99          

   \                                 In  segment CODE, align 2
    100          void clearProcessBuff(volatile char* pb, volatile unsigned int* pb_index, volatile unsigned int* pb_buffered) {
   \                     clearProcessBuff:
   \   000000   0A12         PUSH.W  R10
    101              for(int i = 0; i < LARGE_RING_SIZE; ++i)pb[i] = '\0';
   \   000002   0A43         MOV.W   #0x0, R10
   \                     ??clearProcessBuff_0:
   \   000004   3A906400     CMP.W   #0x64, R10
   \   000008   0634         JGE     ??clearProcessBuff_1
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   0F5A         ADD.W   R10, R15
   \   00000E   CF430000     MOV.B   #0x0, 0(R15)
   \   000012   1A53         ADD.W   #0x1, R10
   \   000014   F73F         JMP     ??clearProcessBuff_0
    102          
    103              *pb_index = BEGINNING;
   \                     ??clearProcessBuff_1:
   \   000016   8D430000     MOV.W   #0x0, 0(R13)
    104              *pb_buffered = false;
   \   00001A   8E430000     MOV.W   #0x0, 0(R14)
    105          }
   \   00001E   3A41         POP.W   R10
   \   000020   1001         RETA
    106          
    107          //===========================================================================
    108          // Function name: clearProcessBuff_0
    109          //
    110          // Description: This function is used to clear the process buffer for USC0
    111          //
    112          // Passed : pb, pb_Index, pb_buffered
    113          // Locals: no variables declared
    114          // Returned: no values returned
    115          // Globals: no globals used
    116          //
    117          // Author: Ibrahim Moghul
    118          // Date: Apr 2022
    119          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    120          //===========================================================================
    121          

   \                                 In  segment CODE, align 2
    122          void clearProcessBuff_0(void) {
   \                     clearProcessBuff_0:
    123              clearProcessBuff(USB0_Char_Rx_Process, &pb0_index, &pb0_buffered);
   \   000000   3E40....     MOV.W   #pb0_buffered, R14
   \   000004   3D40....     MOV.W   #pb0_index, R13
   \   000008   3C40....     MOV.W   #USB0_Char_Rx_Process, R12
   \   00000C   ........     CALLA   #clearProcessBuff
    124          }
   \   000010   1001         RETA
    125          
    126          //===========================================================================
    127          // Function name: clearProcessBuff_1
    128          //
    129          // Description: This function is used to clear the process buffer for USC1
    130          //
    131          // Passed : pb, pb_Index, pb_buffered
    132          // Locals: no variables declared
    133          // Returned: no values returned
    134          // Globals: no globals used
    135          //
    136          // Author: Ibrahim Moghul
    137          // Date: Apr 2022
    138          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    139          //===========================================================================

   \                                 In  segment CODE, align 2
    140          void clearProcessBuff_1(void) {
   \                     clearProcessBuff_1:
    141              clearProcessBuff(USB1_Char_Rx_Process, &pb1_index, &pb1_buffered);
   \   000000   3E40....     MOV.W   #pb1_buffered, R14
   \   000004   3D40....     MOV.W   #pb1_index, R13
   \   000008   3C40....     MOV.W   #USB1_Char_Rx_Process, R12
   \   00000C   ........     CALLA   #clearProcessBuff
    142          }
   \   000010   1001         RETA
    143          
    144          /*void out_character(char character) {
    145              //------------------------------------------------------------------------------
    146              // The while loop will stall as long as the Flag is not set [port is busy]
    147              while (!(UCA0IFG & UCTXIFG)); // USCI_A0 TX buffer ready?
    148          
    149              UCA0TXBUF = character;
    150              //------------------------------------------------------------------------------
    151          }*/
    152          
    153          //===========================================================================
    154          // Function name: USCI_A0_transmit
    155          //
    156          // Description: This function is used to transmit from USC0
    157          //
    158          // Passed : no variables passed
    159          // Locals: no variables declared
    160          // Returned: no values returned
    161          // Globals: tx0_index
    162          //
    163          // Author: Ibrahim Moghul
    164          // Date: Apr 2022
    165          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    166          //===========================================================================
    167          

   \                                 In  segment CODE, align 2
    168          void USCI_A0_transmit(void) {
   \                     USCI_A0_transmit:
    169              tx0_index = BEGINNING;
   \   000000   8243....     MOV.W   #0x0, &tx0_index
    170              UCA0IE |= UCTXIE;
   \   000004   A2D31A05     BIS.W   #0x2, &0x51a
    171          }
   \   000008   1001         RETA
   \   00000A                REQUIRE _A_UCA0IE_L
    172          
    173          //===========================================================================
    174          // Function name: USCI_A1_transmit
    175          //
    176          // Description: This function is used to transmit from USC1
    177          //
    178          // Passed : no variables passed
    179          // Locals: no variables declared
    180          // Returned: no values returned
    181          // Globals: tx1_index
    182          //
    183          // Author: Ibrahim Moghul
    184          // Date: Apr 2022
    185          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    186          //===========================================================================
    187          

   \                                 In  segment CODE, align 2
    188          void USCI_A1_transmit(void) {
   \                     USCI_A1_transmit:
    189              tx1_index = BEGINNING;
   \   000000   8243....     MOV.W   #0x0, &tx1_index
    190              UCA1IE |= UCTXIE;
   \   000004   A2D39A05     BIS.W   #0x2, &0x59a
    191          }
   \   000008   1001         RETA
   \   00000A                REQUIRE _A_UCA1IE_L
    192          
    193          //===========================================================================
    194          // Function name: loadRingtoPB
    195          //
    196          // Description: generic function to load from ring to process buffer
    197          //
    198          // Passed : rx_wr,rx_rd,Rx_Process,Rx_Ring,pb_index,pb_buffered
    199          // Locals: no variables declared
    200          // Returned: no values returned
    201          // Globals: no globals used
    202          //
    203          // Author: Ibrahim Moghul
    204          // Date: Apr 2022
    205          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    206          //===========================================================================
    207          

   \                                 In  segment CODE, align 2
    208          void loadRingtoPB(volatile unsigned int* rx_wr, unsigned int* rx_rd, volatile char* Rx_Process, volatile char* Rx_Ring, volatile unsigned int* pb_index, volatile unsigned int* pb_buffered) {
   \                     loadRingtoPB:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   1B411000     MOV.W   0x10(SP), R11
   \   000006   18411200     MOV.W   0x12(SP), R8
    209              if(*pb_buffered) return;
   \   00000A   88930000     CMP.W   #0x0, 0(R8)
   \   00000E   2D20         JNE     ??loadRingtoPB_0
    210          
    211              if(*rx_wr != *rx_rd) {
   \   000010   AC9D0000     CMP.W   @R13, 0(R12)
   \   000014   1824         JEQ     ??loadRingtoPB_2
    212                  Rx_Process[*pb_index] = Rx_Ring[*rx_rd];
                         ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \   000016   294B         MOV.W   @R11, R9
   \   000018   064F         MOV.W   R15, R6
   \   00001A   265D         ADD.W   @R13, R6
   \   00001C   0A4E         MOV.W   R14, R10
   \   00001E   0A59         ADD.W   R9, R10
   \   000020   EA460000     MOV.B   @R6, 0(R10)
    213          
    214                  if(++(*rx_rd) > SMALL_RING_SIZE - 1) *rx_rd = BEGINNING;
   \   000024   9D530000     ADD.W   #0x1, 0(R13)
   \   000028   BD9010000000 CMP.W   #0x10, 0(R13)
   \   00002E   0228         JNC     ??loadRingtoPB_3
   \   000030   8D430000     MOV.W   #0x0, 0(R13)
    215          
    216                  if(++(*pb_index) > LARGE_RING_SIZE - 1) *pb_index = BEGINNING;
   \                     ??loadRingtoPB_3:
   \   000034   2A4B         MOV.W   @R11, R10
   \   000036   1A53         ADD.W   #0x1, R10
   \   000038   8B4A0000     MOV.W   R10, 0(R11)
   \   00003C   3A906400     CMP.W   #0x64, R10
   \   000040   0228         JNC     ??loadRingtoPB_2
   \   000042   8B430000     MOV.W   #0x0, 0(R11)
    217              }
    218          
    219              if(/**pb_index >= 2 && */Rx_Process[(*pb_index) - 1] == '\n' && Rx_Process[(*pb_index) - 2] == '\r') {
   \                     ??loadRingtoPB_2:
   \   000046   2A4B         MOV.W   @R11, R10
   \   000048   094E         MOV.W   R14, R9
   \   00004A   095A         ADD.W   R10, R9
   \   00004C   F9900A00FFFF CMP.B   #0xa, 0xffff(R9)
   \   000052   0B20         JNE     ??loadRingtoPB_0
   \   000054   2A4B         MOV.W   @R11, R10
   \   000056   094E         MOV.W   R14, R9
   \   000058   095A         ADD.W   R10, R9
   \   00005A   F9900D00FEFF CMP.B   #0xd, 0xfffe(R9)
   \   000060   0420         JNE     ??loadRingtoPB_0
    220                  *pb_buffered = true;
   \   000062   98430000     MOV.W   #0x1, 0(R8)
    221                  *pb_index = BEGINNING;
   \   000066   8B430000     MOV.W   #0x0, 0(R11)
    222              }
    223          }
   \                     ??loadRingtoPB_0:
   \   00006A   5617         POPM.W  #0x6, R11
   \   00006C   1001         RETA
    224          
    225          //===========================================================================
    226          // Function name: loadRingtoPB_0
    227          //
    228          // Description: This function is used to load from ring to process for USC0
    229          //
    230          // Passed : no variables passed
    231          // Locals: no variables declared
    232          // Returned: no values returned
    233          // Globals: usb0_rx_rw,usb0_rx_rd,USB0_Char_Rx_Process, USB0_Rx_Ring, 
    234          // pb0_index, pb0_buffered
    235          //
    236          // Author: Ibrahim Moghul
    237          // Date: Apr 2022
    238          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    239          //===========================================================================
    240          

   \                                 In  segment CODE, align 2
    241          void loadRingtoPB_0(void) {
   \                     loadRingtoPB_0:
    242              loadRingtoPB(&usb0_rx_wr, &usb0_rx_rd, USB0_Char_Rx_Process, USB0_Char_Rx_Ring, &pb0_index, &pb0_buffered);
   \   000000   3012....     PUSH.W  #pb0_buffered
   \   000004   3012....     PUSH.W  #pb0_index
   \   000008   3F40....     MOV.W   #USB0_Char_Rx_Ring, R15
   \   00000C   3E40....     MOV.W   #USB0_Char_Rx_Process, R14
   \   000010   3D40....     MOV.W   #usb0_rx_rd, R13
   \   000014   3C40....     MOV.W   #usb0_rx_wr, R12
   \   000018   ........     CALLA   #loadRingtoPB
    243          }
   \   00001C   A1000400     ADDA    #0x4, SP
   \   000020   1001         RETA
    244          
    245          //===========================================================================
    246          // Function name: loadRingtoPB_1
    247          //
    248          // Description: This function is used to load from ring to process for USC1
    249          //
    250          // Passed : no variables passed
    251          // Locals: no variables declared
    252          // Returned: no values returned
    253          // Globals: usb1_rx_rw,usb1_rx_rd,USB1_Char_Rx_Process, USB1_Rx_Ring, 
    254          // pb1_index, pb1_buffered
    255          //
    256          // Author: Ibrahim Moghul
    257          // Date: Apr 2022
    258          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    259          //===========================================================================
    260          

   \                                 In  segment CODE, align 2
    261          void loadRingtoPB_1(void) {
   \                     loadRingtoPB_1:
    262              loadRingtoPB(&usb1_rx_wr, &usb1_rx_rd, USB1_Char_Rx_Process, USB1_Char_Rx_Ring, &pb1_index, &pb1_buffered);
   \   000000   3012....     PUSH.W  #pb1_buffered
   \   000004   3012....     PUSH.W  #pb1_index
   \   000008   3F40....     MOV.W   #USB1_Char_Rx_Ring, R15
   \   00000C   3E40....     MOV.W   #USB1_Char_Rx_Process, R14
   \   000010   3D40....     MOV.W   #usb1_rx_rd, R13
   \   000014   3C40....     MOV.W   #usb1_rx_wr, R12
   \   000018   ........     CALLA   #loadRingtoPB
    263          }
   \   00001C   A1000400     ADDA    #0x4, SP
   \   000020   1001         RETA
    264          
    265          //===========================================================================
    266          // Function name: SerialProcess
    267          //
    268          // Description: This function runs all the processes necessarity for 
    269          // serial communications
    270          //
    271          // Passed : no variables passed
    272          // Locals: no variables declared
    273          // Returned: no values returned
    274          // Globals: no globals used
    275          //
    276          // Author: Ibrahim Moghul
    277          // Date: Apr 2022
    278          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    279          //===========================================================================
    280          
    281          

   \                                 In  segment CODE, align 2
    282          void SerialProcess(void) {
   \                     SerialProcess:
    283              /*if(!pb0_buffered)*/loadRingtoPB_0();
   \   000000   ........     CALLA   #loadRingtoPB_0
    284          
    285              /*if(!pb1_buffered)*/loadRingtoPB_1();
   \   000004   ........     CALLA   #loadRingtoPB_1
    286          
    287          }
   \   000008   1001         RETA

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Init_Serial_UCA
      4   SerialProcess
        4   -> loadRingtoPB_0
        4   -> loadRingtoPB_1
      4   USCI_A0_transmit
      4   USCI_A1_transmit
      6   clearProcessBuff
      4   clearProcessBuff_0
        4   -> clearProcessBuff
      4   clearProcessBuff_1
        4   -> clearProcessBuff
     16   loadRingtoPB
      8   loadRingtoPB_0
        8   -> loadRingtoPB
      8   loadRingtoPB_1
        8   -> loadRingtoPB


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     110  Init_Serial_UCA
      10  SerialProcess
     100  USB0_Char_Rx_Process
      16  USB0_Char_Rx_Ring
     100  USB0_Char_Tx
     100  USB1_Char_Rx_Process
      16  USB1_Char_Rx_Ring
     100  USB1_Char_Tx
      10  USCI_A0_transmit
      10  USCI_A1_transmit
       2  _A_UCA0BRW_L
       2  _A_UCA0CTLW0_L
       2  _A_UCA0IE_L
       2  _A_UCA0MCTLW_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1IE_L
       2  _A_UCA1MCTLW_L
      34  clearProcessBuff
      18  clearProcessBuff_0
      18  clearProcessBuff_1
     110  loadRingtoPB
      34  loadRingtoPB_0
      34  loadRingtoPB_1
       2  pb0_buffered
       2  pb0_index
       2  pb1_buffered
       2  pb1_index
       1  receievedFromPC
       2  serialState
       2  tx0_index
       2  tx1_index
       2  usb0_rx_rd
       2  usb0_rx_wr
       2  usb1_rx_rd
       2  usb1_rx_wr

 
 388 bytes in segment CODE
  16 bytes in segment DATA16_AN
 455 bytes in segment DATA16_Z
 
 388 bytes of CODE memory
 455 bytes of DATA memory (+ 16 bytes shared)

Errors: none
Warnings: 1
