###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          12/Apr/2022  15:03:58
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 10\utils.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWAD88.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 10\utils.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj" --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -Ohz --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\List\utils.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj\utils.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 10\utils.c
      1          #include <string.h>
      2          #include "utils.h"
      3          #include "macros.h"
      4          extern volatile unsigned char display_changed;
      5          extern char display_line[4][11];
      6          

   \                                 In  segment CODE, align 2
      7          void centerStringToDisplay(unsigned int line, char * s) {
   \                     centerStringToDisplay:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
      8              int len = strlen(s);
   \   000006   0C4D         MOV.W   R13, R12
   \   000008   ........     CALLA   #strlen
   \   00000C   084C         MOV.W   R12, R8
      9              int pos = ((10 - len) >> 1);
   \   00000E   39400A00     MOV.W   #0xa, R9
   \   000012   098C         SUB.W   R12, R9
   \   000014   5901         RRAM.W  #0x1, R9
     10              strcpy(display_line[line] + pos, s);
   \   000016   064A         MOV.W   R10, R6
   \   000018                RPT     #0xa
   \   000018   4918065A     ADDX.W  R10, R6
   \   00001C   0D4B         MOV.W   R11, R13
   \   00001E   0C46         MOV.W   R6, R12
   \   000020   0C59         ADD.W   R9, R12
   \   000022   3C50....     ADD.W   #display_line, R12
   \   000026   ........     CALLA   #strcpy
     11              display_line[line][pos + len] = ' ';
   \   00002A   0958         ADD.W   R8, R9
   \   00002C   0956         ADD.W   R6, R9
   \   00002E   F9402000.... MOV.B   #0x20, display_line(R9)
     12              display_line[line][10] = 0;
   \   000034   C643....     MOV.B   #0x0, display_line + 10(R6)
     13          }
   \   000038   5617         POPM.W  #0x6, R11
   \   00003A   1001         RETA
     14          

   \                                 In  segment CODE, align 2
     15          char* subStringPos(const char* str,char * subString) {
   \                     subStringPos:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
     16          
     17              int i = 0;
   \   000006   0843         MOV.W   #0x0, R8
     18              int d = 0;
     19          
     20              int lenSub = strlen(subString);
   \   000008   0C4D         MOV.W   R13, R12
   \   00000A   ........     CALLA   #strlen
   \   00000E   094C         MOV.W   R12, R9
     21              int len = strlen(str) - lenSub;
   \   000010   0C4A         MOV.W   R10, R12
   \   000012   ........     CALLA   #strlen
   \   000016   0C89         SUB.W   R9, R12
     22              
     23              for (i = 0; i < len;i++) {
   \   000018   093C         JMP     ??subStringPos_1
     24                  int exists = 1;
     25          
     26                  for (d = 0; d < lenSub; d++) {
     27                      if (str[i + d] != subString[d]) {
   \                     ??subStringPos_0:
   \   00001A   0D4A         MOV.W   R10, R13
   \   00001C   0D58         ADD.W   R8, R13
   \   00001E   0D5E         ADD.W   R14, R13
   \   000020   0F4B         MOV.W   R11, R15
   \   000022   0F5E         ADD.W   R14, R15
   \   000024   ED9F0000     CMP.B   @R15, 0(R13)
   \   000028   0524         JEQ     ??subStringPos_4
     28                          exists = 0;
     29                          break;
     30                      }
     31                  }
   \   00002A   1853         ADD.W   #0x1, R8
   \                     ??subStringPos_1:
   \   00002C   089C         CMP.W   R12, R8
   \   00002E   0834         JGE     ??subStringPos_5
   \   000030   0E43         MOV.W   #0x0, R14
   \   000032   013C         JMP     ??subStringPos_2
   \                     ??subStringPos_4:
   \   000034   1E53         ADD.W   #0x1, R14
   \                     ??subStringPos_2:
   \   000036   0E99         CMP.W   R9, R14
   \   000038   F03B         JL      ??subStringPos_0
     32          
     33                  if (exists) return (char*)(str + i);
   \   00003A   0A58         ADD.W   R8, R10
   \   00003C   0C4A         MOV.W   R10, R12
   \   00003E   013C         JMP     ??subStringPos_3
     34              }
     35              return 0;
   \                     ??subStringPos_5:
   \   000040   0C43         MOV.W   #0x0, R12
   \                     ??subStringPos_3:
   \   000042   3817         POPM.W  #0x4, R11
   \   000044   1001         RETA
     36          }
     37          

   \                                 In  segment CODE, align 2
     38          int stoi(char* str,int len) {
   \                     stoi:
   \   000000   1B15         PUSHM.W #0x2, R11
     39              int num = 0;
   \   000002   0E43         MOV.W   #0x0, R14
     40              for(int i = 0; i < len && str[i] >= '0' && str[i] <= '9'; ++i)
   \   000004   0A43         MOV.W   #0x0, R10
   \   000006   063C         JMP     ??stoi_1
     41                  num = num * 10 + (int)(str[i] - '0');
   \                     ??stoi_0:
   \   000008                RPT     #0xa
   \   000008   49180F5E     ADDX.W  R14, R15
   \   00000C   0E4F         MOV.W   R15, R14
   \   00000E   3E50D0FF     ADD.W   #0xffd0, R14
   \   000012   1A53         ADD.W   #0x1, R10
   \                     ??stoi_1:
   \   000014   0A9D         CMP.W   R13, R10
   \   000016   0934         JGE     ??stoi_2
   \   000018   0F4C         MOV.W   R12, R15
   \   00001A   0F5A         ADD.W   R10, R15
   \   00001C   6F4F         MOV.B   @R15, R15
   \   00001E   4B4F         MOV.B   R15, R11
   \   000020   7B50D000     ADD.B   #0xd0, R11
   \   000024   7B900A00     CMP.B   #0xa, R11
   \   000028   EF2B         JNC     ??stoi_0
     42              return num;
   \                     ??stoi_2:
   \   00002A   0C4E         MOV.W   R14, R12
   \   00002C   1A17         POPM.W  #0x2, R11
   \   00002E   1001         RETA
     43          }
     44          

   \                                 In  segment CODE, align 2
     45          char* charInString(const char* str, char c) {
   \                     charInString:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   4A4D         MOV.B   R13, R10
     46              for(int i = 0; i < strlen(str)+1; i++)
   \   000006   0843         MOV.W   #0x0, R8
   \   000008   013C         JMP     ??charInString_1
   \                     ??charInString_0:
   \   00000A   1853         ADD.W   #0x1, R8
   \                     ??charInString_1:
   \   00000C   0C4B         MOV.W   R11, R12
   \   00000E   ........     CALLA   #strlen
   \   000012   1C53         ADD.W   #0x1, R12
   \   000014   089C         CMP.W   R12, R8
   \   000016   052C         JC      ??charInString_3
     47                  if(str[i] == c) return (char*)(str + i);
   \   000018   0C4B         MOV.W   R11, R12
   \   00001A   0C58         ADD.W   R8, R12
   \   00001C   6A9C         CMP.B   @R12, R10
   \   00001E   F523         JNE     ??charInString_0
   \   000020   013C         JMP     ??charInString_2
     48          
     49              return 0;
   \                     ??charInString_3:
   \   000022   0C43         MOV.W   #0x0, R12
   \                     ??charInString_2:
   \   000024   3817         POPM.W  #0x4, R11
   \   000026   1001         RETA
     50          }
     51          

   \                                 In  segment CODE, align 2
     52          unsigned int absVal(int n) {
   \                     absVal:
   \   000000   B1000400     SUBA    #0x4, SP
     53              const int ret[2] = {n, -n};
   \   000004   814C0000     MOV.W   R12, 0(SP)
   \   000008   0F4C         MOV.W   R12, R15
   \   00000A   3FE3         XOR.W   #0xffff, R15
   \   00000C   1F53         ADD.W   #0x1, R15
   \   00000E   814F0200     MOV.W   R15, 0x2(SP)
     54              return (unsigned int)(ret [n < 0]);
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   0238         JL      ??absVal_1
   \   000016   0F43         MOV.W   #0x0, R15
   \   000018   013C         JMP     ??absVal_0
   \                     ??absVal_1:
   \   00001A   2F43         MOV.W   #0x2, R15
   \                     ??absVal_0:
   \   00001C   0F51         ADD.W   SP, R15
   \   00001E   2C4F         MOV.W   @R15, R12
   \   000020   A1000400     ADDA    #0x4, SP
   \   000024   1001         RETA
     55          }
     56          

   \                                 In  segment CODE, align 2
     57          void HEXtoBCD(int hex_value, int line, int start) {
   \                     HEXtoBCD:
   \   000000   0A12         PUSH.W  R10
     58              int value = 0;
   \   000002   0F43         MOV.W   #0x0, R15
   \   000004   033C         JMP     ??HEXtoBCD_3
     59          
     60              while(hex_value > 999) {
     61                  hex_value -= 1000;
   \                     ??HEXtoBCD_0:
   \   000006   3C5018FC     ADD.W   #0xfc18, R12
     62                  value += 1;
   \   00000A   1F53         ADD.W   #0x1, R15
     63              }
   \                     ??HEXtoBCD_3:
   \   00000C   3C90E803     CMP.W   #0x3e8, R12
   \   000010   FA37         JGE     ??HEXtoBCD_0
     64          
     65              display_line[line][start] = 0x30 + value;
   \   000012   0A4D         MOV.W   R13, R10
   \   000014                RPT     #0xa
   \   000014   49180A5D     ADDX.W  R13, R10
   \   000018   0A5E         ADD.W   R14, R10
   \   00001A   3A50....     ADD.W   #display_line, R10
   \   00001E   7E403000     MOV.B   #0x30, R14
   \   000022   4F5E         ADD.B   R14, R15
   \   000024   CA4F0000     MOV.B   R15, 0(R10)
     66              value = 0;
   \   000028   0F43         MOV.W   #0x0, R15
   \   00002A   033C         JMP     ??HEXtoBCD_4
     67          
     68              while(hex_value > 99) {
     69                  hex_value -= 100;
   \                     ??HEXtoBCD_1:
   \   00002C   3C509CFF     ADD.W   #0xff9c, R12
     70                  value += 1;
   \   000030   1F53         ADD.W   #0x1, R15
     71              }
   \                     ??HEXtoBCD_4:
   \   000032   3C906400     CMP.W   #0x64, R12
   \   000036   FA37         JGE     ??HEXtoBCD_1
     72          
     73              display_line[line][start + 1] = 0x30 + value;
   \   000038   4F5E         ADD.B   R14, R15
   \   00003A   CA4F0100     MOV.B   R15, 0x1(R10)
     74              value = 0;
   \   00003E   0F43         MOV.W   #0x0, R15
   \   000040   033C         JMP     ??HEXtoBCD_5
     75          
     76              while(hex_value > 9) {
     77                  hex_value -= 10;
   \                     ??HEXtoBCD_2:
   \   000042   3C50F6FF     ADD.W   #0xfff6, R12
     78                  value += 1;
   \   000046   1F53         ADD.W   #0x1, R15
     79              }
   \                     ??HEXtoBCD_5:
   \   000048   3C900A00     CMP.W   #0xa, R12
   \   00004C   FA37         JGE     ??HEXtoBCD_2
     80          
     81              display_line[line][start + 2] = 0x30 + value;
   \   00004E   4F5E         ADD.B   R14, R15
   \   000050   CA4F0200     MOV.B   R15, 0x2(R10)
     82              display_line[line][start + 3] = 0x30 + hex_value;
   \   000054   4C5E         ADD.B   R14, R12
   \   000056   CA4C0300     MOV.B   R12, 0x3(R10)
     83          }
   \   00005A   3A41         POP.W   R10
   \   00005C   1001         RETA
     84          
     85          

   \                                 In  segment CODE, align 2
     86          int additionSafe(int val, int max, int min, int increment) {
   \                     additionSafe:
   \   000000   1B15         PUSHM.W #0x2, R11
     87              long res = val + increment;
   \   000002   0C5F         ADD.W   R15, R12
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   22B2         BIT.W   #0x4, SR
   \   000008   0B7B         SUBC.W  R11, R11
   \   00000A   3BE3         XOR.W   #0xffff, R11
     88          
     89              if(res > (long)max) res = (long)max;
   \   00000C   0C4D         MOV.W   R13, R12
   \   00000E   0D5D         RLA.W   R13
   \   000010   0D7D         SUBC.W  R13, R13
   \   000012   3DE3         XOR.W   #0xffff, R13
   \   000014   0D9B         CMP.W   R11, R13
   \   000016   0338         JL      ??additionSafe_0
   \   000018   0420         JNE     ??additionSafe_1
   \   00001A   0C9A         CMP.W   R10, R12
   \   00001C   022C         JC      ??additionSafe_1
   \                     ??additionSafe_0:
   \   00001E   0A4C         MOV.W   R12, R10
   \   000020   0B4D         MOV.W   R13, R11
     90          
     91              if(res < (long)min) res = (long)min;
   \                     ??additionSafe_1:
   \   000022   0F4E         MOV.W   R14, R15
   \   000024   0F5F         RLA.W   R15
   \   000026   0F7F         SUBC.W  R15, R15
   \   000028   3FE3         XOR.W   #0xffff, R15
   \   00002A   0B9F         CMP.W   R15, R11
   \   00002C   0338         JL      ??additionSafe_2
   \   00002E   0320         JNE     ??additionSafe_3
   \   000030   0A9E         CMP.W   R14, R10
   \   000032   012C         JC      ??additionSafe_3
   \                     ??additionSafe_2:
   \   000034   0A4E         MOV.W   R14, R10
     92          
     93              return (int)res;
   \                     ??additionSafe_3:
   \   000036   0C4A         MOV.W   R10, R12
   \   000038   1A17         POPM.W  #0x2, R11
   \   00003A   1001         RETA
     94          }
     95          

   \                                 In  segment CODE, align 2
     96          int multSafe(int a, int b) {
   \                     multSafe:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
     97              if(a == 0 || b == 0) return 0;
   \   000006   0C93         CMP.W   #0x0, R12
   \   000008   0224         JEQ     ??multSafe_2
   \   00000A   0D93         CMP.W   #0x0, R13
   \   00000C   0220         JNE     ??multSafe_3
   \                     ??multSafe_2:
   \   00000E   0C43         MOV.W   #0x0, R12
   \   000010   1E3C         JMP     ??multSafe_0
     98          
     99              int res = a * b;
   \                     ??multSafe_3:
   \   000012   0212         PUSH.W  SR
   \   000014   32C2         DINT
   \   000016   0343         NOP
   \   000018   824C....     MOV.W   R12, &__iar_HWMUL              // MPY
   \   00001C   824D....     MOV.W   R13, &__iar_HWMUL + 8          // OP2
   \   000020   1842....     MOV.W   &__iar_HWMUL + 10, R8          // RESLO
   \   000024   0343         NOP
   \   000026   3241         POP.W   SR
    100          
    101              if(a == res / b)return res;
   \   000028   0C48         MOV.W   R8, R12
   \   00002A   0E4D         MOV.W   R13, R14
   \   00002C   ........     CALLA   #?DivMod16s
   \   000030   0A9C         CMP.W   R12, R10
   \   000032   0220         JNE     ??multSafe_4
   \   000034   0C48         MOV.W   R8, R12
   \   000036   0B3C         JMP     ??multSafe_0
    102              return (INT_MAX) * (a < 0 ? -1 : 1) * (b < 0 ? -1 : 1);
   \                     ??multSafe_4:
   \   000038   0A93         CMP.W   #0x0, R10
   \   00003A   0338         JL      ??multSafe_5
   \   00003C   3C40FF7F     MOV.W   #0x7fff, R12
   \   000040   023C         JMP     ??multSafe_1
   \                     ??multSafe_5:
   \   000042   3C400180     MOV.W   #0x8001, R12
   \                     ??multSafe_1:
   \   000046   0B93         CMP.W   #0x0, R11
   \   000048   0234         JGE     ??multSafe_0
   \   00004A   3CE3         XOR.W   #0xffff, R12
   \   00004C   1C53         ADD.W   #0x1, R12
   \                     ??multSafe_0:
   \   00004E   3817         POPM.W  #0x4, R11
   \   000050   1001         RETA
    103          }

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   HEXtoBCD
      8   absVal
      8   additionSafe
     16   centerStringToDisplay
       16   -> strcpy
       16   -> strlen
     12   charInString
       12   -> strlen
     14   multSafe
       12 ?DivMod16s
      8   stoi
     12   subStringPos
       12   -> strlen


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      94  HEXtoBCD
      38  absVal
      60  additionSafe
      60  centerStringToDisplay
      40  charInString
      82  multSafe
      48  stoi
      70  subStringPos

 
 492 bytes in segment CODE
 
 492 bytes of CODE memory

Errors: none
Warnings: none
