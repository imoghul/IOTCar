###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          20/Apr/2022  11:48:01
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\anotherone\Project 10\wheels.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EW29D8.tmp
#        ("C:\Users\saad\Documents\anotherone\Project 10\wheels.c" -lC
#        "C:\Users\saad\Documents\anotherone\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\anotherone\Project 10\Debug\Obj" --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -Ohz --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\anotherone\Project 10\Debug\List\wheels.lst
#    Object file   =  
#        C:\Users\saad\Documents\anotherone\Project 10\Debug\Obj\wheels.r43
#
###############################################################################

C:\Users\saad\Documents\anotherone\Project 10\wheels.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x3c4
   \   union <unnamed> _A_TB1CCTL1_L
   \                     _A_TB1CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c6
   \   union <unnamed> _A_TB1CCTL2_L
   \                     _A_TB1CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d0
   \   union <unnamed> _A_TB1R_L
   \                     _A_TB1R_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d4
   \   union <unnamed> _A_TB1CCR1_L
   \                     _A_TB1CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d6
   \   union <unnamed> _A_TB1CCR2_L
   \                     _A_TB1CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x458
   \   union <unnamed> _A_TB3CCR3_L
   \                     _A_TB3CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x45a
   \   union <unnamed> _A_TB3CCR4_L
   \                     _A_TB3CCR4_L:
   \   000000                DS8 2
      2          #include "ports.h"
      3          #include "wheels.h"
      4          #include "adc.h"
      5          #include "timers.h"
      6          #include "detectors.h"
      7          #include "pid.h"
      8          #include "sm.h"
      9          #include <string.h>
     10          
     11          extern volatile unsigned int cycle_count;
     12          extern volatile unsigned int stopwatch_milliseconds;
     13          extern volatile unsigned int stopwatch_seconds;
     14          extern volatile unsigned char display_changed;
     15          extern char display_line[4][11];

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          volatile unsigned int wheel_periods;
   \                     wheel_periods:
   \   000000                DS8 2
     17          extern volatile unsigned int Time_Sequence;
     18          extern volatile unsigned int Last_Time_Sequence;
     19          extern volatile unsigned int time_change;
     20          extern volatile unsigned int ADC_Left_Detect, ADC_Right_Detect;

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     21          volatile unsigned int rightSwitchable = 1, leftSwitchable = 1;
   \                     rightSwitchable:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for rightSwitchable>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     leftSwitchable:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for leftSwitchable>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          unsigned int temp;
   \                     temp:
   \   000000                DS8 2
     23          extern char movingDirection;
     24          extern int leftVals[VALUES_TO_HOLD];
     25          extern int rightVals[VALUES_TO_HOLD];
     26          
     27          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     28          PIDController rightFollowController = {
   \                     rightFollowController:
   \   000000                DS8 8
   \   000008                REQUIRE `?<Initializer for rightFollowController>`
     29              .kP = 5,// /8
     30              .kD = 3,// /8
     31              //.kI = 0,
     32              .error = 0,
     33              .lastError = 0
     34              //.lastIntegral = 0
     35          };

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     36          PIDController leftFollowController = {
   \                     leftFollowController:
   \   000000                DS8 8
   \   000008                REQUIRE `?<Initializer for leftFollowController>`
     37              .kP = 5,// /8
     38              .kD = 3,// /8
     39              //.kI = 0,
     40              .error = 0,
     41              .lastError = 0
     42              //.lastIntegral = 0
     43          };
     44          
     45          

   \                                 In  segment CODE, align 2
     46          void ShutoffMotors(void) {
   \                     ShutoffMotors:
     47              ShutoffRight();
   \   000000   ........     CALLA   #ShutoffRight
     48              ShutoffLeft();
   \   000004   ........     BRA     #ShutoffLeft
     49          }
     50          

   \                                 In  segment CODE, align 2
     51          void ShutoffRight(void) {
   \                     ShutoffRight:
     52              RIGHT_FORWARD_SPEED = RIGHT_REVERSE_SPEED = WHEEL_OFF;
   \   000000   82435804     MOV.W   #0x0, &0x458
   \   000004   82435404     MOV.W   #0x0, &0x454
     53              rightSwitchable = 0;
   \   000008   8243....     MOV.W   #0x0, &rightSwitchable
     54          
     55              TB1CCTL2 &= ~CCIFG;
   \   00000C   92C3C603     BIC.W   #0x1, &0x3c6
     56              TB1CCR2 = TB1R + TB1CCR2_INTERVAL;
   \   000010   1F42D003     MOV.W   &0x3d0, R15
   \   000014   3F50A861     ADD.W   #0x61a8, R15
   \   000018   824FD603     MOV.W   R15, &0x3d6
     57              TB1CCTL2 |= CCIE;
   \   00001C   B2D01000C603 BIS.W   #0x10, &0x3c6
     58          }
   \   000022   1001         RETA
   \   000024                REQUIRE _A_TB3CCR1_L
   \   000024                REQUIRE _A_TB3CCR3_L
   \   000024                REQUIRE _A_TB1CCTL2_L
   \   000024                REQUIRE _A_TB1CCR2_L
   \   000024                REQUIRE _A_TB1R_L
     59          

   \                                 In  segment CODE, align 2
     60          void ShutoffLeft(void) {
   \                     ShutoffLeft:
     61              LEFT_FORWARD_SPEED = LEFT_REVERSE_SPEED = WHEEL_OFF;
   \   000000   82435A04     MOV.W   #0x0, &0x45a
   \   000004   82435604     MOV.W   #0x0, &0x456
     62              leftSwitchable = 0;
   \   000008   8243....     MOV.W   #0x0, &leftSwitchable
     63          
     64              TB1CCTL1 &= ~CCIFG;
   \   00000C   92C3C403     BIC.W   #0x1, &0x3c4
     65              TB1CCR1 = TB1R + TB1CCR1_INTERVAL;
   \   000010   1F42D003     MOV.W   &0x3d0, R15
   \   000014   3F50A861     ADD.W   #0x61a8, R15
   \   000018   824FD403     MOV.W   R15, &0x3d4
     66              TB1CCTL1 |= CCIE;
   \   00001C   B2D01000C403 BIS.W   #0x10, &0x3c4
     67          }
   \   000022   1001         RETA
   \   000024                REQUIRE _A_TB3CCR2_L
   \   000024                REQUIRE _A_TB3CCR4_L
   \   000024                REQUIRE _A_TB1CCTL1_L
   \   000024                REQUIRE _A_TB1CCR1_L
   \   000024                REQUIRE _A_TB1R_L
     68          

   \                                 In  segment CODE, align 2
     69          void MotorSafety(void) {
   \                     MotorSafety:
     70              if ((RIGHT_FORWARD_SPEED != 0 && RIGHT_REVERSE_SPEED != 0) || (LEFT_FORWARD_SPEED != 0 && LEFT_REVERSE_SPEED != 0)) {
   \   000000   82935404     CMP.W   #0x0, &0x454
   \   000004   0324         JEQ     ??MotorSafety_0
   \   000006   82935804     CMP.W   #0x0, &0x458
   \   00000A   0620         JNE     ??MotorSafety_1
   \                     ??MotorSafety_0:
   \   00000C   82935604     CMP.W   #0x0, &0x456
   \   000010   0724         JEQ     ??MotorSafety_2
   \   000012   82935A04     CMP.W   #0x0, &0x45a
   \   000016   0424         JEQ     ??MotorSafety_2
     71                  ShutoffMotors();
   \                     ??MotorSafety_1:
   \   000018   ........     CALLA   #ShutoffRight
   \   00001C   ........     CALLA   #ShutoffLeft
     72                  //P1OUT |= RED_LED;
     73              } else {
     74                  //P1OUT &= ~RED_LED;
     75              }
     76          }
   \                     ??MotorSafety_2:
   \   000020   1001         RETA
   \   000022                REQUIRE _A_TB3CCR1_L
   \   000022                REQUIRE _A_TB3CCR3_L
   \   000022                REQUIRE _A_TB3CCR2_L
   \   000022                REQUIRE _A_TB3CCR4_L
     77          

   \                                 In  segment CODE, align 2
     78          int RunRightMotor(int val) {
   \                     RunRightMotor:
     79              if(RIGHT_REVERSE_SPEED > 0 && val > 0 || RIGHT_FORWARD_SPEED > 0 && val < 0) {
   \   000000   82935804     CMP.W   #0x0, &0x458
   \   000004   0224         JEQ     ??RunRightMotor_1
   \   000006   1C93         CMP.W   #0x1, R12
   \   000008   0534         JGE     ??RunRightMotor_2
   \                     ??RunRightMotor_1:
   \   00000A   82935404     CMP.W   #0x0, &0x454
   \   00000E   0424         JEQ     ??RunRightMotor_3
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   0234         JGE     ??RunRightMotor_3
     80                  ShutoffRight();
   \                     ??RunRightMotor_2:
   \   000014   ........     CALLA   #ShutoffRight
     81              }
     82          
     83              if (val > 0) {
   \                     ??RunRightMotor_3:
   \   000018   1C93         CMP.W   #0x1, R12
   \   00001A   0838         JL      ??RunRightMotor_4
     84                  RIGHT_REVERSE_SPEED = WHEEL_OFF;
   \   00001C   82435804     MOV.W   #0x0, &0x458
     85          
     86                  if(rightSwitchable) RIGHT_FORWARD_SPEED = val;
   \   000020   8293....     CMP.W   #0x0, &rightSwitchable
   \   000024   1324         JEQ     ??RunRightMotor_0
   \   000026   824C5404     MOV.W   R12, &0x454
   \   00002A   103C         JMP     ??RunRightMotor_0
     87          
     88                  return 1;//P6IN & R_FORWARD;
     89              } else if (val == 0) {
   \                     ??RunRightMotor_4:
   \   00002C   0C93         CMP.W   #0x0, R12
   \   00002E   0520         JNE     ??RunRightMotor_5
     90                  ShutoffRight();
   \   000030   ........     CALLA   #ShutoffRight
     91                  return rightSwitchable;
   \   000034   1C42....     MOV.W   &rightSwitchable, R12
   \   000038   1001         RETA
     92              } else {
     93                  RIGHT_FORWARD_SPEED = WHEEL_OFF;
   \                     ??RunRightMotor_5:
   \   00003A   82435404     MOV.W   #0x0, &0x454
     94          
     95                  if(rightSwitchable) RIGHT_REVERSE_SPEED = -val;
   \   00003E   8293....     CMP.W   #0x0, &rightSwitchable
   \   000042   0424         JEQ     ??RunRightMotor_0
   \   000044   3CE3         XOR.W   #0xffff, R12
   \   000046   1C53         ADD.W   #0x1, R12
   \   000048   824C5804     MOV.W   R12, &0x458
     96          
     97                  return 1;//P6IN & R_REVERSE;
   \                     ??RunRightMotor_0:
   \   00004C   1C43         MOV.W   #0x1, R12
   \   00004E   1001         RETA
   \   000050                REQUIRE _A_TB3CCR3_L
   \   000050                REQUIRE _A_TB3CCR1_L
     98              }
     99          }
    100          

   \                                 In  segment CODE, align 2
    101          int RunLeftMotor( int val) {
   \                     RunLeftMotor:
    102              if(LEFT_REVERSE_SPEED > 0 && val > 0 || LEFT_FORWARD_SPEED > 0 && val < 0) {
   \   000000   82935A04     CMP.W   #0x0, &0x45a
   \   000004   0224         JEQ     ??RunLeftMotor_1
   \   000006   1C93         CMP.W   #0x1, R12
   \   000008   0534         JGE     ??RunLeftMotor_2
   \                     ??RunLeftMotor_1:
   \   00000A   82935604     CMP.W   #0x0, &0x456
   \   00000E   0424         JEQ     ??RunLeftMotor_3
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   0234         JGE     ??RunLeftMotor_3
    103                  ShutoffLeft();
   \                     ??RunLeftMotor_2:
   \   000014   ........     CALLA   #ShutoffLeft
    104              }
    105          
    106              if (val > 0) {
   \                     ??RunLeftMotor_3:
   \   000018   1C93         CMP.W   #0x1, R12
   \   00001A   0838         JL      ??RunLeftMotor_4
    107                  LEFT_REVERSE_SPEED = WHEEL_OFF;
   \   00001C   82435A04     MOV.W   #0x0, &0x45a
    108          
    109                  if(leftSwitchable) LEFT_FORWARD_SPEED = val;
   \   000020   8293....     CMP.W   #0x0, &leftSwitchable
   \   000024   1324         JEQ     ??RunLeftMotor_0
   \   000026   824C5604     MOV.W   R12, &0x456
   \   00002A   103C         JMP     ??RunLeftMotor_0
    110          
    111                  return 1;//P6IN & L_FORWARD;
    112              } else if (val == 0) {
   \                     ??RunLeftMotor_4:
   \   00002C   0C93         CMP.W   #0x0, R12
   \   00002E   0520         JNE     ??RunLeftMotor_5
    113                  ShutoffLeft();
   \   000030   ........     CALLA   #ShutoffLeft
    114                  return leftSwitchable;
   \   000034   1C42....     MOV.W   &leftSwitchable, R12
   \   000038   1001         RETA
    115              } else {
    116                  LEFT_FORWARD_SPEED = WHEEL_OFF;
   \                     ??RunLeftMotor_5:
   \   00003A   82435604     MOV.W   #0x0, &0x456
    117          
    118                  if(leftSwitchable) LEFT_REVERSE_SPEED = -val;
   \   00003E   8293....     CMP.W   #0x0, &leftSwitchable
   \   000042   0424         JEQ     ??RunLeftMotor_0
   \   000044   3CE3         XOR.W   #0xffff, R12
   \   000046   1C53         ADD.W   #0x1, R12
   \   000048   824C5A04     MOV.W   R12, &0x45a
    119          
    120                  return 1;//P6IN & L_REVERSE_2355;
   \                     ??RunLeftMotor_0:
   \   00004C   1C43         MOV.W   #0x1, R12
   \   00004E   1001         RETA
   \   000050                REQUIRE _A_TB3CCR4_L
   \   000050                REQUIRE _A_TB3CCR2_L
    121              }
    122          }
    123          
    124          /*int RunMotor(int val, volatile unsigned short * forwardReg, volatile unsigned short * revReg,unsigned short forwardPin, unsigned short revPin,volatile unsigned int switchable,void (*shutoff)()){
    125            if(*revReg > 0 && val > 0 || *forwardReg > 0 && val < 0) {
    126                  shutoff();
    127              }
    128          
    129              if (val > 0) {
    130                  *revReg = WHEEL_OFF;
    131          
    132                  if(switchable) {
    133                      *forwardReg = val;
    134                  }
    135          
    136                  return P6IN & forwardPin;
    137              } else if (val == 0) {
    138                  shutoff();
    139                  return switchable;
    140              } else {
    141                  *forwardReg = WHEEL_OFF;
    142          
    143                  if(switchable) *revReg = -val;
    144          
    145                  return P6IN & revPin;
    146              }
    147          }
    148          
    149          int RunRightMotor( int val){
    150            return RunMotor(val, &RIGHT_FORWARD_SPEED, &RIGHT_REVERSE_SPEED, R_FORWARD, R_REVERSE,rightSwitchable,ShutoffRight);
    151          }
    152          
    153          int RunLeftMotor( int val){
    154            return RunMotor(val, &LEFT_FORWARD_SPEED, &LEFT_REVERSE_SPEED, L_FORWARD, L_REVERSE_2355,leftSwitchable,ShutoffLeft);
    155          }*/
    156          

   \                                 In  segment CODE, align 2
    157          int LockMotors(int polR, int polL) {
   \                     LockMotors:
    158              return (Drive_Path(polR > 0 ? STRAIGHT_RIGHT : -STRAIGHT_RIGHT, polL > 0 ? STRAIGHT_LEFT : -STRAIGHT_LEFT, LOCK_TIME));
   \   000000   ........     CALLA   #?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   000004   3E409600     MOV.W   #0x96, R14
   \   000008   ........     BRA     #Drive_Path
    159          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   1D93         CMP.W   #0x1, R13
   \   000002   0334         JGE     ??LockMotors_0
   \   000004   3D4080C1     MOV.W   #0xc180, R13
   \   000008   023C         JMP     ??LockMotors_1
   \                     ??LockMotors_0:
   \   00000A   3D40803E     MOV.W   #0x3e80, R13
   \                     ??LockMotors_1:
   \   00000E   1C93         CMP.W   #0x1, R12
   \   000010   0334         JGE     ??LockMotors_2
   \   000012   3C40E0B1     MOV.W   #0xb1e0, R12
   \   000016   1001         RETA
   \                     ??LockMotors_2:
   \   000018   3C40204E     MOV.W   #0x4e20, R12
   \   00001C   1001         RETA
    160          

   \                                 In  segment CODE, align 2
    161          int LockMotorsTime(int polR, int polL, int duration) {
   \                     LockMotorsTime:
    162              return (Drive_Path(polR > 0 ? STRAIGHT_RIGHT : -STRAIGHT_RIGHT, polL > 0 ? STRAIGHT_LEFT : -STRAIGHT_LEFT, duration));
   \   000000   ........     CALLA   #?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   000004   ........     BRA     #Drive_Path
    163          }
    164          

   \                                 In  segment CODE, align 2
    165          int Update_Ticks(int milliseconds) { // each tick is 4ms
   \                     Update_Ticks:
    166              stopwatch_milliseconds += MS_PER_TICK;
   \   000000   A252....     ADD.W   #0x4, &stopwatch_milliseconds
    167          
    168              if(stopwatch_milliseconds >= milliseconds) {
   \   000004   829C....     CMP.W   R12, &stopwatch_milliseconds
   \   000008   0428         JNC     ??Update_Ticks_0
    169                  stopwatch_milliseconds = 0;
   \   00000A   8243....     MOV.W   #0x0, &stopwatch_milliseconds
    170                  return 1;
   \   00000E   1C43         MOV.W   #0x1, R12
   \   000010   1001         RETA
    171              }
    172          
    173              return 0;
   \                     ??Update_Ticks_0:
   \   000012   0C43         MOV.W   #0x0, R12
   \   000014   1001         RETA
    174          }
    175          
    176          /*int Drive_Path_Definite(int speedR, int speedL, unsigned int ticksDuration) {
    177              int successR = RunRightMotor(speedR);
    178              int successL = RunLeftMotor(speedL);
    179          
    180              if (time_change) {
    181                  time_change = 0;
    182          
    183                  if (successR && successL && Update_Ticks(ticksDuration)) {
    184                      ShutoffMotors();
    185                      return 1;
    186                  }
    187              }
    188          
    189              return 0;
    190          }
    191          
    192          
    193          int Drive_Path_Indefinite(int speedR, int speedL) {
    194              int successR = RunRightMotor(speedR);
    195              int successL = RunLeftMotor(speedL);
    196              return successR && successL;
    197          }*/
    198          

   \                                 In  segment CODE, align 2
    199          int Drive_Path(int speedR, int speedL, unsigned int ticksDuration) {
   \                     Drive_Path:
    200              /*int successR = RunRightMotor(speedR);
    201              int successL = RunLeftMotor(speedL);
    202              int success = successR && successL;*/
    203              RunRightMotor(speedR);
   \   000000   ........     CALLA   #RunRightMotor
    204              RunLeftMotor(speedL);
   \   000004   0C4D         MOV.W   R13, R12
   \   000006   ........     CALLA   #RunLeftMotor
    205          
    206              if(ticksDuration == 0) return 0;
   \   00000A   0E93         CMP.W   #0x0, R14
   \   00000C   1024         JEQ     ??Drive_Path_0
    207          
    208              if (time_change) {
   \   00000E   8293....     CMP.W   #0x0, &time_change
   \   000012   0D24         JEQ     ??Drive_Path_0
    209                  time_change = 0;
   \   000014   8243....     MOV.W   #0x0, &time_change
    210          
    211                  if (/*success && */Update_Ticks(ticksDuration)) {
   \   000018   0C4E         MOV.W   R14, R12
   \   00001A   ........     CALLA   #Update_Ticks
   \   00001E   0C93         CMP.W   #0x0, R12
   \   000020   0624         JEQ     ??Drive_Path_0
    212                      ShutoffMotors();
   \   000022   ........     CALLA   #ShutoffRight
   \   000026   ........     CALLA   #ShutoffLeft
    213                      return 1;
   \   00002A   1C43         MOV.W   #0x1, R12
   \   00002C   1001         RETA
    214                  }
    215              }
    216          
    217              return 0;
   \                     ??Drive_Path_0:
   \   00002E   0C43         MOV.W   #0x0, R12
   \   000030   1001         RETA
    218          }

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for rightSwitchable>`:
   \   000000   0100         DC16 1

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for leftSwitchable>`:
   \   000000   0100         DC16 1

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for rightFollowController>`:
   \   000000   050003000000 DC16 5, 3, 0, 0
   \            0000        

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for leftFollowController>`:
   \   000000   050003000000 DC16 5, 3, 0, 0
   \            0000        
    219          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Drive_Path
        4   -> RunLeftMotor
        4   -> RunRightMotor
        4   -> ShutoffLeft
        4   -> ShutoffRight
        4   -> Update_Ticks
      4   LockMotors
        0   -> Drive_Path
      4   LockMotorsTime
        0   -> Drive_Path
      4   MotorSafety
        4   -> ShutoffLeft
        4   -> ShutoffRight
      4   RunLeftMotor
        4   -> ShutoffLeft
      4   RunRightMotor
        4   -> ShutoffRight
      4   ShutoffLeft
      4   ShutoffMotors
        0   -> ShutoffLeft
        4   -> ShutoffRight
      4   ShutoffRight
      4   Update_Ticks


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Initializer for leftFollowController>
       2  ?<Initializer for leftSwitchable>
       8  ?<Initializer for rightFollowController>
       2  ?<Initializer for rightSwitchable>
      30  ?Subroutine0
      50  Drive_Path
      12  LockMotors
       8  LockMotorsTime
      34  MotorSafety
      80  RunLeftMotor
      80  RunRightMotor
      36  ShutoffLeft
       8  ShutoffMotors
      36  ShutoffRight
      22  Update_Ticks
       2  _A_TB1CCR1_L
       2  _A_TB1CCR2_L
       2  _A_TB1CCTL1_L
       2  _A_TB1CCTL2_L
       2  _A_TB1R_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
       2  _A_TB3CCR3_L
       2  _A_TB3CCR4_L
       8  leftFollowController
       2  leftSwitchable
       8  rightFollowController
       2  rightSwitchable
       2  temp
       2  wheel_periods

 
 396 bytes in segment CODE
  18 bytes in segment DATA16_AN
  20 bytes in segment DATA16_I
  20 bytes in segment DATA16_ID
   4 bytes in segment DATA16_Z
 
 396 bytes of CODE  memory
  20 bytes of CONST memory
  24 bytes of DATA  memory (+ 18 bytes shared)

Errors: none
Warnings: none
