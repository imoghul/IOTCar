###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          12/Apr/2022  15:54:10
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Project 10\wheels.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWA49B.tmp
#        ("C:\Users\saad\Documents\ece-306\Project 10\wheels.c" -lC
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj" --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -Ohz --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\List\wheels.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Project 10\Debug\Obj\wheels.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Project 10\wheels.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x3c4
   \   union <unnamed> _A_TB1CCTL1_L
   \                     _A_TB1CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c6
   \   union <unnamed> _A_TB1CCTL2_L
   \                     _A_TB1CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d0
   \   union <unnamed> _A_TB1R_L
   \                     _A_TB1R_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d4
   \   union <unnamed> _A_TB1CCR1_L
   \                     _A_TB1CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d6
   \   union <unnamed> _A_TB1CCR2_L
   \                     _A_TB1CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x458
   \   union <unnamed> _A_TB3CCR3_L
   \                     _A_TB3CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x45a
   \   union <unnamed> _A_TB3CCR4_L
   \                     _A_TB3CCR4_L:
   \   000000                DS8 2
      2          #include "ports.h"
      3          #include "wheels.h"
      4          #include "adc.h"
      5          #include "timers.h"
      6          #include "detectors.h"
      7          #include "pid.h"
      8          #include "sm.h"
      9          #include <string.h>
     10          
     11          extern volatile unsigned int cycle_count;
     12          extern volatile unsigned int stopwatch_milliseconds;
     13          extern volatile unsigned int stopwatch_seconds;
     14          extern volatile unsigned char display_changed;
     15          extern char display_line[4][11];

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          volatile unsigned int wheel_periods;
   \                     wheel_periods:
   \   000000                DS8 2
     17          extern volatile unsigned int Time_Sequence;
     18          extern volatile unsigned int Last_Time_Sequence;
     19          extern volatile unsigned int time_change;
     20          extern volatile unsigned int ADC_Left_Detect, ADC_Right_Detect;

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     21          volatile unsigned int rightSwitchable = 1, leftSwitchable = 1;
   \                     rightSwitchable:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for rightSwitchable>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     leftSwitchable:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for leftSwitchable>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     22          unsigned int temp;
   \                     temp:
   \   000000                DS8 2
     23          extern char movingDirection;
     24          extern int leftVals[VALUES_TO_HOLD];
     25          extern int rightVals[VALUES_TO_HOLD];
     26          
     27          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     28          PIDController rightFollowController = {
   \                     rightFollowController:
   \   000000                DS8 8
   \   000008                REQUIRE `?<Initializer for rightFollowController>`
     29              .kP = -1,
     30              .kD = 1,
     31              //.kI = 0,
     32              .error = 0,
     33              .lastError = 0
     34              //.lastIntegral = 0
     35          };

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     36          PIDController leftFollowController = {
   \                     leftFollowController:
   \   000000                DS8 8
   \   000008                REQUIRE `?<Initializer for leftFollowController>`
     37              .kP = -1,
     38              .kD = 1,
     39              //.kI = 0,
     40              .error = 0,
     41              .lastError = 0
     42              //.lastIntegral = 0
     43          };
     44          
     45          

   \                                 In  segment CODE, align 2
     46          void ShutoffMotors(void) {
   \                     ShutoffMotors:
     47              ShutoffRight();
   \   000000   ........     CALLA   #ShutoffRight
     48              ShutoffLeft();
   \   000004   ........     BRA     #ShutoffLeft
     49          }
     50          

   \                                 In  segment CODE, align 2
     51          void ShutoffRight(void) {
   \                     ShutoffRight:
     52              RIGHT_FORWARD_SPEED = RIGHT_REVERSE_SPEED = WHEEL_OFF;
   \   000000   82435804     MOV.W   #0x0, &0x458
   \   000004   82435404     MOV.W   #0x0, &0x454
     53              rightSwitchable = 0;
   \   000008   8243....     MOV.W   #0x0, &rightSwitchable
     54              TB1CCTL1 &= ~CCIFG;
   \   00000C   92C3C403     BIC.W   #0x1, &0x3c4
     55              TB1CCR1 = TB1R + TB1CCR1_INTERVAL;
   \   000010   1F42D003     MOV.W   &0x3d0, R15
   \   000014   3F50A861     ADD.W   #0x61a8, R15
   \   000018   824FD403     MOV.W   R15, &0x3d4
     56              TB1CCTL1 |= CCIE;
   \   00001C   B2D01000C403 BIS.W   #0x10, &0x3c4
     57          }
   \   000022   1001         RETA
   \   000024                REQUIRE _A_TB3CCR1_L
   \   000024                REQUIRE _A_TB3CCR3_L
   \   000024                REQUIRE _A_TB1CCTL1_L
   \   000024                REQUIRE _A_TB1CCR1_L
   \   000024                REQUIRE _A_TB1R_L
     58          

   \                                 In  segment CODE, align 2
     59          void ShutoffLeft(void) {
   \                     ShutoffLeft:
     60              LEFT_FORWARD_SPEED = LEFT_REVERSE_SPEED = WHEEL_OFF;
   \   000000   82435A04     MOV.W   #0x0, &0x45a
   \   000004   82435604     MOV.W   #0x0, &0x456
     61              leftSwitchable = 0;
   \   000008   8243....     MOV.W   #0x0, &leftSwitchable
     62              TB1CCTL2 &= ~CCIFG;
   \   00000C   92C3C603     BIC.W   #0x1, &0x3c6
     63              TB1CCR2 = TB1R + TB1CCR2_INTERVAL;
   \   000010   1F42D003     MOV.W   &0x3d0, R15
   \   000014   3F50A861     ADD.W   #0x61a8, R15
   \   000018   824FD603     MOV.W   R15, &0x3d6
     64              TB1CCTL2 |= CCIE;
   \   00001C   B2D01000C603 BIS.W   #0x10, &0x3c6
     65          }
   \   000022   1001         RETA
   \   000024                REQUIRE _A_TB3CCR2_L
   \   000024                REQUIRE _A_TB3CCR4_L
   \   000024                REQUIRE _A_TB1CCTL2_L
   \   000024                REQUIRE _A_TB1CCR2_L
   \   000024                REQUIRE _A_TB1R_L
     66          

   \                                 In  segment CODE, align 2
     67          void MotorSafety(void) {
   \                     MotorSafety:
     68              if ((RIGHT_FORWARD_SPEED != 0 && RIGHT_REVERSE_SPEED != 0) || (LEFT_FORWARD_SPEED != 0 && LEFT_REVERSE_SPEED != 0)) {
   \   000000   82935404     CMP.W   #0x0, &0x454
   \   000004   0324         JEQ     ??MotorSafety_0
   \   000006   82935804     CMP.W   #0x0, &0x458
   \   00000A   0620         JNE     ??MotorSafety_1
   \                     ??MotorSafety_0:
   \   00000C   82935604     CMP.W   #0x0, &0x456
   \   000010   0724         JEQ     ??MotorSafety_2
   \   000012   82935A04     CMP.W   #0x0, &0x45a
   \   000016   0424         JEQ     ??MotorSafety_2
     69                  ShutoffMotors();
   \                     ??MotorSafety_1:
   \   000018   ........     CALLA   #ShutoffRight
   \   00001C   ........     CALLA   #ShutoffLeft
     70                  //P1OUT |= RED_LED;
     71              } else {
     72                  //P1OUT &= ~RED_LED;
     73              }
     74          }
   \                     ??MotorSafety_2:
   \   000020   1001         RETA
   \   000022                REQUIRE _A_TB3CCR1_L
   \   000022                REQUIRE _A_TB3CCR3_L
   \   000022                REQUIRE _A_TB3CCR2_L
   \   000022                REQUIRE _A_TB3CCR4_L
     75          

   \                                 In  segment CODE, align 2
     76          int RunRightMotor(int val) {
   \                     RunRightMotor:
     77              if(RIGHT_REVERSE_SPEED > 0 && val > 0 || RIGHT_FORWARD_SPEED > 0 && val < 0) {
   \   000000   82935804     CMP.W   #0x0, &0x458
   \   000004   0224         JEQ     ??RunRightMotor_1
   \   000006   1C93         CMP.W   #0x1, R12
   \   000008   0534         JGE     ??RunRightMotor_2
   \                     ??RunRightMotor_1:
   \   00000A   82935404     CMP.W   #0x0, &0x454
   \   00000E   0424         JEQ     ??RunRightMotor_3
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   0234         JGE     ??RunRightMotor_3
     78                  ShutoffRight();
   \                     ??RunRightMotor_2:
   \   000014   ........     CALLA   #ShutoffRight
     79              }
     80          
     81              if (val > 0) {
   \                     ??RunRightMotor_3:
   \   000018   1C93         CMP.W   #0x1, R12
   \   00001A   0838         JL      ??RunRightMotor_4
     82                  RIGHT_REVERSE_SPEED = WHEEL_OFF;
   \   00001C   82435804     MOV.W   #0x0, &0x458
     83          
     84                  if(rightSwitchable) RIGHT_FORWARD_SPEED = val;
   \   000020   8293....     CMP.W   #0x0, &rightSwitchable
   \   000024   1324         JEQ     ??RunRightMotor_0
   \   000026   824C5404     MOV.W   R12, &0x454
   \   00002A   103C         JMP     ??RunRightMotor_0
     85          
     86                  return 1;//P6IN & R_FORWARD;
     87              } else if (val == 0) {
   \                     ??RunRightMotor_4:
   \   00002C   0C93         CMP.W   #0x0, R12
   \   00002E   0520         JNE     ??RunRightMotor_5
     88                  ShutoffRight();
   \   000030   ........     CALLA   #ShutoffRight
     89                  return rightSwitchable;
   \   000034   1C42....     MOV.W   &rightSwitchable, R12
   \   000038   1001         RETA
     90              } else {
     91                  RIGHT_FORWARD_SPEED = WHEEL_OFF;
   \                     ??RunRightMotor_5:
   \   00003A   82435404     MOV.W   #0x0, &0x454
     92          
     93                  if(rightSwitchable) RIGHT_REVERSE_SPEED = -val;
   \   00003E   8293....     CMP.W   #0x0, &rightSwitchable
   \   000042   0424         JEQ     ??RunRightMotor_0
   \   000044   3CE3         XOR.W   #0xffff, R12
   \   000046   1C53         ADD.W   #0x1, R12
   \   000048   824C5804     MOV.W   R12, &0x458
     94          
     95                  return 1;//P6IN & R_REVERSE;
   \                     ??RunRightMotor_0:
   \   00004C   1C43         MOV.W   #0x1, R12
   \   00004E   1001         RETA
   \   000050                REQUIRE _A_TB3CCR3_L
   \   000050                REQUIRE _A_TB3CCR1_L
     96              }
     97          }
     98          

   \                                 In  segment CODE, align 2
     99          int RunLeftMotor( int val) {
   \                     RunLeftMotor:
    100              if(LEFT_REVERSE_SPEED > 0 && val > 0 || LEFT_FORWARD_SPEED > 0 && val < 0) {
   \   000000   82935A04     CMP.W   #0x0, &0x45a
   \   000004   0224         JEQ     ??RunLeftMotor_1
   \   000006   1C93         CMP.W   #0x1, R12
   \   000008   0534         JGE     ??RunLeftMotor_2
   \                     ??RunLeftMotor_1:
   \   00000A   82935604     CMP.W   #0x0, &0x456
   \   00000E   0424         JEQ     ??RunLeftMotor_3
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   0234         JGE     ??RunLeftMotor_3
    101                  ShutoffLeft();
   \                     ??RunLeftMotor_2:
   \   000014   ........     CALLA   #ShutoffLeft
    102              }
    103          
    104              if (val > 0) {
   \                     ??RunLeftMotor_3:
   \   000018   1C93         CMP.W   #0x1, R12
   \   00001A   0838         JL      ??RunLeftMotor_4
    105                  LEFT_REVERSE_SPEED = WHEEL_OFF;
   \   00001C   82435A04     MOV.W   #0x0, &0x45a
    106          
    107                  if(leftSwitchable) LEFT_FORWARD_SPEED = val;
   \   000020   8293....     CMP.W   #0x0, &leftSwitchable
   \   000024   1324         JEQ     ??RunLeftMotor_0
   \   000026   824C5604     MOV.W   R12, &0x456
   \   00002A   103C         JMP     ??RunLeftMotor_0
    108          
    109                  return 1;//P6IN & L_FORWARD;
    110              } else if (val == 0) {
   \                     ??RunLeftMotor_4:
   \   00002C   0C93         CMP.W   #0x0, R12
   \   00002E   0520         JNE     ??RunLeftMotor_5
    111                  ShutoffLeft();
   \   000030   ........     CALLA   #ShutoffLeft
    112                  return leftSwitchable;
   \   000034   1C42....     MOV.W   &leftSwitchable, R12
   \   000038   1001         RETA
    113              } else {
    114                  LEFT_FORWARD_SPEED = WHEEL_OFF;
   \                     ??RunLeftMotor_5:
   \   00003A   82435604     MOV.W   #0x0, &0x456
    115          
    116                  if(leftSwitchable) LEFT_REVERSE_SPEED = -val;
   \   00003E   8293....     CMP.W   #0x0, &leftSwitchable
   \   000042   0424         JEQ     ??RunLeftMotor_0
   \   000044   3CE3         XOR.W   #0xffff, R12
   \   000046   1C53         ADD.W   #0x1, R12
   \   000048   824C5A04     MOV.W   R12, &0x45a
    117          
    118                  return 1;//P6IN & L_REVERSE_2355;
   \                     ??RunLeftMotor_0:
   \   00004C   1C43         MOV.W   #0x1, R12
   \   00004E   1001         RETA
   \   000050                REQUIRE _A_TB3CCR4_L
   \   000050                REQUIRE _A_TB3CCR2_L
    119              }
    120          }
    121          
    122          /*int RunMotor(int val, volatile unsigned short * forwardReg, volatile unsigned short * revReg,unsigned short forwardPin, unsigned short revPin,volatile unsigned int switchable,void (*shutoff)()){
    123            if(*revReg > 0 && val > 0 || *forwardReg > 0 && val < 0) {
    124                  shutoff();
    125              }
    126          
    127              if (val > 0) {
    128                  *revReg = WHEEL_OFF;
    129          
    130                  if(switchable) {
    131                      *forwardReg = val;
    132                  }
    133          
    134                  return P6IN & forwardPin;
    135              } else if (val == 0) {
    136                  shutoff();
    137                  return switchable;
    138              } else {
    139                  *forwardReg = WHEEL_OFF;
    140          
    141                  if(switchable) *revReg = -val;
    142          
    143                  return P6IN & revPin;
    144              }
    145          }
    146          
    147          int RunRightMotor( int val){
    148            return RunMotor(val, &RIGHT_FORWARD_SPEED, &RIGHT_REVERSE_SPEED, R_FORWARD, R_REVERSE,rightSwitchable,ShutoffRight);
    149          }
    150          
    151          int RunLeftMotor( int val){
    152            return RunMotor(val, &LEFT_FORWARD_SPEED, &LEFT_REVERSE_SPEED, L_FORWARD, L_REVERSE_2355,leftSwitchable,ShutoffLeft);
    153          }*/
    154          

   \                                 In  segment CODE, align 2, keep-with-next
    155          int LockMotors(int polR, int polL) {
   \                     LockMotors:
    156              return (Drive_Path(polR * STRAIGHT_RIGHT, polL * STRAIGHT_LEFT, LOCK_TIME));
   \   000000   3E409600     MOV.W   #0x96, R14
   \   000004                REQUIRE ?Subroutine0
   \   000004                // Fall through to label ?Subroutine0
    157          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   0212         PUSH.W  SR
   \   000002   32C2         DINT
   \   000004   0343         NOP
   \   000006   824D....     MOV.W   R13, &__iar_HWMUL              // MPY
   \   00000A   B240803E.... MOV.W   #0x3e80, &__iar_HWMUL + 8      // OP2
   \   000010   1D42....     MOV.W   &__iar_HWMUL + 10, R13         // RESLO
   \   000014   0343         NOP
   \   000016   3241         POP.W   SR
   \   000018   5C0E         RLAM.W  #0x4, R12
   \   00001A   5C02         RLAM.W  #0x1, R12
   \   00001C   0F4C         MOV.W   R12, R15
   \   00001E   5C0E         RLAM.W  #0x4, R12
   \   000020   0F5C         ADD.W   R12, R15
   \   000022   0C5C         RLA.W   R12
   \   000024   0F5C         ADD.W   R12, R15
   \   000026   0C5C         RLA.W   R12
   \   000028   0F5C         ADD.W   R12, R15
   \   00002A   5C0A         RLAM.W  #0x3, R12
   \   00002C   0C5F         ADD.W   R15, R12
   \   00002E   ........     BRA     #Drive_Path
    158          

   \                                 In  segment CODE, align 2
    159          int LockMotorsTime(int polR, int polL, int duration) {
   \                     LockMotorsTime:
    160              return (Drive_Path(polR * STRAIGHT_RIGHT, polL * STRAIGHT_LEFT, duration));
   \   000000   ....         JMP     ?Subroutine0
   \   000002   0343         NOP
    161          }
    162          

   \                                 In  segment CODE, align 2
    163          int Update_Ticks(int milliseconds) { // each tick is 4ms
   \                     Update_Ticks:
    164              stopwatch_milliseconds += MS_PER_TICK;
   \   000000   A252....     ADD.W   #0x4, &stopwatch_milliseconds
    165          
    166              if(stopwatch_milliseconds >= milliseconds) {
   \   000004   829C....     CMP.W   R12, &stopwatch_milliseconds
   \   000008   0428         JNC     ??Update_Ticks_0
    167                  stopwatch_milliseconds = 0;
   \   00000A   8243....     MOV.W   #0x0, &stopwatch_milliseconds
    168                  return 1;
   \   00000E   1C43         MOV.W   #0x1, R12
   \   000010   1001         RETA
    169              }
    170          
    171              return 0;
   \                     ??Update_Ticks_0:
   \   000012   0C43         MOV.W   #0x0, R12
   \   000014   1001         RETA
    172          }
    173          
    174          /*int Drive_Path_Definite(int speedR, int speedL, unsigned int ticksDuration) {
    175              int successR = RunRightMotor(speedR);
    176              int successL = RunLeftMotor(speedL);
    177          
    178              if (time_change) {
    179                  time_change = 0;
    180          
    181                  if (successR && successL && Update_Ticks(ticksDuration)) {
    182                      ShutoffMotors();
    183                      return 1;
    184                  }
    185              }
    186          
    187              return 0;
    188          }
    189          
    190          
    191          int Drive_Path_Indefinite(int speedR, int speedL) {
    192              int successR = RunRightMotor(speedR);
    193              int successL = RunLeftMotor(speedL);
    194              return successR && successL;
    195          }*/
    196          

   \                                 In  segment CODE, align 2
    197          int Drive_Path(int speedR, int speedL, unsigned int ticksDuration) {
   \                     Drive_Path:
   \   000000   0A12         PUSH.W  R10
    198              int successR = RunRightMotor(speedR);
   \   000002   ........     CALLA   #RunRightMotor
   \   000006   0A4C         MOV.W   R12, R10
    199              int successL = RunLeftMotor(speedL);
   \   000008   0C4D         MOV.W   R13, R12
   \   00000A   ........     CALLA   #RunLeftMotor
    200              int success = successR && successL;
   \   00000E   0A93         CMP.W   #0x0, R10
   \   000010   0524         JEQ     ??Drive_Path_3
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   0324         JEQ     ??Drive_Path_3
   \   000016   1C43         MOV.W   #0x1, R12
   \   000018   5F43         MOV.B   #0x1, R15
   \   00001A   023C         JMP     ??Drive_Path_2
   \                     ??Drive_Path_3:
   \   00001C   0C43         MOV.W   #0x0, R12
   \   00001E   4F43         MOV.B   #0x0, R15
    201              if(ticksDuration == 0) return success;
   \                     ??Drive_Path_2:
   \   000020   0E93         CMP.W   #0x0, R14
   \   000022   1324         JEQ     ??Drive_Path_1
    202          
    203              if (time_change) {
   \   000024   8293....     CMP.W   #0x0, &time_change
   \   000028   0F24         JEQ     ??Drive_Path_4
    204                  time_change = 0;
   \   00002A   8243....     MOV.W   #0x0, &time_change
    205          
    206                  if (success && Update_Ticks(ticksDuration)) {
   \   00002E   4F93         CMP.B   #0x0, R15
   \   000030   0B24         JEQ     ??Drive_Path_4
   \   000032   0C4E         MOV.W   R14, R12
   \   000034   ........     CALLA   #Update_Ticks
   \   000038   0C93         CMP.W   #0x0, R12
   \   00003A   0624         JEQ     ??Drive_Path_4
    207                      ShutoffMotors();
   \   00003C   ........     CALLA   #ShutoffRight
   \   000040   ........     CALLA   #ShutoffLeft
    208                      return 1;
   \   000044   1C43         MOV.W   #0x1, R12
   \   000046   013C         JMP     ??Drive_Path_1
    209                  }
    210              }
    211          
    212              return 0;
   \                     ??Drive_Path_4:
   \   000048   0C43         MOV.W   #0x0, R12
   \                     ??Drive_Path_1:
   \   00004A   3A41         POP.W   R10
   \   00004C   1001         RETA
    213          }

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for rightSwitchable>`:
   \   000000   0100         DC16 1

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for leftSwitchable>`:
   \   000000   0100         DC16 1

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for rightFollowController>`:
   \   000000   FFFF01000000 DC16 -1, 1, 0, 0
   \            0000        

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for leftFollowController>`:
   \   000000   FFFF01000000 DC16 -1, 1, 0, 0
   \            0000        
    214          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   Drive_Path
        6   -> RunLeftMotor
        6   -> RunRightMotor
        6   -> ShutoffLeft
        6   -> ShutoffRight
        6   -> Update_Ticks
      4   LockMotors
        0   -> Drive_Path
      4   LockMotorsTime
        0   -> Drive_Path
      4   MotorSafety
        4   -> ShutoffLeft
        4   -> ShutoffRight
      4   RunLeftMotor
        4   -> ShutoffLeft
      4   RunRightMotor
        4   -> ShutoffRight
      4   ShutoffLeft
      4   ShutoffMotors
        0   -> ShutoffLeft
        4   -> ShutoffRight
      4   ShutoffRight
      4   Update_Ticks


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Initializer for leftFollowController>
       2  ?<Initializer for leftSwitchable>
       8  ?<Initializer for rightFollowController>
       2  ?<Initializer for rightSwitchable>
      50  ?Subroutine0
      78  Drive_Path
       4  LockMotors
       4  LockMotorsTime
      34  MotorSafety
      80  RunLeftMotor
      80  RunRightMotor
      36  ShutoffLeft
       8  ShutoffMotors
      36  ShutoffRight
      22  Update_Ticks
       2  _A_TB1CCR1_L
       2  _A_TB1CCR2_L
       2  _A_TB1CCTL1_L
       2  _A_TB1CCTL2_L
       2  _A_TB1R_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
       2  _A_TB3CCR3_L
       2  _A_TB3CCR4_L
       8  leftFollowController
       2  leftSwitchable
       8  rightFollowController
       2  rightSwitchable
       2  temp
       2  wheel_periods

 
 432 bytes in segment CODE
  18 bytes in segment DATA16_AN
  20 bytes in segment DATA16_I
  20 bytes in segment DATA16_ID
   4 bytes in segment DATA16_Z
 
 432 bytes of CODE  memory
  20 bytes of CONST memory
  24 bytes of DATA  memory (+ 18 bytes shared)

Errors: none
Warnings: none
