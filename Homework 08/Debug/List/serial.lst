###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          23/Mar/2022  12:03:16
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\Homework 08\serial.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWDC2D.tmp
#        ("C:\Users\saad\Documents\ece-306\Homework 08\serial.c" -lC
#        "C:\Users\saad\Documents\ece-306\Homework 08\Debug\List" -o
#        "C:\Users\saad\Documents\ece-306\Homework 08\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\saad\Documents\ece-306\Homework 08\Debug\List\serial.lst
#    Object file   =  
#        C:\Users\saad\Documents\ece-306\Homework 08\Debug\Obj\serial.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\Homework 08\serial.c
      1          #include "serial.h"
      2          #include <string.h>
      3          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x500
   \   union <unnamed> _A_UCA0CTLW0_L
   \                     _A_UCA0CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x506
   \   union <unnamed> _A_UCA0BRW_L
   \                     _A_UCA0BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x508
   \   union <unnamed> _A_UCA0MCTLW_L
   \                     _A_UCA0MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50c
   \   union <unnamed> _A_UCA0RXBUF_L
   \                     _A_UCA0RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x50e
   \   union <unnamed> _A_UCA0TXBUF_L
   \                     _A_UCA0TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51a
   \   union <unnamed> _A_UCA0IE_L
   \                     _A_UCA0IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51c
   \   union <unnamed> _A_UCA0IFG_L
   \                     _A_UCA0IFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x51e
   \   union <unnamed> _A_UCA0IV_L
   \                     _A_UCA0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x580
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x586
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x588
   \   union <unnamed> _A_UCA1MCTLW_L
   \                     _A_UCA1MCTLW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x58e
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59a
   \   union <unnamed> _A_UCA1IE_L
   \                     _A_UCA1IE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x59e
   \   union <unnamed> _A_UCA1IV_L
   \                     _A_UCA1IV_L:
   \   000000                DS8 2
      4          
      5          // global variables

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      6          volatile unsigned int usb0_rx_ring_wr,usb0_rx_ring_rd,usb1_rx_ring_wr,usb1_rx_ring_rd ;
   \                     usb0_rx_ring_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb0_rx_ring_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_ring_wr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     usb1_rx_ring_rd:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      7          volatile char USB0_Char_Rx[SMALL_RING_SIZE],USB1_Char_Rx[SMALL_RING_SIZE];
   \                     USB0_Char_Rx:
   \   000000                DS8 12

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     USB1_Char_Rx:
   \   000000                DS8 12
      8          extern unsigned volatile UCA0_index,UCA1_index;
      9          extern char* test_command;
     10          extern volatile unsigned char display_changed;
     11          extern char display_line[4][11];
     12          
     13          //----------------------------------------------------------------------------

   \                                 In  segment CODE, align 2
     14          void Init_Serial_UCA(void) {
   \                     Init_Serial_UCA:
     15              int i;
     16          
     17              for(i = 0; i < SMALL_RING_SIZE; i++) {
   \   000000   0F43         MOV.W   #0x0, R15
   \                     ??Init_Serial_UCA_0:
   \   000002   3F900C00     CMP.W   #0xc, R15
   \   000006   0634         JGE     ??Init_Serial_UCA_1
     18                  USB0_Char_Rx[i] = 0x00;
   \   000008   CF43....     MOV.B   #0x0, USB0_Char_Rx(R15)
     19                  USB1_Char_Rx[i] = 0x00;
   \   00000C   CF43....     MOV.B   #0x0, USB1_Char_Rx(R15)
     20              }
   \   000010   1F53         ADD.W   #0x1, R15
   \   000012   F73F         JMP     ??Init_Serial_UCA_0
     21          
     22              usb0_rx_ring_wr = BEGINNING;
   \                     ??Init_Serial_UCA_1:
   \   000014   8243....     MOV.W   #0x0, &usb0_rx_ring_wr
     23              usb0_rx_ring_rd = BEGINNING;
   \   000018   8243....     MOV.W   #0x0, &usb0_rx_ring_rd
     24              usb1_rx_ring_wr = BEGINNING;
   \   00001C   8243....     MOV.W   #0x0, &usb1_rx_ring_wr
     25              usb1_rx_ring_rd = BEGINNING;
   \   000020   8243....     MOV.W   #0x0, &usb1_rx_ring_rd
     26          
     27              //for(i = 0; i < LARGE_RING_SIZE; i++) {
     28              //    USB_Char_Tx[i] = 0x00;
     29              //}
     30          
     31              //usb_tx_ring_wr = BEGINNING;
     32              //usb_tx_ring_rd = BEGINNING;
     33              
     34              // Configure UART 0
     35              UCA0CTLW0 = 0;
   \   000024   82430005     MOV.W   #0x0, &0x500
     36              UCA0CTLW0 |= UCSWRST;
   \   000028   92D30005     BIS.W   #0x1, &0x500
     37              UCA0CTLW0 |= UCSSEL__SMCLK;
   \   00002C   B2D080000005 BIS.W   #0x80, &0x500
     38              UCA0BRW = 4;
   \   000032   A2420605     MOV.W   #0x4, &0x506
     39              UCA0MCTLW = 0x5551;
   \   000036   B24051550805 MOV.W   #0x5551, &0x508
     40              UCA0CTLW0 &= ~UCSWRST;
   \   00003C   92C30005     BIC.W   #0x1, &0x500
     41              UCA0IE |= UCRXIE;
   \   000040   92D31A05     BIS.W   #0x1, &0x51a
     42              // Configure UART 1
     43              UCA1CTLW0 = 0;
   \   000044   82438005     MOV.W   #0x0, &0x580
     44              UCA1CTLW0 |= UCSWRST;
   \   000048   92D38005     BIS.W   #0x1, &0x580
     45              UCA1CTLW0 |= UCSSEL__SMCLK;
   \   00004C   B2D080008005 BIS.W   #0x80, &0x580
     46              UCA1BRW = 4;
   \   000052   A2428605     MOV.W   #0x4, &0x586
     47              UCA1MCTLW = 0x5551;
   \   000056   B24051558805 MOV.W   #0x5551, &0x588
     48              UCA1CTLW0 &= ~UCSWRST;
   \   00005C   92C38005     BIC.W   #0x1, &0x580
     49              UCA1IE |= UCRXIE;
   \   000060   92D39A05     BIS.W   #0x1, &0x59a
     50          }
   \   000064   1001         RETA
   \   000066                REQUIRE _A_UCA0CTLW0_L
   \   000066                REQUIRE _A_UCA0BRW_L
   \   000066                REQUIRE _A_UCA0MCTLW_L
   \   000066                REQUIRE _A_UCA0IE_L
   \   000066                REQUIRE _A_UCA1CTLW0_L
   \   000066                REQUIRE _A_UCA1BRW_L
   \   000066                REQUIRE _A_UCA1MCTLW_L
   \   000066                REQUIRE _A_UCA1IE_L
     51          //------------------------------------------------------------------------------
     52          #pragma vector=EUSCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
     53          __interrupt void eUSCI_A0_ISR(void) {
   \                     eUSCI_A0_ISR:
   \   000000   5F15         PUSHM.W #0x6, R15
     54              unsigned int temp;
     55          
     56              switch(__even_in_range(UCA0IV, 0x08)) {
                     ^
Warning[Pe546]: transfer of control bypasses initialization of:
            variable "i" (declared at line 69)
   \   000002   1F421E05     MOV.W   &0x51e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A0_ISR>_0`:
   \   000008   623C         JMP     ??eUSCI_A0_ISR_3
   \   00000A   033C         JMP     ??eUSCI_A0_ISR_10
   \   00000C   303C         JMP     ??eUSCI_A0_ISR_11
   \   00000E   5F3C         JMP     ??eUSCI_A0_ISR_3
   \   000010   5E3C         JMP     ??eUSCI_A0_ISR_3
     57                  case 0:
     58                      break;
     59          
     60                  case 2: // RXIFG
     61                      temp = usb0_rx_ring_wr++;
   \                     ??eUSCI_A0_ISR_10:
   \   000012   1F42....     MOV.W   &usb0_rx_ring_wr, R15
   \   000016   0E4F         MOV.W   R15, R14
   \   000018   1E53         ADD.W   #0x1, R14
   \   00001A   824E....     MOV.W   R14, &usb0_rx_ring_wr
   \   00001E   0A4F         MOV.W   R15, R10
     62                      USB0_Char_Rx[temp] = UCA0RXBUF;
   \   000020   1E420C05     MOV.W   &0x50c, R14
   \   000024   CA4E....     MOV.B   R14, USB0_Char_Rx(R10)
     63                      
     64                      if (usb0_rx_ring_wr >= (sizeof(USB0_Char_Rx))) {
   \   000028   B2900C00.... CMP.W   #0xc, &usb0_rx_ring_wr
   \   00002E   0228         JNC     ??eUSCI_A0_ISR_5
     65                          usb0_rx_ring_wr = BEGINNING;
   \   000030   8243....     MOV.W   #0x0, &usb0_rx_ring_wr
     66                      }
     67                      
     68                  strcpy(display_line[1], "          ");
   \                     ??eUSCI_A0_ISR_5:
   \   000034   3D40....     MOV.W   #`?<Constant "          ">`, R13
   \   000038   3C40....     MOV.W   #display_line + 11, R12
   \   00003C   ........     CALLA   #strcpy
     69                  int i = 0;
   \   000040   0E43         MOV.W   #0x0, R14
     70                  for(;i<10 && USB0_Char_Rx[i]!=0;++i)
   \                     ??eUSCI_A0_ISR_0:
   \   000042   3E900A00     CMP.W   #0xa, R14
   \   000046   0834         JGE     ??eUSCI_A0_ISR_1
   \   000048   CE93....     CMP.B   #0x0, USB0_Char_Rx(R14)
   \   00004C   0524         JEQ     ??eUSCI_A0_ISR_1
     71                    display_line[0][i] = USB0_Char_Rx[i];
   \   00004E   DE4E........ MOV.B   USB0_Char_Rx(R14), display_line(R14)
   \   000054   1E53         ADD.W   #0x1, R14
   \   000056   F53F         JMP     ??eUSCI_A0_ISR_0
     72                  for(;i<10;++i) display_line[0][i]=' ';
   \                     ??eUSCI_A0_ISR_1:
   \   000058   3E900A00     CMP.W   #0xa, R14
   \   00005C   0534         JGE     ??eUSCI_A0_ISR_6
   \   00005E   FE402000.... MOV.B   #0x20, display_line(R14)
   \   000064   1E53         ADD.W   #0x1, R14
   \   000066   F83F         JMP     ??eUSCI_A0_ISR_1
     73                  display_line[0][10] = 0;
   \                     ??eUSCI_A0_ISR_6:
   \   000068   C243....     MOV.B   #0x0, &display_line + 10
     74          
     75                      break;
   \   00006C   303C         JMP     ??eUSCI_A0_ISR_3
     76          
     77                  case 4: // TXIFG
     78                    switch(UCA0_index++){
   \                     ??eUSCI_A0_ISR_11:
   \   00006E   1F42....     MOV.W   &UCA0_index, R15
   \   000072   0D4F         MOV.W   R15, R13
   \   000074   1D53         ADD.W   #0x1, R13
   \   000076   824D....     MOV.W   R13, &UCA0_index
   \   00007A   0F83         SUB.W   #0x0, R15
   \   00007C   1524         JEQ     ??eUSCI_A0_ISR_7
   \   00007E   1F83         SUB.W   #0x1, R15
   \   000080   1324         JEQ     ??eUSCI_A0_ISR_7
   \   000082   1F83         SUB.W   #0x1, R15
   \   000084   1124         JEQ     ??eUSCI_A0_ISR_7
   \   000086   1F83         SUB.W   #0x1, R15
   \   000088   0F24         JEQ     ??eUSCI_A0_ISR_7
   \   00008A   1F83         SUB.W   #0x1, R15
   \   00008C   0D24         JEQ     ??eUSCI_A0_ISR_7
   \   00008E   1F83         SUB.W   #0x1, R15
   \   000090   0B24         JEQ     ??eUSCI_A0_ISR_7
   \   000092   1F83         SUB.W   #0x1, R15
   \   000094   0924         JEQ     ??eUSCI_A0_ISR_7
   \   000096   1F83         SUB.W   #0x1, R15
   \   000098   0724         JEQ     ??eUSCI_A0_ISR_7
   \   00009A   1F83         SUB.W   #0x1, R15
   \   00009C   0524         JEQ     ??eUSCI_A0_ISR_7
   \   00009E   1F83         SUB.W   #0x1, R15
   \   0000A0   0C24         JEQ     ??eUSCI_A0_ISR_8
   \   0000A2   1F83         SUB.W   #0x1, R15
   \   0000A4   0E24         JEQ     ??eUSCI_A0_ISR_9
   \   0000A6   113C         JMP     ??eUSCI_A0_ISR_4
     79                      case 0:
     80                      case 1:
     81                      case 2:
     82                      case 3:
     83                      case 4:
     84                      case 5:
     85                      case 6:
     86                      case 7:
     87                      case 8:
     88                        UCA0TXBUF = test_command[UCA0_index];
   \                     ??eUSCI_A0_ISR_7:
   \   0000A8   1F42....     MOV.W   &test_command, R15
   \   0000AC   1F52....     ADD.W   &UCA0_index, R15
   \   0000B0   6F4F         MOV.B   @R15, R15
   \   0000B2   4F4F         MOV.B   R15, R15
   \   0000B4   824F0E05     MOV.W   R15, &0x50e
     89                        break;
   \   0000B8   0A3C         JMP     ??eUSCI_A0_ISR_3
     90                      case 9:
     91                        UCA0TXBUF = 0x0D;
   \                     ??eUSCI_A0_ISR_8:
   \   0000BA   B2400D000E05 MOV.W   #0xd, &0x50e
     92                        break;
   \   0000C0   063C         JMP     ??eUSCI_A0_ISR_3
     93                      case 10:
     94                        UCA0TXBUF = 0x0A;
   \                     ??eUSCI_A0_ISR_9:
   \   0000C2   B2400A000E05 MOV.W   #0xa, &0x50e
     95                        break;
   \   0000C8   023C         JMP     ??eUSCI_A0_ISR_3
     96                      default:
     97                        UCA0IE &= ~UCTXIE;
   \                     ??eUSCI_A0_ISR_4:
   \   0000CA   A2C31A05     BIC.W   #0x2, &0x51a
     98                        break;
     99                      
    100                    }
    101                    break;
    102          
    103                  default:
    104                      break;
    105              }
    106          }
   \                     ??eUSCI_A0_ISR_3:
   \   0000CE   5A17         POPM.W  #0x6, R15
   \   0000D0   0013         RETI
   \   0000D2                REQUIRE _A_UCA0RXBUF_L
   \   0000D2                REQUIRE _A_UCA0TXBUF_L
   \   0000D2                REQUIRE _A_UCA0IE_L
   \   0000D2                REQUIRE _A_UCA0IV_L
    107          
    108          #pragma vector=EUSCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    109          __interrupt void eUSCI_A1_ISR(void) {
   \                     eUSCI_A1_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
    110              unsigned int temp;
                                  ^
Warning[Pe177]: variable "temp" was declared but never referenced
    111          
    112              switch(__even_in_range(UCA1IV, 0x08)) {
   \   000002   1F429E05     MOV.W   &0x59e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for eUSCI_A1_ISR>_0`:
   \   000008   343C         JMP     ??eUSCI_A1_ISR_2
   \   00000A   333C         JMP     ??eUSCI_A1_ISR_2
   \   00000C   023C         JMP     ??eUSCI_A1_ISR_6
   \   00000E   313C         JMP     ??eUSCI_A1_ISR_2
   \   000010   303C         JMP     ??eUSCI_A1_ISR_2
    113                  case 0:
    114                      break;
    115          
    116                  case 2: // RXIFG
    117                      /*temp = usb1_rx_ring_wr++;
    118                      USB1_Char_Rx[temp] = UCA1RXBUF;
    119                      
    120                      if (usb1_rx_ring_wr >= (sizeof(USB1_Char_Rx))) {
    121                          usb1_rx_ring_wr = BEGINNING;
    122                      }
    123                      
    124                      strcpy(display_line[1], "          ");
    125                      int i = 0;
    126                      for(;i<10 && USB1_Char_Rx[i]!=0;++i)
    127                        display_line[1][i] = USB1_Char_Rx[i];
    128                      for(;i<10;++i) display_line[1][i]=' ';
    129                      display_line[1][10] = 0;*/
    130          
    131                      break;
    132          
    133                  case 4: // TXIFG
    134                    switch(UCA1_index++){
   \                     ??eUSCI_A1_ISR_6:
   \   000012   1F42....     MOV.W   &UCA1_index, R15
   \   000016   0E4F         MOV.W   R15, R14
   \   000018   1E53         ADD.W   #0x1, R14
   \   00001A   824E....     MOV.W   R14, &UCA1_index
   \   00001E   0F83         SUB.W   #0x0, R15
   \   000020   1524         JEQ     ??eUSCI_A1_ISR_3
   \   000022   1F83         SUB.W   #0x1, R15
   \   000024   1324         JEQ     ??eUSCI_A1_ISR_3
   \   000026   1F83         SUB.W   #0x1, R15
   \   000028   1124         JEQ     ??eUSCI_A1_ISR_3
   \   00002A   1F83         SUB.W   #0x1, R15
   \   00002C   0F24         JEQ     ??eUSCI_A1_ISR_3
   \   00002E   1F83         SUB.W   #0x1, R15
   \   000030   0D24         JEQ     ??eUSCI_A1_ISR_3
   \   000032   1F83         SUB.W   #0x1, R15
   \   000034   0B24         JEQ     ??eUSCI_A1_ISR_3
   \   000036   1F83         SUB.W   #0x1, R15
   \   000038   0924         JEQ     ??eUSCI_A1_ISR_3
   \   00003A   1F83         SUB.W   #0x1, R15
   \   00003C   0724         JEQ     ??eUSCI_A1_ISR_3
   \   00003E   1F83         SUB.W   #0x1, R15
   \   000040   0524         JEQ     ??eUSCI_A1_ISR_3
   \   000042   1F83         SUB.W   #0x1, R15
   \   000044   0C24         JEQ     ??eUSCI_A1_ISR_4
   \   000046   1F83         SUB.W   #0x1, R15
   \   000048   0E24         JEQ     ??eUSCI_A1_ISR_5
   \   00004A   113C         JMP     ??eUSCI_A1_ISR_1
    135                      case 0:
    136                      case 1:
    137                      case 2:
    138                      case 3:
    139                      case 4:
    140                      case 5:
    141                      case 6:
    142                      case 7:
    143                      case 8:
    144                        UCA1TXBUF = test_command[UCA1_index];
   \                     ??eUSCI_A1_ISR_3:
   \   00004C   1F42....     MOV.W   &test_command, R15
   \   000050   1F52....     ADD.W   &UCA1_index, R15
   \   000054   6F4F         MOV.B   @R15, R15
   \   000056   4F4F         MOV.B   R15, R15
   \   000058   824F8E05     MOV.W   R15, &0x58e
    145                        break;
   \   00005C   0A3C         JMP     ??eUSCI_A1_ISR_2
    146                      case 9:
    147                        UCA1TXBUF = 0x0D;
   \                     ??eUSCI_A1_ISR_4:
   \   00005E   B2400D008E05 MOV.W   #0xd, &0x58e
    148                        break;
   \   000064   063C         JMP     ??eUSCI_A1_ISR_2
    149                      case 10:
    150                        UCA1TXBUF = 0x0A;
   \                     ??eUSCI_A1_ISR_5:
   \   000066   B2400A008E05 MOV.W   #0xa, &0x58e
    151                        break;
   \   00006C   023C         JMP     ??eUSCI_A1_ISR_2
    152                      default:
    153                        UCA1IE &= ~UCTXIE;
   \                     ??eUSCI_A1_ISR_1:
   \   00006E   A2C39A05     BIC.W   #0x2, &0x59a
    154                        break;
    155                      
    156                    }
    157                    break;
    158          
    159                  default:
    160                      break;
    161              }
    162          }
   \                     ??eUSCI_A1_ISR_2:
   \   000072   1E17         POPM.W  #0x2, R15
   \   000074   0013         RETI
   \   000076                REQUIRE _A_UCA1TXBUF_L
   \   000076                REQUIRE _A_UCA1IE_L
   \   000076                REQUIRE _A_UCA1IV_L
    163          

   \                                 In  segment CODE, align 2
    164          void out_character(char character) {
   \                     out_character:
   \                     ??out_character_0:
    165              //------------------------------------------------------------------------------
    166              // The while loop will stall as long as the Flag is not set [port is busy]
    167              while (!(UCA0IFG & UCTXIFG)); // USCI_A0 TX buffer ready?
   \   000000   A2B31C05     BIT.W   #0x2, &0x51c
   \   000004   FD2B         JNC     ??out_character_0
    168          
    169              UCA0TXBUF = character;
   \   000006   4C4C         MOV.B   R12, R12
   \   000008   824C0E05     MOV.W   R12, &0x50e
    170              //------------------------------------------------------------------------------
    171          }
   \   00000C   1001         RETA
   \   00000E                REQUIRE _A_UCA0IFG_L
   \   00000E                REQUIRE _A_UCA0TXBUF_L

   \                                 In  segment INTVEC, offset 0x40, root
   \                     `??eUSCI_A1_ISR::??INTVEC 64`:
   \   000040   ....         DC16    eUSCI_A1_ISR

   \                                 In  segment INTVEC, offset 0x42, root
   \                     `??eUSCI_A0_ISR::??INTVEC 66`:
   \   000042   ....         DC16    eUSCI_A0_ISR

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "          ">`:
   \   000000   202020202020 DC8 "          "
   \            2020202000  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Init_Serial_UCA
     16   eUSCI_A0_ISR
       16   -> strcpy
      8   eUSCI_A1_ISR
      4   out_character


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "          ">
     102  Init_Serial_UCA
      12  USB0_Char_Rx
      12  USB1_Char_Rx
       2  _A_UCA0BRW_L
       2  _A_UCA0CTLW0_L
       2  _A_UCA0IE_L
       2  _A_UCA0IFG_L
       2  _A_UCA0IV_L
       2  _A_UCA0MCTLW_L
       2  _A_UCA0RXBUF_L
       2  _A_UCA0TXBUF_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1IE_L
       2  _A_UCA1IV_L
       2  _A_UCA1MCTLW_L
       2  _A_UCA1TXBUF_L
     210  eUSCI_A0_ISR
       2  eUSCI_A0_ISR::??INTVEC 66
     118  eUSCI_A1_ISR
       2  eUSCI_A1_ISR::??INTVEC 64
      14  out_character
       2  usb0_rx_ring_rd
       2  usb0_rx_ring_wr
       2  usb1_rx_ring_rd
       2  usb1_rx_ring_wr

 
 116 bytes in segment CODE
  28 bytes in segment DATA16_AN
  11 bytes in segment DATA16_C
  32 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 328 bytes in segment ISR_CODE
 
 444 bytes of CODE  memory
  11 bytes of CONST memory (+  4 bytes shared)
  32 bytes of DATA  memory (+ 28 bytes shared)

Errors: none
Warnings: 2
