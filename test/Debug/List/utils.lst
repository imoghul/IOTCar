###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          10/Apr/2022  15:40:59
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\saad\Documents\ece-306\test\utils.c
#    Command line  =  
#        -f C:\Users\saad\AppData\Local\Temp\EWDE8C.tmp
#        (C:\Users\saad\Documents\ece-306\test\utils.c -lC
#        C:\Users\saad\Documents\ece-306\test\Debug\List -o
#        C:\Users\saad\Documents\ece-306\test\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --debug -D__MSP430FR2355__ -e
#        --double=32 --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I ./ --core=430X
#        --data_model=small -On --multiplier=32 --hw_workaround=CPU40
#        --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  C:\Users\saad\Documents\ece-306\test\Debug\List\utils.lst
#    Object file   =  C:\Users\saad\Documents\ece-306\test\Debug\Obj\utils.r43
#
###############################################################################

C:\Users\saad\Documents\ece-306\test\utils.c
      1          #include <string.h>
      2          #include "utils.h"
      3          #include "macros.h"
      4          extern volatile unsigned char display_changed;
      5          extern char display_line[4][11];
      6          

   \                                 In  segment CODE, align 2
      7          void centerStringToDisplay(unsigned int line, char * s) {
   \                     centerStringToDisplay:
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
      8              strcpy(display_line[line] + ((10 - strlen(s)) >> 1), s);
   \   000006   0C4B         MOV.W   R11, R12
   \   000008   ........     CALLA   #strlen
   \   00000C   0D4B         MOV.W   R11, R13
   \   00000E   0F4A         MOV.W   R10, R15
   \   000010                RPT     #0xa
   \   000010   49180F5A     ADDX.W  R10, R15
   \   000014   3E400A00     MOV.W   #0xa, R14
   \   000018   0E8C         SUB.W   R12, R14
   \   00001A   5E03         RRUM.W  #0x1, R14
   \   00001C   0F5E         ADD.W   R14, R15
   \   00001E   3F50....     ADD.W   #display_line, R15
   \   000022   0C4F         MOV.W   R15, R12
   \   000024   ........     CALLA   #strcpy
      9          }
   \   000028   1A17         POPM.W  #0x2, R11
   \   00002A   1001         RETA
     10          

   \                                 In  segment CODE, align 2
     11          char* subStringPos(const char* str,char * subString) {
   \                     subStringPos:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
     12          
     13              int i = 0;
   \   000006   0843         MOV.W   #0x0, R8
     14              int d = 0;
   \   000008   0943         MOV.W   #0x0, R9
     15          
     16              int lenSub = strlen(subString);
   \   00000A   0C4B         MOV.W   R11, R12
   \   00000C   ........     CALLA   #strlen
   \   000010   064C         MOV.W   R12, R6
     17              int len = strlen(str) - lenSub;
   \   000012   0C4A         MOV.W   R10, R12
   \   000014   ........     CALLA   #strlen
   \   000018   0E4C         MOV.W   R12, R14
   \   00001A   0E86         SUB.W   R6, R14
     18              
     19              for (i = 0; i < len;i++) {
   \   00001C   0843         MOV.W   #0x0, R8
   \                     ??subStringPos_1:
   \   00001E   089E         CMP.W   R14, R8
   \   000020   1834         JGE     ??subStringPos_4
     20                  int exists = 1;
   \   000022   1D43         MOV.W   #0x1, R13
     21          
     22                  for (d = 0; d < lenSub; d++) {
   \   000024   0943         MOV.W   #0x0, R9
   \                     ??subStringPos_0:
   \   000026   0996         CMP.W   R6, R9
   \   000028   0D34         JGE     ??subStringPos_2
     23                      if (str[i + d] != subString[d]) {
   \   00002A   0F48         MOV.W   R8, R15
   \   00002C   0F59         ADD.W   R9, R15
   \   00002E   0C4A         MOV.W   R10, R12
   \   000030   0C5F         ADD.W   R15, R12
   \   000032   0F4B         MOV.W   R11, R15
   \   000034   0F59         ADD.W   R9, R15
   \   000036   EC9F0000     CMP.B   @R15, 0(R12)
   \   00003A   0224         JEQ     ??subStringPos_5
     24                          exists = 0;
   \   00003C   0D43         MOV.W   #0x0, R13
     25                          break;
   \   00003E   023C         JMP     ??subStringPos_2
     26                      }
     27                  }
   \                     ??subStringPos_5:
   \   000040   1953         ADD.W   #0x1, R9
   \   000042   F13F         JMP     ??subStringPos_0
     28          
     29                  if (exists) return (char*)(str + i);
   \                     ??subStringPos_2:
   \   000044   0D93         CMP.W   #0x0, R13
   \   000046   0324         JEQ     ??subStringPos_6
   \   000048   0A58         ADD.W   R8, R10
   \   00004A   0C4A         MOV.W   R10, R12
   \   00004C   033C         JMP     ??subStringPos_3
     30              }
   \                     ??subStringPos_6:
   \   00004E   1853         ADD.W   #0x1, R8
   \   000050   E63F         JMP     ??subStringPos_1
     31              return 0;
   \                     ??subStringPos_4:
   \   000052   0C43         MOV.W   #0x0, R12
   \                     ??subStringPos_3:
   \   000054   5617         POPM.W  #0x6, R11
   \   000056   1001         RETA
     32          }
     33          

   \                                 In  segment CODE, align 2
     34          int stoi(char* str,int len) {
   \                     stoi:
   \   000000   0A12         PUSH.W  R10
   \   000002   0E4C         MOV.W   R12, R14
     35              int num = 0;
   \   000004   0C43         MOV.W   #0x0, R12
     36              for(int i = 0; i < len && str[i] >= '0' && str[i] <= '9'; ++i)
   \   000006   0A43         MOV.W   #0x0, R10
   \                     ??stoi_0:
   \   000008   0A9D         CMP.W   R13, R10
   \   00000A   1734         JGE     ??stoi_1
   \   00000C   0F4E         MOV.W   R14, R15
   \   00000E   0F5A         ADD.W   R10, R15
   \   000010   FF9030000000 CMP.B   #0x30, 0(R15)
   \   000016   1128         JNC     ??stoi_1
   \   000018   0F4E         MOV.W   R14, R15
   \   00001A   0F5A         ADD.W   R10, R15
   \   00001C   FF903A000000 CMP.B   #0x3a, 0(R15)
   \   000022   0B2C         JC      ??stoi_1
     37                  num = num * 10 + (int)(str[i] - '0');
   \   000024   0F4E         MOV.W   R14, R15
   \   000026   0F5A         ADD.W   R10, R15
   \   000028   6F4F         MOV.B   @R15, R15
   \   00002A   4F4F         MOV.B   R15, R15
   \   00002C                RPT     #0xa
   \   00002C   49180F5C     ADDX.W  R12, R15
   \   000030   0C4F         MOV.W   R15, R12
   \   000032   3C50D0FF     ADD.W   #0xffd0, R12
   \   000036   1A53         ADD.W   #0x1, R10
   \   000038   E73F         JMP     ??stoi_0
     38              return num;
   \                     ??stoi_1:
   \   00003A   3A41         POP.W   R10
   \   00003C   1001         RETA
     39          }
     40          

   \                                 In  segment CODE, align 2
     41          char* charInString(const char* str, char c) {
   \                     charInString:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   4A4D         MOV.B   R13, R10
     42              for(int i = 0; i < strlen(str)+1; i++)
   \   000006   0843         MOV.W   #0x0, R8
   \                     ??charInString_0:
   \   000008   0C4B         MOV.W   R11, R12
   \   00000A   ........     CALLA   #strlen
   \   00000E   1C53         ADD.W   #0x1, R12
   \   000010   089C         CMP.W   R12, R8
   \   000012   0A2C         JC      ??charInString_2
     43                  if(str[i] == c) return (char*)(str + i);
   \   000014   0F4B         MOV.W   R11, R15
   \   000016   0F58         ADD.W   R8, R15
   \   000018   CF9A0000     CMP.B   R10, 0(R15)
   \   00001C   0320         JNE     ??charInString_3
   \   00001E   0B58         ADD.W   R8, R11
   \   000020   0C4B         MOV.W   R11, R12
   \   000022   033C         JMP     ??charInString_1
   \                     ??charInString_3:
   \   000024   1853         ADD.W   #0x1, R8
   \   000026   F03F         JMP     ??charInString_0
     44          
     45              return 0;
   \                     ??charInString_2:
   \   000028   0C43         MOV.W   #0x0, R12
   \                     ??charInString_1:
   \   00002A   3817         POPM.W  #0x4, R11
   \   00002C   1001         RETA
     46          }
     47          

   \                                 In  segment CODE, align 2
     48          unsigned int absVal(int n) {
   \                     absVal:
   \   000000   B1000400     SUBA    #0x4, SP
     49              const int ret[2] = {n, -n};
   \   000004   814C0000     MOV.W   R12, 0(SP)
   \   000008   0F4C         MOV.W   R12, R15
   \   00000A   3FE3         XOR.W   #0xffff, R15
   \   00000C   1F53         ADD.W   #0x1, R15
   \   00000E   814F0200     MOV.W   R15, 0x2(SP)
     50              return (unsigned int)(ret [n < 0]);
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   0234         JGE     ??absVal_1
   \   000016   5F43         MOV.B   #0x1, R15
   \   000018   013C         JMP     ??absVal_0
   \                     ??absVal_1:
   \   00001A   4F43         MOV.B   #0x0, R15
   \                     ??absVal_0:
   \   00001C   4F4F         MOV.B   R15, R15
   \   00001E   0F5F         RLA.W   R15
   \   000020   0F51         ADD.W   SP, R15
   \   000022   2C4F         MOV.W   @R15, R12
   \   000024   A1000400     ADDA    #0x4, SP
   \   000028   1001         RETA
     51          }
     52          

   \                                 In  segment CODE, align 2
     53          void HEXtoBCD(int hex_value, int line, int start) {
   \                     HEXtoBCD:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4E         MOV.W   R14, R10
     54              int value = 0;
   \   000004   0F43         MOV.W   #0x0, R15
     55          
     56              while(hex_value > 999) {
   \                     ??HEXtoBCD_0:
   \   000006   3C90E803     CMP.W   #0x3e8, R12
   \   00000A   0438         JL      ??HEXtoBCD_3
     57                  hex_value -= 1000;
   \   00000C   3C5018FC     ADD.W   #0xfc18, R12
     58                  value += 1;
   \   000010   1F53         ADD.W   #0x1, R15
   \   000012   F93F         JMP     ??HEXtoBCD_0
     59              }
     60          
     61              display_line[line][start] = 0x30 + value;
   \                     ??HEXtoBCD_3:
   \   000014   0E12         PUSH.W  R14
   \   000016   C14F0000     MOV.B   R15, 0(SP)
   \   00001A   3E41         POP.W   R14
   \   00001C   7E503000     ADD.B   #0x30, R14
   \   000020   0B4D         MOV.W   R13, R11
   \   000022                RPT     #0xa
   \   000022   49180B5D     ADDX.W  R13, R11
   \   000026   0B5A         ADD.W   R10, R11
   \   000028   CB4E....     MOV.B   R14, display_line(R11)
     62              value = 0;
   \   00002C   0F43         MOV.W   #0x0, R15
     63          
     64              while(hex_value > 99) {
   \                     ??HEXtoBCD_1:
   \   00002E   3C906400     CMP.W   #0x64, R12
   \   000032   0438         JL      ??HEXtoBCD_4
     65                  hex_value -= 100;
   \   000034   3C509CFF     ADD.W   #0xff9c, R12
     66                  value += 1;
   \   000038   1F53         ADD.W   #0x1, R15
   \   00003A   F93F         JMP     ??HEXtoBCD_1
     67              }
     68          
     69              display_line[line][start + 1] = 0x30 + value;
   \                     ??HEXtoBCD_4:
   \   00003C   0B12         PUSH.W  R11
   \   00003E   C14F0000     MOV.B   R15, 0(SP)
   \   000042   3B41         POP.W   R11
   \   000044   7B503000     ADD.B   #0x30, R11
   \   000048   084D         MOV.W   R13, R8
   \   00004A                RPT     #0xa
   \   00004A   4918085D     ADDX.W  R13, R8
   \   00004E   0E4A         MOV.W   R10, R14
   \   000050   0E58         ADD.W   R8, R14
   \   000052   CE4B....     MOV.B   R11, display_line + 1(R14)
     70              value = 0;
   \   000056   0F43         MOV.W   #0x0, R15
     71          
     72              while(hex_value > 9) {
   \                     ??HEXtoBCD_2:
   \   000058   3C900A00     CMP.W   #0xa, R12
   \   00005C   0438         JL      ??HEXtoBCD_5
     73                  hex_value -= 10;
   \   00005E   3C50F6FF     ADD.W   #0xfff6, R12
     74                  value += 1;
   \   000062   1F53         ADD.W   #0x1, R15
   \   000064   F93F         JMP     ??HEXtoBCD_2
     75              }
     76          
     77              display_line[line][start + 2] = 0x30 + value;
   \                     ??HEXtoBCD_5:
   \   000066   0B12         PUSH.W  R11
   \   000068   C14F0000     MOV.B   R15, 0(SP)
   \   00006C   3B41         POP.W   R11
   \   00006E   7B503000     ADD.B   #0x30, R11
   \   000072   084D         MOV.W   R13, R8
   \   000074                RPT     #0xa
   \   000074   4918085D     ADDX.W  R13, R8
   \   000078   0E4A         MOV.W   R10, R14
   \   00007A   0E58         ADD.W   R8, R14
   \   00007C   CE4B....     MOV.B   R11, display_line + 2(R14)
     78              display_line[line][start + 3] = 0x30 + hex_value;
   \   000080   0B12         PUSH.W  R11
   \   000082   C14C0000     MOV.B   R12, 0(SP)
   \   000086   3B41         POP.W   R11
   \   000088   7B503000     ADD.B   #0x30, R11
   \   00008C   084D         MOV.W   R13, R8
   \   00008E                RPT     #0xa
   \   00008E   4918085D     ADDX.W  R13, R8
   \   000092   0E4A         MOV.W   R10, R14
   \   000094   0E58         ADD.W   R8, R14
   \   000096   CE4B....     MOV.B   R11, display_line + 3(R14)
     79          }
   \   00009A   3817         POPM.W  #0x4, R11
   \   00009C   1001         RETA
     80          
     81          

   \                                 In  segment CODE, align 2
     82          int additionSafe(int val, int max, int min, int increment) {
   \                     additionSafe:
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   064F         MOV.W   R15, R6
     83              long res = val + increment;
   \   000008   0E4B         MOV.W   R11, R14
   \   00000A   0E56         ADD.W   R6, R14
   \   00000C   0F4E         MOV.W   R14, R15
   \   00000E   0F5F         RLA.W   R15
   \   000010   0F7F         SUBC.W  R15, R15
   \   000012   3FE3         XOR.W   #0xffff, R15
     84          
     85              if(res > (long)max) res = (long)max;
   \   000014   084D         MOV.W   R13, R8
   \   000016   0948         MOV.W   R8, R9
   \   000018   0959         RLA.W   R9
   \   00001A   0979         SUBC.W  R9, R9
   \   00001C   39E3         XOR.W   #0xffff, R9
   \   00001E   099F         CMP.W   R15, R9
   \   000020   0338         JL      ??additionSafe_0
   \   000022   0920         JNE     ??additionSafe_1
   \   000024   089E         CMP.W   R14, R8
   \   000026   072C         JC      ??additionSafe_1
   \                     ??additionSafe_0:
   \   000028   084D         MOV.W   R13, R8
   \   00002A   0948         MOV.W   R8, R9
   \   00002C   0959         RLA.W   R9
   \   00002E   0979         SUBC.W  R9, R9
   \   000030   39E3         XOR.W   #0xffff, R9
   \   000032   0E48         MOV.W   R8, R14
   \   000034   0F49         MOV.W   R9, R15
     86          
     87              if(res < (long)min) res = (long)min;
   \                     ??additionSafe_1:
   \   000036   084A         MOV.W   R10, R8
   \   000038   0948         MOV.W   R8, R9
   \   00003A   0959         RLA.W   R9
   \   00003C   0979         SUBC.W  R9, R9
   \   00003E   39E3         XOR.W   #0xffff, R9
   \   000040   0F99         CMP.W   R9, R15
   \   000042   0338         JL      ??additionSafe_2
   \   000044   0920         JNE     ??additionSafe_3
   \   000046   0E98         CMP.W   R8, R14
   \   000048   072C         JC      ??additionSafe_3
   \                     ??additionSafe_2:
   \   00004A   084A         MOV.W   R10, R8
   \   00004C   0948         MOV.W   R8, R9
   \   00004E   0959         RLA.W   R9
   \   000050   0979         SUBC.W  R9, R9
   \   000052   39E3         XOR.W   #0xffff, R9
   \   000054   0E48         MOV.W   R8, R14
   \   000056   0F49         MOV.W   R9, R15
     88          
     89              return (int)res;
   \                     ??additionSafe_3:
   \   000058   0C4E         MOV.W   R14, R12
   \   00005A   5617         POPM.W  #0x6, R11
   \   00005C   1001         RETA
     90          }
     91          

   \                                 In  segment CODE, align 2
     92          int multSafe(int a, int b) {
   \                     multSafe:
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
     93              if(a == 0 || b == 0) return 0;
   \   000006   0A93         CMP.W   #0x0, R10
   \   000008   0224         JEQ     ??multSafe_3
   \   00000A   0B93         CMP.W   #0x0, R11
   \   00000C   0220         JNE     ??multSafe_4
   \                     ??multSafe_3:
   \   00000E   0C43         MOV.W   #0x0, R12
   \   000010   353C         JMP     ??multSafe_0
     94          
     95              int res = a * b;
   \                     ??multSafe_4:
   \   000012   0212         PUSH.W  SR
   \   000014   32C2         DINT
   \   000016   0343         NOP
   \   000018   824A....     MOV.W   R10, &__iar_HWMUL              // MPY
   \   00001C   824B....     MOV.W   R11, &__iar_HWMUL + 8          // OP2
   \   000020   1842....     MOV.W   &__iar_HWMUL + 10, R8          // RESLO
   \   000024   0343         NOP
   \   000026   3241         POP.W   SR
     96          
     97              if(a == res / b)return res;
   \   000028   0C48         MOV.W   R8, R12
   \   00002A   0E4B         MOV.W   R11, R14
   \   00002C   ........     CALLA   #?DivMod16s
   \   000030   0A9C         CMP.W   R12, R10
   \   000032   0220         JNE     ??multSafe_5
   \   000034   0C48         MOV.W   R8, R12
   \   000036   223C         JMP     ??multSafe_0
     98              return (INT_MAX) * (a < 0 ? -1 : 1) * (b < 0 ? -1 : 1);
   \                     ??multSafe_5:
   \   000038   0A93         CMP.W   #0x0, R10
   \   00003A   0234         JGE     ??multSafe_6
   \   00003C   3F43         MOV.W   #0xffff, R15
   \   00003E   013C         JMP     ??multSafe_1
   \                     ??multSafe_6:
   \   000040   1F43         MOV.W   #0x1, R15
   \                     ??multSafe_1:
   \   000042   0B93         CMP.W   #0x0, R11
   \   000044   0234         JGE     ??multSafe_7
   \   000046   3B43         MOV.W   #0xffff, R11
   \   000048   013C         JMP     ??multSafe_2
   \                     ??multSafe_7:
   \   00004A   1B43         MOV.W   #0x1, R11
   \                     ??multSafe_2:
   \   00004C   0212         PUSH.W  SR
   \   00004E   32C2         DINT
   \   000050   0343         NOP
   \   000052   824F....     MOV.W   R15, &__iar_HWMUL              // MPY
   \   000056   824B....     MOV.W   R11, &__iar_HWMUL + 8          // OP2
   \   00005A   1F42....     MOV.W   &__iar_HWMUL + 10, R15         // RESLO
   \   00005E   0343         NOP
   \   000060   3241         POP.W   SR
   \   000062   0212         PUSH.W  SR
   \   000064   32C2         DINT
   \   000066   0343         NOP
   \   000068   824F....     MOV.W   R15, &__iar_HWMUL              // MPY
   \   00006C   B240FF7F.... MOV.W   #0x7fff, &__iar_HWMUL + 8      // OP2
   \   000072   1C42....     MOV.W   &__iar_HWMUL + 10, R12         // RESLO
   \   000076   0343         NOP
   \   000078   3241         POP.W   SR
   \   00007A   0343         NOP
   \                     ??multSafe_0:
   \   00007C   3817         POPM.W  #0x4, R11
   \   00007E   1001         RETA
     99          }

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     14   HEXtoBCD
      8   absVal
     16   additionSafe
      8   centerStringToDisplay
        8   -> strcpy
        8   -> strlen
     12   charInString
       12   -> strlen
     14   multSafe
       12 ?DivMod16s
      6   stoi
     16   subStringPos
       16   -> strlen


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     158  HEXtoBCD
      42  absVal
      94  additionSafe
      44  centerStringToDisplay
      46  charInString
     128  multSafe
      62  stoi
      88  subStringPos

 
 662 bytes in segment CODE
 
 662 bytes of CODE memory

Errors: none
Warnings: none
